(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * App.min.js
 * @description Require the main application modules.
 */

var ComponentDomParser = require("componentdomparser"),
    ScrollReveal = require('scrollReveal'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex();

// Register the base modules.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('parallaxStage', require('./Components/ParallaxStage/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentParser.
var parser = new ComponentDomParser({
    dataSelector: 'component', // Equals [data-component="*"]
    componentIndex: componentStore.getIndex(),
    componentDidMountCallback: function(instance, el, dataset) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        // Initialize the module.
        instance.initialize.call(instance, el, dataset);

        return instance;
    }
});

// Parse the document for all [data-component] nodes.
parser.parse();

var scrollReveal = new ScrollReveal();
},{"./Components/ClassToggler/View.js":2,"./Components/ParallaxStage/View.js":3,"./Components/ScrollTo/View.js":4,"./Utilities/ComponentIndex/Util.js":5,"componentdomparser":8,"scrollReveal":9}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ClassToggler}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":6}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    setTransform = require('./../../Utilities/Helpers').setTransform,
    ParallaxStage;

/**
 * ParallaxStage
 * @description Creates a subtle parallax scrolling effect on some child elements.
 * @constructor
 */
ParallaxStage = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the parallax values will be based on.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ParallaxStage}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.targets = document.querySelectorAll(dataset.target || '[data-parallax]');
        this.set('lastScrollTop', 0);

        // Setup the rAF.
        var self = this,
            _animFrame;

        (function animloop(){
            self.render();
            _animFrame = window.requestAnimationFrame(animloop);
        }());

        return this;
    },

    render: function() {
        'use strict';

        var currentScrollTop = document.body.scrollTop,
            lastScrollTop = this.get('lastScrollTop');

        if(currentScrollTop === lastScrollTop) {
            return this;
        }

        this.set('lastScrollTop', currentScrollTop);
        this.adjustPositions(currentScrollTop);

        return this;
    },
    adjustPositions: function(scrollTop) {
        'use strict';

        var stageOffset = this.el.offsetTop,
            scrollPos = scrollTop - stageOffset;

        this.setElementsTransformValue(this.targets[0], scrollPos);
        this.setElementsTransformValue(this.targets[1], scrollPos);

        return this;
    },
    setElementsTransformValue: function(element, scrollPos) {
        'use strict';

        var val = Math.round(scrollPos / (Math.abs(element.dataset.parallaxfactor) || 1));

        setTransform(element, 'translateY(' + val + 'px)');

        return this;
    }
});

module.exports = ParallaxStage;
},{"./../../Utilities/Helpers":7,"componentPrototype":6}],4:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ScrollTo}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":7,"componentPrototype":6}],5:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        console.info('Component ' + key + ' was already registered in this index.', this);
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],6:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll Weiß
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function(el) {
                this.el = el;
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":7}],7:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },
    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    },
    setTransform: function(element, prop) {
        'use strict';

        element.style.webkitTransform = prop;
        element.style.MozTransform = prop;
        element.style.msTransform = prop;
        element.style.OTransform = prop;
        element.style.transform = prop;
    }
};

module.exports = helpers;
},{}],8:[function(require,module,exports){
/* ComponentDomParser 0.0.1 | @license ISC */

(function (global, factory) {
    "use strict";

    // If the env is browserify, export the factory using the module object.
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global);

        // If the env is AMD, register the Module as 'ComponentDomParser'.
    } else if (global.define && typeof global.define === "function" && global.define.amd) {
        global.define("ComponentDomParser", [], function () {
            return factory(global);
        });

        // If the env is a browser(without CJS or AMD support), export the factory into the global window object.
    } else {
        global.ComponentDomParser = factory(global);
    }
})(window, function (global) {
    "use strict";

    var doc = global.document;

    /*
     * ComponentDomParser
     * @param options {Object} The options Object which initializes the parser.
     * @example
     * // Initialize a new instance of the ComponentDomParser.
     * var parser = new window.ComponentDomParser({
     *     dataSelector: 'app',
     *     componentIndex: {
     *         'myApplication': function(el) { el.innerHTML = 'myApplication initialized!' }
     *     },
     *     componentDidMountCallback: function(instance) {
     *         console.log(instance);
     *     }
     * });
     *
     * // Parse the document for all [data-app] nodes.
     * parser.parse();
     * @constructor
     */
    var ComponentDomParser = function (options) {
        this._checkForRequiredConstants(options);

        this.contextElement = options.contextElement || doc.body;
        this.dataSelector = options.dataSelector;
        this.componentIndex = options.componentIndex;
        this.componentDidMountCallback = options.componentDidMountCallback;
    };

    ComponentDomParser.prototype._checkForRequiredConstants = function (options) {
        if (!options) {
            throw new Error("ComponentDomParser Error: No option object was specified.");
        }

        if (!options.dataSelector) {
            throw new Error("ComponentDomParser Error: No dataSelector was specified.");
        }

        if (!options.componentIndex) {
            throw new Error("ComponentDomParser Error: No componentIndex was specified.");
        }

        if (options.componentDidMountCallback && typeof options.componentDidMountCallback !== "function") {
            throw new Error("ComponentDomParser Error: The componentDidMountCallback option must be a function.");
        }
    };

    ComponentDomParser.prototype.parse = function () {
        var elementNodeList = this.contextElement.querySelectorAll("[data-" + this.dataSelector + "]");
        var elementNodes = Array.prototype.slice.call(elementNodeList, 0);
        var self = this;

        elementNodes.forEach(function (node) {
            var componentKey = node.dataset[self.dataSelector];
            var Component = self.componentIndex[componentKey];

            if (Component) {
                self._mountComponent(node, Component);
            } else {
                console.info("ComponentDomParser Info: Component \"" + componentKey + "\" is not present in the passed componentIndex:", self.componentIndex);
            }
        });

        return this;
    };

    ComponentDomParser.prototype._mountComponent = function (node, Component) {
        var instance = new Component(node);

        if (this.componentDidMountCallback) {
            this.componentDidMountCallback(instance);
        }

        return instance;
    };


    return ComponentDomParser;
});

},{}],9:[function(require,module,exports){

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.scrollReveal = factory();
  }
}(this, function(require, exports, module) {

/*
                       _ _ _____                      _   _
                      | | |  __ \                    | | (_)
    ___  ___ _ __ ___ | | | |__) |_____   _____  __ _| |  _ ___
   / __|/ __| '__/ _ \| | |  _  // _ \ \ / / _ \/ _` | | | / __|
   \__ \ (__| | | (_) | | | | \ \  __/\ V /  __/ (_| | |_| \__ \
   |___/\___|_|  \___/|_|_|_|  \_\___| \_/ \___|\__,_|_(_) |___/ v2.1.0
                                                        _/ |
                                                       |__/

============================================================================*/

/**
 * scrollReveal.js (c) 2014 Julian Lloyd ( @julianlloyd )
 *
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */

window.scrollReveal = (function( window ) {

  'use strict'

  var _requestAnimFrame
    , extend
    , handler
    , self

  function scrollReveal( config ) {

    self         = this
    self.elems   = {}
    self.serial  = 1
    self.blocked = false
    self.config  = extend( self.defaults, config )

    if ( self.isMobile() && !self.config.mobile || !self.isSupported() ) {
      self.destroy()
      return
    }

    if ( self.config.viewport == window.document.documentElement ) {

      window.addEventListener( 'scroll', handler, false )
      window.addEventListener( 'resize', handler, false )

    } else self.config.viewport.addEventListener( 'scroll', handler, false )

    self.init( true )
  }

  scrollReveal.prototype = {

    defaults: {

      enter:    'bottom',
      move:     '8px',
      over:     '0.6s',
      wait:     '0s',
      easing:   'ease',

      scale:    { direction: 'up', power: '5%' },

      opacity:  0,
      mobile:   false,
      reset:    false,
      viewport: window.document.documentElement, // <HTML> element by default.

      /**
       *        'always' — delay every time an animation resets
       *        'once'   — delay only the first time an animation reveals
       *        'onload' - delay only for animations triggered by self.init()
       */
      delay:    'once',

      /**
       *        vFactor changes when an element is considered in the viewport;
       *        the default requires 60% of an element be visible.
       */
      vFactor:  0.60,

      complete: function( el ) {} // Note: reset animations do not complete.
    },

    /**
     * Queries the DOM, builds scrollReveal elements and triggers animation.
     * @param {boolean} flag — a hook for controlling delay on first load.
     */
    init: function( flag ) {

      var serial
        , elem
        , query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {

        serial      = self.serial++
        elem        = self.elems[ serial ] = { domEl: el }
        elem.config = self.configFactory( elem )
        elem.styles = self.styleFactory( elem )
        elem.seen   = false

        el.removeAttribute( 'data-sr' )
        el.setAttribute( 'style',

            elem.styles.inline
          + elem.styles.initial
        )
      })

      self.scrolled = self.scrollY()
      self.animate( flag )
    },

    /**
     * Applies and removes appropriate styles.
     * @param {boolean} flag — a hook for controlling delay on first load.
     */
    animate: function( flag ) {

      var key
        , elem
        , visible
        , complete

      /**
       * Cleans the DOM and removes completed elements from self.elems.
       * @param {integer} key — self.elems property key.
       */
      complete = function( key ) {

        var elem = self.elems[ key ]

        setTimeout(function() {

          elem.domEl.setAttribute( 'style', elem.styles.inline )
          elem.config.complete( elem.domEl )
          delete self.elems[ key ]

        }, elem.styles.duration )
      }

      /**
       * Begin loop.
       */
      for ( key in self.elems ) {
        if ( self.elems.hasOwnProperty( key ) ) {

          elem    = self.elems[ key ]
          visible = self.isElemInViewport( elem )

          if ( visible ) {

            if ( self.config.delay === 'always'
            || ( self.config.delay === 'onload' && flag )
            || ( self.config.delay === 'once'   && !elem.seen ) ) {

              /**
               * Use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.transition
              )

            } else {

              /**
               * Don’t use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.reset
              )
            }

            elem.seen = true

            if ( !elem.config.reset && !elem.animating ) {

              /**
               * Reset is DISABLED for this element,
               * so let’s count down to animation complete.
               */
              elem.animating = true
              complete( key )
            }
          }

          if ( !visible && elem.config.reset ) {

            /**
             * Reset is ENABLED for this element,
             * so let’s apply its reset styles.
             */
            elem.domEl.setAttribute( 'style',

                elem.styles.inline
              + elem.styles.initial
              + elem.styles.reset
            )
          }
        }
      }

      self.blocked = false
    },

    /**
     * Parses an elements data-sr attribute, and returns a configuration object.
     * @param {object} elem — An object from self.elems.
     * @return {object}
     */
    configFactory: function( elem ) {

      var parsed = {}
        , config = {}
        , words  = elem.domEl.getAttribute( 'data-sr' ).split( /[, ]+/ )

      /**
       * Find and remove any syntax sugar.
       */
      words = self.filter( words )
      words.forEach(function( keyword, i ) {

        /**
         * Find keywords.
         */
        switch ( keyword ) {

          case 'enter':

            parsed.enter = words[ i + 1 ]
            return

          case 'wait':

            parsed.wait = words[ i + 1 ]
            return

          case 'move':

            parsed.move = words[ i + 1 ]
            return

          case 'ease':

            parsed.move = words[ i + 1 ]
            parsed.ease = 'ease'
            return

          case 'ease-in':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in'
            return

          case 'ease-in-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in-out'
            return

          case 'ease-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-out'
            return

          case 'hustle':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
            return

          case 'over':

            parsed.over = words[ i + 1 ]
            return

          case 'reset':

            if ( words[ i - 1 ] == 'no' ) parsed.reset = false
            else                          parsed.reset = true

            return

          case 'scale':

            parsed.scale = {}

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              return
            }

            parsed.scale.power = words[ i + 1 ]
            return

          default:
            return
        }
      })

      /**
       * Build default config object, then apply any
       * overrides parsed from the data-sr attribute.
       */
      config = extend( config, self.config )
      config = extend( config, parsed )

      if ( config.enter  == 'top'  || config.enter == 'bottom' ) config.axis = 'Y'
      if ( config.enter  == 'left' || config.enter == 'right'  ) config.axis = 'X'

      /**
       * Check for hustle easing.
       */
      if ( config.easing == 'hustle' ) config.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'

      /**
       * Let’s make sure our our pixel distances are negative for top and left.
       * e.g. "enter top and move 25px" starts at 'top: -25px' in CSS.
       */
      if ( config.enter == 'top' || config.enter == 'left' ) config.move = '-' + config.move

      return config

    },

    /**
     * Generates styles based on an elements configuration property.
     * @param {object} elem — An object from self.elems.
     * @return {object}
     */
    styleFactory: function( elem ) {

      var transition
        , initial
        , target
        , reset
        , inline
        , build

      inline = ( elem.domEl.getAttribute( 'style' ) ) ? elem.domEl.getAttribute( 'style' ) + '; visibility: visible; ' : 'visibility: visible; '

      /**
       * Want to disable delay on mobile devices? Uncomment the line below.
       */
      //if ( self.isMobile() && self.config.mobile ) elem.config.wait = 0

      transition = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                  '-webkit-perspective: 1000;' +
          '-webkit-backface-visibility: hidden;'

      reset      = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                  '-webkit-perspective: 1000; ' +
          '-webkit-backface-visibility: hidden; '

      /**
       * Constructs initial and target styles.
       */
      build = function() {

        if ( parseInt( elem.config.move ) != 0 ) {

          initial += ' translate' + elem.config.axis + '(' + elem.config.move + ')'
          target  += ' translate' + elem.config.axis + '(0)'
        }

        if ( parseInt( elem.config.scale.power ) != 0 ) {

          if ( elem.config.scale.direction == 'up'   ) elem.config.scale.value = 1 - ( parseFloat( elem.config.scale.power ) * 0.01 )
          if ( elem.config.scale.direction == 'down' ) elem.config.scale.value = 1 + ( parseFloat( elem.config.scale.power ) * 0.01 )

          initial += ' scale(' + elem.config.scale.value + ')'
          target  += ' scale(1)'
        }

        initial += '; opacity: ' + elem.config.opacity + '; '
        target  += '; opacity: 1; ';
      }

      initial = 'transform:'
      target  = 'transform:'

      build()

      /**
       * Build again for webkit.
       */
      initial += '-webkit-transform:'
      target  += '-webkit-transform:'

      build()

      return {

        transition: transition,
        initial:    initial,
        target:     target,
        reset:      reset,
        inline:     inline,
        duration:   ( ( parseFloat( elem.config.over ) + parseFloat( elem.config.wait ) ) * 1000 )
      }
    },

    filter: function( words ) {

      var filtered  = []

      var sugar = [

        'from',
        'the',
        'and',
        'then',
        'but',
        'with',
        'please',
      ]

      words.forEach(function( word ) {

        if ( sugar.indexOf( word ) > -1 ) return

        filtered.push( word )
        return
      })

      return filtered
    },

    getViewportH: function() {

      var client = self.config.viewport[ 'clientHeight' ]
        , inner  = window[ 'innerHeight' ]

      if ( self.config.viewport == window.document.documentElement ) {

        return ( client < inner ) ? inner : client
      }

      return client
    },

    scrollY: function() {

      if ( self.config.viewport == window.document.documentElement ) return window.pageYOffset

      return self.config.viewport.scrollTop + self.config.viewport.offsetTop
    },

    getOffset: function( el ) {

      var offsetTop  = 0
        , offsetLeft = 0

      do {

        if ( !isNaN( el.offsetTop  )) offsetTop  += el.offsetTop
        if ( !isNaN( el.offsetLeft )) offsetLeft += el.offsetLeft

      } while ( el = el.offsetParent )

      return {

        top: offsetTop,
        left: offsetLeft
      }
    },

    isElemInViewport: function( elem ) {

      var elHeight = elem.domEl.offsetHeight
        , elTop    = self.getOffset( elem.domEl ).top
        , elBottom = elTop + elHeight
        , vFactor  = elem.config.vFactor || 0

      return ( elTop + elHeight * vFactor < self.scrolled + self.getViewportH() )
          && ( elBottom - elHeight * vFactor > self.scrolled )
          || ( elem.domEl.currentStyle ? elem.domEl.currentStyle : window.getComputedStyle( elem.domEl, null ) ).position == 'fixed'
    },

    isMobile: function() {

      var agent = navigator.userAgent || navigator.vendor || window.opera

      return (/(ipad|playbook|silk|android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test( agent )||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test( agent.substr( 0, 4 ))) ? true : false
    },

    isSupported: function() {

      var sensor    = document.createElement( 'sensor' )
        , cssPrefix = 'Webkit,Moz,O,'.split( ',' )
        , tests     = ( 'transition ' + cssPrefix.join( 'transition,' ) ).split( ',' )

      for ( var i = 0; i < tests.length; i++ ) {

        if ( !sensor.style[tests[i]] === '' ) return false
      }

      return true
    },

    destroy: function() {

      var query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {
        el.removeAttribute( 'data-sr' )
      })
    }

  }

  handler = function( e ) {

    if ( !self.blocked ) {

      self.blocked  = true
      self.scrolled = self.scrollY()

      _requestAnimFrame( function() {

        self.animate()
      })
    }
  }

  extend = function( target, src ) {

    for ( var prop in src ) {

      if ( src.hasOwnProperty( prop ) ) {

        target[ prop ] = src[ prop ]
      }
    }

    return target
  }

  /**
   * RequestAnimationFrame polyfill.
   */
  _requestAnimFrame = (function() {

    return window.requestAnimationFrame        ||
           window.webkitRequestAnimationFrame  ||
           window.mozRequestAnimationFrame     ||

          function( callback ) {

            window.setTimeout( callback, 1000 / 60 )
          }
  }())

  return scrollReveal

})( window )

return scrollReveal;

}));

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9jb21wb25lbnRkb21wYXJzZXIvRGlzdC9Db21wb25lbnREb21QYXJzZXIuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9ub2RlX21vZHVsZXMvc2Nyb2xsUmV2ZWFsL2Rpc3Qvc2Nyb2xsUmV2ZWFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBBcHAubWluLmpzXG4gKiBAZGVzY3JpcHRpb24gUmVxdWlyZSB0aGUgbWFpbiBhcHBsaWNhdGlvbiBtb2R1bGVzLlxuICovXG5cbnZhciBDb21wb25lbnREb21QYXJzZXIgPSByZXF1aXJlKFwiY29tcG9uZW50ZG9tcGFyc2VyXCIpLFxuICAgIFNjcm9sbFJldmVhbCA9IHJlcXVpcmUoJ3Njcm9sbFJldmVhbCcpLFxuICAgIENvbXBvbmVudEluZGV4ID0gcmVxdWlyZSgnLi9VdGlsaXRpZXMvQ29tcG9uZW50SW5kZXgvVXRpbC5qcycpLFxuICAgIGNvbXBvbmVudFN0b3JlID0gbmV3IENvbXBvbmVudEluZGV4KCk7XG5cbi8vIFJlZ2lzdGVyIHRoZSBiYXNlIG1vZHVsZXMuXG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcignY2xhc3NUb2dnbGVyJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL0NsYXNzVG9nZ2xlci9WaWV3LmpzJykpO1xuY29tcG9uZW50U3RvcmUucmVnaXN0ZXIoJ3BhcmFsbGF4U3RhZ2UnLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvUGFyYWxsYXhTdGFnZS9WaWV3LmpzJykpO1xuY29tcG9uZW50U3RvcmUucmVnaXN0ZXIoJ3Njcm9sbFRvJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL1Njcm9sbFRvL1ZpZXcuanMnKSk7XG5cbi8vIFNldHMgdXAgdGhlIGNvbXBvbmVudFBhcnNlci5cbnZhciBwYXJzZXIgPSBuZXcgQ29tcG9uZW50RG9tUGFyc2VyKHtcbiAgICBkYXRhU2VsZWN0b3I6ICdjb21wb25lbnQnLCAvLyBFcXVhbHMgW2RhdGEtY29tcG9uZW50PVwiKlwiXVxuICAgIGNvbXBvbmVudEluZGV4OiBjb21wb25lbnRTdG9yZS5nZXRJbmRleCgpLFxuICAgIGNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2s6IGZ1bmN0aW9uKGluc3RhbmNlLCBlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYoIWluc3RhbmNlLmluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vZHVsZS5cbiAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZS5jYWxsKGluc3RhbmNlLCBlbCwgZGF0YXNldCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn0pO1xuXG4vLyBQYXJzZSB0aGUgZG9jdW1lbnQgZm9yIGFsbCBbZGF0YS1jb21wb25lbnRdIG5vZGVzLlxucGFyc2VyLnBhcnNlKCk7XG5cbnZhciBzY3JvbGxSZXZlYWwgPSBuZXcgU2Nyb2xsUmV2ZWFsKCk7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIENsYXNzVG9nZ2xlcjtcblxuLyoqXG4gKiBDbGFzc1RvZ2dsZXJcbiAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIGEgY2xhc3Mgb24gYSB0YXJnZXQgZWxlbWVudCBvbiBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5DbGFzc1RvZ2dsZXIgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmVsLmRhdGFzZXQ7XG5cbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFzZXQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zZXQoJ2NsYXNzJywgZGF0YXNldC5jbGFzcyB8fCAnYWN0aXZlJyk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xlQ2xhc3NcbiAgICAgKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyB0aGUgY2xhc3Mgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtDbGFzc1RvZ2dsZXJ9XG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy50YXJnZXRbMF0uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmdldCgnY2xhc3MnKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NUb2dnbGVyOyIsInZhciBjb21wb25lbnRQcm90b3R5cGUgPSByZXF1aXJlKCdjb21wb25lbnRQcm90b3R5cGUnKSxcbiAgICBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLy4uLy4uL1V0aWxpdGllcy9IZWxwZXJzJykuc2V0VHJhbnNmb3JtLFxuICAgIFBhcmFsbGF4U3RhZ2U7XG5cbi8qKlxuICogUGFyYWxsYXhTdGFnZVxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBzdWJ0bGUgcGFyYWxsYXggc2Nyb2xsaW5nIGVmZmVjdCBvbiBzb21lIGNoaWxkIGVsZW1lbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBhcmFsbGF4U3RhZ2UgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIHBhcmFsbGF4IHZhbHVlcyB3aWxsIGJlIGJhc2VkIG9uLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtQYXJhbGxheFN0YWdlfVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmVsLmRhdGFzZXQ7XG5cbiAgICAgICAgdGhpcy50YXJnZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhc2V0LnRhcmdldCB8fCAnW2RhdGEtcGFyYWxsYXhdJyk7XG4gICAgICAgIHRoaXMuc2V0KCdsYXN0U2Nyb2xsVG9wJywgMCk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGhlIHJBRi5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgX2FuaW1GcmFtZTtcblxuICAgICAgICAoZnVuY3Rpb24gYW5pbWxvb3AoKXtcbiAgICAgICAgICAgIHNlbGYucmVuZGVyKCk7XG4gICAgICAgICAgICBfYW5pbUZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltbG9vcCk7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgbGFzdFNjcm9sbFRvcCA9IHRoaXMuZ2V0KCdsYXN0U2Nyb2xsVG9wJyk7XG5cbiAgICAgICAgaWYoY3VycmVudFNjcm9sbFRvcCA9PT0gbGFzdFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldCgnbGFzdFNjcm9sbFRvcCcsIGN1cnJlbnRTY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmFkanVzdFBvc2l0aW9ucyhjdXJyZW50U2Nyb2xsVG9wKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGFkanVzdFBvc2l0aW9uczogZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgc3RhZ2VPZmZzZXQgPSB0aGlzLmVsLm9mZnNldFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHNjcm9sbFRvcCAtIHN0YWdlT2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuc2V0RWxlbWVudHNUcmFuc2Zvcm1WYWx1ZSh0aGlzLnRhcmdldHNbMF0sIHNjcm9sbFBvcyk7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudHNUcmFuc2Zvcm1WYWx1ZSh0aGlzLnRhcmdldHNbMV0sIHNjcm9sbFBvcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlOiBmdW5jdGlvbihlbGVtZW50LCBzY3JvbGxQb3MpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciB2YWwgPSBNYXRoLnJvdW5kKHNjcm9sbFBvcyAvIChNYXRoLmFicyhlbGVtZW50LmRhdGFzZXQucGFyYWxsYXhmYWN0b3IpIHx8IDEpKTtcblxuICAgICAgICBzZXRUcmFuc2Zvcm0oZWxlbWVudCwgJ3RyYW5zbGF0ZVkoJyArIHZhbCArICdweCknKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxheFN0YWdlOyIsInZhciBjb21wb25lbnRQcm90b3R5cGUgPSByZXF1aXJlKCdjb21wb25lbnRQcm90b3R5cGUnKSxcbiAgICBlYXNlSW5PdXRRdWFkID0gcmVxdWlyZSgnLi8uLi8uLi9VdGlsaXRpZXMvSGVscGVycycpLmVhc2VJbk91dFF1YWQsXG4gICAgU2Nyb2xsVG87XG5cbi8qKlxuICogU2Nyb2xsVG9cbiAqIEBkZXNjcmlwdGlvbiBTY3JvbGxzIHRvIGEgY2VydGFpbiB0YXJnZXQgZWxlbWVudCBvbiB0aGUgZWxlbWVudHMgY2xpY2suXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuU2Nyb2xsVG8gPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7U2Nyb2xsVG99XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuZWwuZGF0YXNldDtcblxuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQpWzBdO1xuICAgICAgICB0aGlzLnNldCgnZHVyYXRpb24nLCBkYXRhc2V0LmR1cmF0aW9uIHx8IDYwMCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9UYXJnZXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xsVG9UYXJnZXRcbiAgICAgKiBAZGVzY3JpcHRpb24gU2Nyb2xscyB0byB0aGUgdGFyZ2V0LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBzY3JvbGxUb1RhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB0byA9IHRoaXMudGFyZ2V0Lm9mZnNldFRvcCxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoJ2R1cmF0aW9uJyksXG4gICAgICAgICAgICBzdGFydCA9IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgY2hhbmdlID0gdG8gLSBzdGFydCxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gMCxcbiAgICAgICAgICAgIGluY3JlbWVudCA9IDIwO1xuXG4gICAgICAgIHZhciBhbmltYXRlU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIHZhciB2YWwgPSBlYXNlSW5PdXRRdWFkKGN1cnJlbnRUaW1lLCBzdGFydCwgY2hhbmdlLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFuaW1hdGVTY3JvbGwsIGluY3JlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGVTY3JvbGwoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxUbzsiLCJ2YXIgQ29tcG9uZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmluZGV4ID0ge307XG59O1xuQ29tcG9uZW50SW5kZXgucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5LCBDb25zdHJ1Y3Rvcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmKCFrZXkgfHwgIUNvbnN0cnVjdG9yIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBDb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZih0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDb21wb25lbnQgJyArIGtleSArICcgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGlzIGluZGV4LicsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcbkNvbXBvbmVudEluZGV4LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmluZGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50SW5kZXg7IiwiLyoqXG4gKiBNb2R1bGVQcm90b3R5cGVcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc2V0IG9mIGhhbmR5IGZ1bmN0aW9ucyBhbmQgcmVmZXJlbmNlIHRoZW0gdG8gYSB0YXJnZXQgZS5nLjpcbiAqIEBhdXRob3IgVHlsbCBXZWnDn1xuICovXG5cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vSGVscGVycy5qcycpLmV4dGVuZDtcblxudmFyIFByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXRpYWxpemVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEEgZHVtbXkgaW5pdGlhbGl6ZSBmdW5jdGlvbiB3aGljaCBzZXQncyBnaXZlbiBhdHRyaWJ1dGVzIG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHtvYmplY3QgfHwgc3RyaW5nfSBUaGUgYXR0cmlidXRlKHMpIHRvIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBJZiBhdHRyaWJ1dGVzIHdoZXJlIHBhc3NlZCwgc2V0IHRoZW0gb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgaWYoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYSBrZXkgJiB2YWwgcGFpciBvbiB0aGUgbW9kdWxlIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gdmFsIHtzdHJpbmd9IFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmosIGlmIHRydWUgLSBzZXQgZWFjaCBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uKG9iaktleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W29iaktleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgc2V0IHRoZSBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bnNldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5zZXQvRGVsZXRlIGEga2V5IGZyb20gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB1bnNldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgdmFsdWUgb2YgYW4ga2V5IGluIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byBsb29rIGZvciBpbiB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBib29sIHdoaWNoIGluZGljYXRlcyBpZiBhbiBhdHRyaWJ1dGUgd2FzIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0ciB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgaW5pdGlhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIG1vZHVsZSwgaW52b2tlcyBhIG5ldyBtb2R1bGUgQ29uc3RydWN0b3IgYW5kIGV4dGVuZHMgdGhlIHByb3RvdHlwZSB3aXRoIGFsbCBmdW5jdGlvbnMgZm91bmQgaW4gdGhpcyBvYmplY3QuXG4gICAgICAgICAqIEBleGFtcGxlIFByb3RvdHlwZS5leHRlbmQoe29iamVjdH0pO1xuICAgICAgICAgKiBAcGFyYW0gcHJvdG90eXBlUHJvcHMge29iamVjdH0gQSBzZXQgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjcmVhdGVkIENvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgICBvYmogPSBvYmogPyBvYmogOiB7fTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGZ1bmN0aW9uIHdyYXBwZXIuXG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdpdGggdGhlIGJhc2UgZnVuY3Rpb25zLCBhcyB3ZWxsIGFzIHRoZSBwcm90b1Byb3BzXG4gICAgICAgICAgICBleHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB0aGlzLCBvYmopO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHRhcmdldCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWl4aW5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIE1peCBhIHNldCBvZiBmdW5jdGlvbnMgaW50byB0aGUgY3VycmVudCBwcm90b3R5cGUuXG4gICAgICAgICAqIEBleGFtcGxlIHRoaXMubWl4aW4oeyBnZXRGb3VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDIrMjsgfSB9KTtcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB7T2JqZWN0fSBUaGUgcHJvdG90eXBlLCB0byBtaXggdGhlIE9iaiBpbnRvLlxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtvYmplY3R9IEEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgb24gdGhlIGN1cnJlbnQgcHJvdG90eXBlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IGZ1bmN0aW9uKHRhcmdldCwgb2JqKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iaiA9IG9iaiA/IG9iaiA6IHt9O1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIGlmKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSB0YXJnZXQgZnVuY3Rpb24gd2l0aCB0aGUgYmFzZSBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIHByb3RvUHJvcHNcbiAgICAgICAgICAgIGV4dGVuZCh0YXJnZXQsIG9iaik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b3R5cGU7IiwidmFyIGhlbHBlcnMgPSB7XG4gICAgZXh0ZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoIGkgPT09IGxlbmd0aCApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24oY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZWRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUaW1lLS07XG5cbiAgICAgICAgcmV0dXJuIC1jaGFuZ2VkVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5Nb3pUcmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5PVHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBwcm9wO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGVscGVyczsiLCIvKiBDb21wb25lbnREb21QYXJzZXIgMC4wLjEgfCBAbGljZW5zZSBJU0MgKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIElmIHRoZSBlbnYgaXMgYnJvd3NlcmlmeSwgZXhwb3J0IHRoZSBmYWN0b3J5IHVzaW5nIHRoZSBtb2R1bGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKTtcblxuICAgICAgICAvLyBJZiB0aGUgZW52IGlzIEFNRCwgcmVnaXN0ZXIgdGhlIE1vZHVsZSBhcyAnQ29tcG9uZW50RG9tUGFyc2VyJy5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kZWZpbmUgJiYgdHlwZW9mIGdsb2JhbC5kZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBnbG9iYWwuZGVmaW5lLmFtZCkge1xuICAgICAgICBnbG9iYWwuZGVmaW5lKFwiQ29tcG9uZW50RG9tUGFyc2VyXCIsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShnbG9iYWwpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJZiB0aGUgZW52IGlzIGEgYnJvd3Nlcih3aXRob3V0IENKUyBvciBBTUQgc3VwcG9ydCksIGV4cG9ydCB0aGUgZmFjdG9yeSBpbnRvIHRoZSBnbG9iYWwgd2luZG93IG9iamVjdC5cbiAgICB9IGVsc2Uge1xuICAgICAgICBnbG9iYWwuQ29tcG9uZW50RG9tUGFyc2VyID0gZmFjdG9yeShnbG9iYWwpO1xuICAgIH1cbn0pKHdpbmRvdywgZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcblxuICAgIC8qXG4gICAgICogQ29tcG9uZW50RG9tUGFyc2VyXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gVGhlIG9wdGlvbnMgT2JqZWN0IHdoaWNoIGluaXRpYWxpemVzIHRoZSBwYXJzZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBJbml0aWFsaXplIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBDb21wb25lbnREb21QYXJzZXIuXG4gICAgICogdmFyIHBhcnNlciA9IG5ldyB3aW5kb3cuQ29tcG9uZW50RG9tUGFyc2VyKHtcbiAgICAgKiAgICAgZGF0YVNlbGVjdG9yOiAnYXBwJyxcbiAgICAgKiAgICAgY29tcG9uZW50SW5kZXg6IHtcbiAgICAgKiAgICAgICAgICdteUFwcGxpY2F0aW9uJzogZnVuY3Rpb24oZWwpIHsgZWwuaW5uZXJIVE1MID0gJ215QXBwbGljYXRpb24gaW5pdGlhbGl6ZWQhJyB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2s6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICogICAgICAgICBjb25zb2xlLmxvZyhpbnN0YW5jZSk7XG4gICAgICogICAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIFBhcnNlIHRoZSBkb2N1bWVudCBmb3IgYWxsIFtkYXRhLWFwcF0gbm9kZXMuXG4gICAgICogcGFyc2VyLnBhcnNlKCk7XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIENvbXBvbmVudERvbVBhcnNlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUmVxdWlyZWRDb25zdGFudHMob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0RWxlbWVudCA9IG9wdGlvbnMuY29udGV4dEVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gICAgICAgIHRoaXMuZGF0YVNlbGVjdG9yID0gb3B0aW9ucy5kYXRhU2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29tcG9uZW50SW5kZXggPSBvcHRpb25zLmNvbXBvbmVudEluZGV4O1xuICAgICAgICB0aGlzLmNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2sgPSBvcHRpb25zLmNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2s7XG4gICAgfTtcblxuICAgIENvbXBvbmVudERvbVBhcnNlci5wcm90b3R5cGUuX2NoZWNrRm9yUmVxdWlyZWRDb25zdGFudHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudERvbVBhcnNlciBFcnJvcjogTm8gb3B0aW9uIG9iamVjdCB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5kYXRhU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudERvbVBhcnNlciBFcnJvcjogTm8gZGF0YVNlbGVjdG9yIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNvbXBvbmVudEluZGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnREb21QYXJzZXIgRXJyb3I6IE5vIGNvbXBvbmVudEluZGV4IHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcG9uZW50RGlkTW91bnRDYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucy5jb21wb25lbnREaWRNb3VudENhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbXBvbmVudERvbVBhcnNlciBFcnJvcjogVGhlIGNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2sgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ29tcG9uZW50RG9tUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnROb2RlTGlzdCA9IHRoaXMuY29udGV4dEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLVwiICsgdGhpcy5kYXRhU2VsZWN0b3IgKyBcIl1cIik7XG4gICAgICAgIHZhciBlbGVtZW50Tm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbGVtZW50Tm9kZUxpc3QsIDApO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgZWxlbWVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRLZXkgPSBub2RlLmRhdGFzZXRbc2VsZi5kYXRhU2VsZWN0b3JdO1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHNlbGYuY29tcG9uZW50SW5kZXhbY29tcG9uZW50S2V5XTtcblxuICAgICAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX21vdW50Q29tcG9uZW50KG5vZGUsIENvbXBvbmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIkNvbXBvbmVudERvbVBhcnNlciBJbmZvOiBDb21wb25lbnQgXFxcIlwiICsgY29tcG9uZW50S2V5ICsgXCJcXFwiIGlzIG5vdCBwcmVzZW50IGluIHRoZSBwYXNzZWQgY29tcG9uZW50SW5kZXg6XCIsIHNlbGYuY29tcG9uZW50SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgQ29tcG9uZW50RG9tUGFyc2VyLnByb3RvdHlwZS5fbW91bnRDb21wb25lbnQgPSBmdW5jdGlvbiAobm9kZSwgQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb21wb25lbnQobm9kZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50RGlkTW91bnRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudENhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuXG5cbiAgICByZXR1cm4gQ29tcG9uZW50RG9tUGFyc2VyO1xufSk7XG4iLCJcbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5zY3JvbGxSZXZlYWwgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cbi8qXG4gICAgICAgICAgICAgICAgICAgICAgIF8gXyBfX19fXyAgICAgICAgICAgICAgICAgICAgICBfICAgX1xuICAgICAgICAgICAgICAgICAgICAgIHwgfCB8ICBfXyBcXCAgICAgICAgICAgICAgICAgICAgfCB8IChfKVxuICAgIF9fXyAgX19fIF8gX18gX19fIHwgfCB8IHxfXykgfF9fX19fICAgX19fX18gIF9fIF98IHwgIF8gX19fXG4gICAvIF9ffC8gX198ICdfXy8gXyBcXHwgfCB8ICBfICAvLyBfIFxcIFxcIC8gLyBfIFxcLyBfYCB8IHwgfCAvIF9ffFxuICAgXFxfXyBcXCAoX198IHwgfCAoXykgfCB8IHwgfCBcXCBcXCAgX18vXFwgViAvICBfXy8gKF98IHwgfF98IFxcX18gXFxcbiAgIHxfX18vXFxfX198X3wgIFxcX19fL3xffF98X3wgIFxcX1xcX19ffCBcXF8vIFxcX19ffFxcX18sX3xfKF8pIHxfX18vIHYyLjEuMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLyB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfF9fL1xuXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLyoqXG4gKiBzY3JvbGxSZXZlYWwuanMgKGMpIDIwMTQgSnVsaWFuIExsb3lkICggQGp1bGlhbmxsb3lkIClcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKi9cblxud2luZG93LnNjcm9sbFJldmVhbCA9IChmdW5jdGlvbiggd2luZG93ICkge1xuXG4gICd1c2Ugc3RyaWN0J1xuXG4gIHZhciBfcmVxdWVzdEFuaW1GcmFtZVxuICAgICwgZXh0ZW5kXG4gICAgLCBoYW5kbGVyXG4gICAgLCBzZWxmXG5cbiAgZnVuY3Rpb24gc2Nyb2xsUmV2ZWFsKCBjb25maWcgKSB7XG5cbiAgICBzZWxmICAgICAgICAgPSB0aGlzXG4gICAgc2VsZi5lbGVtcyAgID0ge31cbiAgICBzZWxmLnNlcmlhbCAgPSAxXG4gICAgc2VsZi5ibG9ja2VkID0gZmFsc2VcbiAgICBzZWxmLmNvbmZpZyAgPSBleHRlbmQoIHNlbGYuZGVmYXVsdHMsIGNvbmZpZyApXG5cbiAgICBpZiAoIHNlbGYuaXNNb2JpbGUoKSAmJiAhc2VsZi5jb25maWcubW9iaWxlIHx8ICFzZWxmLmlzU3VwcG9ydGVkKCkgKSB7XG4gICAgICBzZWxmLmRlc3Ryb3koKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCBzZWxmLmNvbmZpZy52aWV3cG9ydCA9PSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Njcm9sbCcsIGhhbmRsZXIsIGZhbHNlIClcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgaGFuZGxlciwgZmFsc2UgKVxuXG4gICAgfSBlbHNlIHNlbGYuY29uZmlnLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoICdzY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSApXG5cbiAgICBzZWxmLmluaXQoIHRydWUgKVxuICB9XG5cbiAgc2Nyb2xsUmV2ZWFsLnByb3RvdHlwZSA9IHtcblxuICAgIGRlZmF1bHRzOiB7XG5cbiAgICAgIGVudGVyOiAgICAnYm90dG9tJyxcbiAgICAgIG1vdmU6ICAgICAnOHB4JyxcbiAgICAgIG92ZXI6ICAgICAnMC42cycsXG4gICAgICB3YWl0OiAgICAgJzBzJyxcbiAgICAgIGVhc2luZzogICAnZWFzZScsXG5cbiAgICAgIHNjYWxlOiAgICB7IGRpcmVjdGlvbjogJ3VwJywgcG93ZXI6ICc1JScgfSxcblxuICAgICAgb3BhY2l0eTogIDAsXG4gICAgICBtb2JpbGU6ICAgZmFsc2UsXG4gICAgICByZXNldDogICAgZmFsc2UsXG4gICAgICB2aWV3cG9ydDogd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgLy8gPEhUTUw+IGVsZW1lbnQgYnkgZGVmYXVsdC5cblxuICAgICAgLyoqXG4gICAgICAgKiAgICAgICAgJ2Fsd2F5cycg4oCUIGRlbGF5IGV2ZXJ5IHRpbWUgYW4gYW5pbWF0aW9uIHJlc2V0c1xuICAgICAgICogICAgICAgICdvbmNlJyAgIOKAlCBkZWxheSBvbmx5IHRoZSBmaXJzdCB0aW1lIGFuIGFuaW1hdGlvbiByZXZlYWxzXG4gICAgICAgKiAgICAgICAgJ29ubG9hZCcgLSBkZWxheSBvbmx5IGZvciBhbmltYXRpb25zIHRyaWdnZXJlZCBieSBzZWxmLmluaXQoKVxuICAgICAgICovXG4gICAgICBkZWxheTogICAgJ29uY2UnLFxuXG4gICAgICAvKipcbiAgICAgICAqICAgICAgICB2RmFjdG9yIGNoYW5nZXMgd2hlbiBhbiBlbGVtZW50IGlzIGNvbnNpZGVyZWQgaW4gdGhlIHZpZXdwb3J0O1xuICAgICAgICogICAgICAgIHRoZSBkZWZhdWx0IHJlcXVpcmVzIDYwJSBvZiBhbiBlbGVtZW50IGJlIHZpc2libGUuXG4gICAgICAgKi9cbiAgICAgIHZGYWN0b3I6ICAwLjYwLFxuXG4gICAgICBjb21wbGV0ZTogZnVuY3Rpb24oIGVsICkge30gLy8gTm90ZTogcmVzZXQgYW5pbWF0aW9ucyBkbyBub3QgY29tcGxldGUuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgdGhlIERPTSwgYnVpbGRzIHNjcm9sbFJldmVhbCBlbGVtZW50cyBhbmQgdHJpZ2dlcnMgYW5pbWF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyDigJQgYSBob29rIGZvciBjb250cm9sbGluZyBkZWxheSBvbiBmaXJzdCBsb2FkLlxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uKCBmbGFnICkge1xuXG4gICAgICB2YXIgc2VyaWFsXG4gICAgICAgICwgZWxlbVxuICAgICAgICAsIHF1ZXJ5XG5cbiAgICAgIHF1ZXJ5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHNlbGYuY29uZmlnLnZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3JBbGwoICdbZGF0YS1zcl0nICkgKVxuICAgICAgcXVlcnkuZm9yRWFjaChmdW5jdGlvbiAoIGVsICkge1xuXG4gICAgICAgIHNlcmlhbCAgICAgID0gc2VsZi5zZXJpYWwrK1xuICAgICAgICBlbGVtICAgICAgICA9IHNlbGYuZWxlbXNbIHNlcmlhbCBdID0geyBkb21FbDogZWwgfVxuICAgICAgICBlbGVtLmNvbmZpZyA9IHNlbGYuY29uZmlnRmFjdG9yeSggZWxlbSApXG4gICAgICAgIGVsZW0uc3R5bGVzID0gc2VsZi5zdHlsZUZhY3RvcnkoIGVsZW0gKVxuICAgICAgICBlbGVtLnNlZW4gICA9IGZhbHNlXG5cbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS1zcicgKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoICdzdHlsZScsXG5cbiAgICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZVxuICAgICAgICAgICsgZWxlbS5zdHlsZXMuaW5pdGlhbFxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICBzZWxmLnNjcm9sbGVkID0gc2VsZi5zY3JvbGxZKClcbiAgICAgIHNlbGYuYW5pbWF0ZSggZmxhZyApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYW5kIHJlbW92ZXMgYXBwcm9wcmlhdGUgc3R5bGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmxhZyDigJQgYSBob29rIGZvciBjb250cm9sbGluZyBkZWxheSBvbiBmaXJzdCBsb2FkLlxuICAgICAqL1xuICAgIGFuaW1hdGU6IGZ1bmN0aW9uKCBmbGFnICkge1xuXG4gICAgICB2YXIga2V5XG4gICAgICAgICwgZWxlbVxuICAgICAgICAsIHZpc2libGVcbiAgICAgICAgLCBjb21wbGV0ZVxuXG4gICAgICAvKipcbiAgICAgICAqIENsZWFucyB0aGUgRE9NIGFuZCByZW1vdmVzIGNvbXBsZXRlZCBlbGVtZW50cyBmcm9tIHNlbGYuZWxlbXMuXG4gICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGtleSDigJQgc2VsZi5lbGVtcyBwcm9wZXJ0eSBrZXkuXG4gICAgICAgKi9cbiAgICAgIGNvbXBsZXRlID0gZnVuY3Rpb24oIGtleSApIHtcblxuICAgICAgICB2YXIgZWxlbSA9IHNlbGYuZWxlbXNbIGtleSBdXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCBlbGVtLnN0eWxlcy5pbmxpbmUgKVxuICAgICAgICAgIGVsZW0uY29uZmlnLmNvbXBsZXRlKCBlbGVtLmRvbUVsIClcbiAgICAgICAgICBkZWxldGUgc2VsZi5lbGVtc1sga2V5IF1cblxuICAgICAgICB9LCBlbGVtLnN0eWxlcy5kdXJhdGlvbiApXG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQmVnaW4gbG9vcC5cbiAgICAgICAqL1xuICAgICAgZm9yICgga2V5IGluIHNlbGYuZWxlbXMgKSB7XG4gICAgICAgIGlmICggc2VsZi5lbGVtcy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cbiAgICAgICAgICBlbGVtICAgID0gc2VsZi5lbGVtc1sga2V5IF1cbiAgICAgICAgICB2aXNpYmxlID0gc2VsZi5pc0VsZW1JblZpZXdwb3J0KCBlbGVtIClcblxuICAgICAgICAgIGlmICggdmlzaWJsZSApIHtcblxuICAgICAgICAgICAgaWYgKCBzZWxmLmNvbmZpZy5kZWxheSA9PT0gJ2Fsd2F5cydcbiAgICAgICAgICAgIHx8ICggc2VsZi5jb25maWcuZGVsYXkgPT09ICdvbmxvYWQnICYmIGZsYWcgKVxuICAgICAgICAgICAgfHwgKCBzZWxmLmNvbmZpZy5kZWxheSA9PT0gJ29uY2UnICAgJiYgIWVsZW0uc2VlbiApICkge1xuXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBVc2UgZGVsYXkuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSggJ3N0eWxlJyxcblxuICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lXG4gICAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy50YXJnZXRcbiAgICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnRyYW5zaXRpb25cbiAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBEb27igJl0IHVzZSBkZWxheS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLFxuXG4gICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmVcbiAgICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnRhcmdldFxuICAgICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMucmVzZXRcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtLnNlZW4gPSB0cnVlXG5cbiAgICAgICAgICAgIGlmICggIWVsZW0uY29uZmlnLnJlc2V0ICYmICFlbGVtLmFuaW1hdGluZyApIHtcblxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogUmVzZXQgaXMgRElTQUJMRUQgZm9yIHRoaXMgZWxlbWVudCxcbiAgICAgICAgICAgICAgICogc28gbGV04oCZcyBjb3VudCBkb3duIHRvIGFuaW1hdGlvbiBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGVsZW0uYW5pbWF0aW5nID0gdHJ1ZVxuICAgICAgICAgICAgICBjb21wbGV0ZSgga2V5IClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoICF2aXNpYmxlICYmIGVsZW0uY29uZmlnLnJlc2V0ICkge1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc2V0IGlzIEVOQUJMRUQgZm9yIHRoaXMgZWxlbWVudCxcbiAgICAgICAgICAgICAqIHNvIGxldOKAmXMgYXBwbHkgaXRzIHJlc2V0IHN0eWxlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoICdzdHlsZScsXG5cbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmVcbiAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy5pbml0aWFsXG4gICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMucmVzZXRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5ibG9ja2VkID0gZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGVsZW1lbnRzIGRhdGEtc3IgYXR0cmlidXRlLCBhbmQgcmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtIOKAlCBBbiBvYmplY3QgZnJvbSBzZWxmLmVsZW1zLlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBjb25maWdGYWN0b3J5OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgdmFyIHBhcnNlZCA9IHt9XG4gICAgICAgICwgY29uZmlnID0ge31cbiAgICAgICAgLCB3b3JkcyAgPSBlbGVtLmRvbUVsLmdldEF0dHJpYnV0ZSggJ2RhdGEtc3InICkuc3BsaXQoIC9bLCBdKy8gKVxuXG4gICAgICAvKipcbiAgICAgICAqIEZpbmQgYW5kIHJlbW92ZSBhbnkgc3ludGF4IHN1Z2FyLlxuICAgICAgICovXG4gICAgICB3b3JkcyA9IHNlbGYuZmlsdGVyKCB3b3JkcyApXG4gICAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKCBrZXl3b3JkLCBpICkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIGtleXdvcmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3dpdGNoICgga2V5d29yZCApIHtcblxuICAgICAgICAgIGNhc2UgJ2VudGVyJzpcblxuICAgICAgICAgICAgcGFyc2VkLmVudGVyID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnd2FpdCc6XG5cbiAgICAgICAgICAgIHBhcnNlZC53YWl0ID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnbW92ZSc6XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnZWFzZSc6XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHBhcnNlZC5lYXNlID0gJ2Vhc2UnXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2Vhc2UtaW4nOlxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpICsgMSBdID09ICd1cCcgfHwgd29yZHNbIGkgKyAxIF0gPT0gJ2Rvd24nICkge1xuXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5kaXJlY3Rpb24gPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgICAgID0gd29yZHNbIGkgKyAyIF1cbiAgICAgICAgICAgICAgcGFyc2VkLmVhc2luZyAgICAgICAgICA9ICdlYXNlLWluJ1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2Vhc2UtaW4nXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2Vhc2UtaW4tb3V0JzpcblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgICAgICAgICAgPSAnZWFzZS1pbi1vdXQnXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSAgID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgPSAnZWFzZS1pbi1vdXQnXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2Vhc2Utb3V0JzpcblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgICAgICAgICAgPSAnZWFzZS1vdXQnXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSAgID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgPSAnZWFzZS1vdXQnXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2h1c3RsZSc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgKyAxIF0gPT0gJ3VwJyB8fCB3b3Jkc1sgaSArIDEgXSA9PSAnZG93bicgKSB7XG5cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLmRpcmVjdGlvbiA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciAgICAgPSB3b3Jkc1sgaSArIDIgXVxuICAgICAgICAgICAgICBwYXJzZWQuZWFzaW5nICAgICAgICAgID0gJ2N1YmljLWJlemllciggMC42LCAwLjIsIDAuMSwgMSApJ1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2N1YmljLWJlemllciggMC42LCAwLjIsIDAuMSwgMSApJ1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdvdmVyJzpcblxuICAgICAgICAgICAgcGFyc2VkLm92ZXIgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdyZXNldCc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgLSAxIF0gPT0gJ25vJyApIHBhcnNlZC5yZXNldCA9IGZhbHNlXG4gICAgICAgICAgICBlbHNlICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQucmVzZXQgPSB0cnVlXG5cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnc2NhbGUnOlxuXG4gICAgICAgICAgICBwYXJzZWQuc2NhbGUgPSB7fVxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpICsgMSBdID09ICd1cCcgfHwgd29yZHNbIGkgKyAxIF0gPT0gJ2Rvd24nICkge1xuXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5kaXJlY3Rpb24gPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgICAgID0gd29yZHNbIGkgKyAyIF1cbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLyoqXG4gICAgICAgKiBCdWlsZCBkZWZhdWx0IGNvbmZpZyBvYmplY3QsIHRoZW4gYXBwbHkgYW55XG4gICAgICAgKiBvdmVycmlkZXMgcGFyc2VkIGZyb20gdGhlIGRhdGEtc3IgYXR0cmlidXRlLlxuICAgICAgICovXG4gICAgICBjb25maWcgPSBleHRlbmQoIGNvbmZpZywgc2VsZi5jb25maWcgKVxuICAgICAgY29uZmlnID0gZXh0ZW5kKCBjb25maWcsIHBhcnNlZCApXG5cbiAgICAgIGlmICggY29uZmlnLmVudGVyICA9PSAndG9wJyAgfHwgY29uZmlnLmVudGVyID09ICdib3R0b20nICkgY29uZmlnLmF4aXMgPSAnWSdcbiAgICAgIGlmICggY29uZmlnLmVudGVyICA9PSAnbGVmdCcgfHwgY29uZmlnLmVudGVyID09ICdyaWdodCcgICkgY29uZmlnLmF4aXMgPSAnWCdcblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVjayBmb3IgaHVzdGxlIGVhc2luZy5cbiAgICAgICAqL1xuICAgICAgaWYgKCBjb25maWcuZWFzaW5nID09ICdodXN0bGUnICkgY29uZmlnLmVhc2luZyA9ICdjdWJpYy1iZXppZXIoIDAuNiwgMC4yLCAwLjEsIDEgKSdcblxuICAgICAgLyoqXG4gICAgICAgKiBMZXTigJlzIG1ha2Ugc3VyZSBvdXIgb3VyIHBpeGVsIGRpc3RhbmNlcyBhcmUgbmVnYXRpdmUgZm9yIHRvcCBhbmQgbGVmdC5cbiAgICAgICAqIGUuZy4gXCJlbnRlciB0b3AgYW5kIG1vdmUgMjVweFwiIHN0YXJ0cyBhdCAndG9wOiAtMjVweCcgaW4gQ1NTLlxuICAgICAgICovXG4gICAgICBpZiAoIGNvbmZpZy5lbnRlciA9PSAndG9wJyB8fCBjb25maWcuZW50ZXIgPT0gJ2xlZnQnICkgY29uZmlnLm1vdmUgPSAnLScgKyBjb25maWcubW92ZVxuXG4gICAgICByZXR1cm4gY29uZmlnXG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHN0eWxlcyBiYXNlZCBvbiBhbiBlbGVtZW50cyBjb25maWd1cmF0aW9uIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtIOKAlCBBbiBvYmplY3QgZnJvbSBzZWxmLmVsZW1zLlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICBzdHlsZUZhY3Rvcnk6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG4gICAgICB2YXIgdHJhbnNpdGlvblxuICAgICAgICAsIGluaXRpYWxcbiAgICAgICAgLCB0YXJnZXRcbiAgICAgICAgLCByZXNldFxuICAgICAgICAsIGlubGluZVxuICAgICAgICAsIGJ1aWxkXG5cbiAgICAgIGlubGluZSA9ICggZWxlbS5kb21FbC5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKSApID8gZWxlbS5kb21FbC5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKSArICc7IHZpc2liaWxpdHk6IHZpc2libGU7ICcgOiAndmlzaWJpbGl0eTogdmlzaWJsZTsgJ1xuXG4gICAgICAvKipcbiAgICAgICAqIFdhbnQgdG8gZGlzYWJsZSBkZWxheSBvbiBtb2JpbGUgZGV2aWNlcz8gVW5jb21tZW50IHRoZSBsaW5lIGJlbG93LlxuICAgICAgICovXG4gICAgICAvL2lmICggc2VsZi5pc01vYmlsZSgpICYmIHNlbGYuY29uZmlnLm1vYmlsZSApIGVsZW0uY29uZmlnLndhaXQgPSAwXG5cbiAgICAgIHRyYW5zaXRpb24gPSAnLXdlYmtpdC10cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgJyArIGVsZW0uY29uZmlnLndhaXQgKyAnLCBvcGFjaXR5ICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAnICsgZWxlbS5jb25maWcud2FpdCArICc7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zaXRpb246IHRyYW5zZm9ybSAnICAgICAgICAgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAnICsgZWxlbS5jb25maWcud2FpdCArICcsIG9wYWNpdHkgJyArIGVsZW0uY29uZmlnLm92ZXIgKyAnICcgKyBlbGVtLmNvbmZpZy5lYXNpbmcgKyAnICcgKyBlbGVtLmNvbmZpZy53YWl0ICsgJzsgJyArXG4gICAgICAgICAgICAgICAgICAnLXdlYmtpdC1wZXJzcGVjdGl2ZTogMTAwMDsnICtcbiAgICAgICAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47J1xuXG4gICAgICByZXNldCAgICAgID0gJy13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gJyArIGVsZW0uY29uZmlnLm92ZXIgKyAnICcgKyBlbGVtLmNvbmZpZy5lYXNpbmcgKyAnIDBzLCBvcGFjaXR5ICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwczsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNpdGlvbjogdHJhbnNmb3JtICcgICAgICAgICArIGVsZW0uY29uZmlnLm92ZXIgKyAnICcgKyBlbGVtLmNvbmZpZy5lYXNpbmcgKyAnIDBzLCBvcGFjaXR5ICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwczsgJyArXG4gICAgICAgICAgICAgICAgICAnLXdlYmtpdC1wZXJzcGVjdGl2ZTogMTAwMDsgJyArXG4gICAgICAgICAgJy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOyAnXG5cbiAgICAgIC8qKlxuICAgICAgICogQ29uc3RydWN0cyBpbml0aWFsIGFuZCB0YXJnZXQgc3R5bGVzLlxuICAgICAgICovXG4gICAgICBidWlsZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICggcGFyc2VJbnQoIGVsZW0uY29uZmlnLm1vdmUgKSAhPSAwICkge1xuXG4gICAgICAgICAgaW5pdGlhbCArPSAnIHRyYW5zbGF0ZScgKyBlbGVtLmNvbmZpZy5heGlzICsgJygnICsgZWxlbS5jb25maWcubW92ZSArICcpJ1xuICAgICAgICAgIHRhcmdldCAgKz0gJyB0cmFuc2xhdGUnICsgZWxlbS5jb25maWcuYXhpcyArICcoMCknXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBhcnNlSW50KCBlbGVtLmNvbmZpZy5zY2FsZS5wb3dlciApICE9IDAgKSB7XG5cbiAgICAgICAgICBpZiAoIGVsZW0uY29uZmlnLnNjYWxlLmRpcmVjdGlvbiA9PSAndXAnICAgKSBlbGVtLmNvbmZpZy5zY2FsZS52YWx1ZSA9IDEgLSAoIHBhcnNlRmxvYXQoIGVsZW0uY29uZmlnLnNjYWxlLnBvd2VyICkgKiAwLjAxIClcbiAgICAgICAgICBpZiAoIGVsZW0uY29uZmlnLnNjYWxlLmRpcmVjdGlvbiA9PSAnZG93bicgKSBlbGVtLmNvbmZpZy5zY2FsZS52YWx1ZSA9IDEgKyAoIHBhcnNlRmxvYXQoIGVsZW0uY29uZmlnLnNjYWxlLnBvd2VyICkgKiAwLjAxIClcblxuICAgICAgICAgIGluaXRpYWwgKz0gJyBzY2FsZSgnICsgZWxlbS5jb25maWcuc2NhbGUudmFsdWUgKyAnKSdcbiAgICAgICAgICB0YXJnZXQgICs9ICcgc2NhbGUoMSknXG4gICAgICAgIH1cblxuICAgICAgICBpbml0aWFsICs9ICc7IG9wYWNpdHk6ICcgKyBlbGVtLmNvbmZpZy5vcGFjaXR5ICsgJzsgJ1xuICAgICAgICB0YXJnZXQgICs9ICc7IG9wYWNpdHk6IDE7ICc7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWwgPSAndHJhbnNmb3JtOidcbiAgICAgIHRhcmdldCAgPSAndHJhbnNmb3JtOidcblxuICAgICAgYnVpbGQoKVxuXG4gICAgICAvKipcbiAgICAgICAqIEJ1aWxkIGFnYWluIGZvciB3ZWJraXQuXG4gICAgICAgKi9cbiAgICAgIGluaXRpYWwgKz0gJy13ZWJraXQtdHJhbnNmb3JtOidcbiAgICAgIHRhcmdldCAgKz0gJy13ZWJraXQtdHJhbnNmb3JtOidcblxuICAgICAgYnVpbGQoKVxuXG4gICAgICByZXR1cm4ge1xuXG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgICAgIGluaXRpYWw6ICAgIGluaXRpYWwsXG4gICAgICAgIHRhcmdldDogICAgIHRhcmdldCxcbiAgICAgICAgcmVzZXQ6ICAgICAgcmVzZXQsXG4gICAgICAgIGlubGluZTogICAgIGlubGluZSxcbiAgICAgICAgZHVyYXRpb246ICAgKCAoIHBhcnNlRmxvYXQoIGVsZW0uY29uZmlnLm92ZXIgKSArIHBhcnNlRmxvYXQoIGVsZW0uY29uZmlnLndhaXQgKSApICogMTAwMCApXG4gICAgICB9XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24oIHdvcmRzICkge1xuXG4gICAgICB2YXIgZmlsdGVyZWQgID0gW11cblxuICAgICAgdmFyIHN1Z2FyID0gW1xuXG4gICAgICAgICdmcm9tJyxcbiAgICAgICAgJ3RoZScsXG4gICAgICAgICdhbmQnLFxuICAgICAgICAndGhlbicsXG4gICAgICAgICdidXQnLFxuICAgICAgICAnd2l0aCcsXG4gICAgICAgICdwbGVhc2UnLFxuICAgICAgXVxuXG4gICAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKCB3b3JkICkge1xuXG4gICAgICAgIGlmICggc3VnYXIuaW5kZXhPZiggd29yZCApID4gLTEgKSByZXR1cm5cblxuICAgICAgICBmaWx0ZXJlZC5wdXNoKCB3b3JkIClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gZmlsdGVyZWRcbiAgICB9LFxuXG4gICAgZ2V0Vmlld3BvcnRIOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGNsaWVudCA9IHNlbGYuY29uZmlnLnZpZXdwb3J0WyAnY2xpZW50SGVpZ2h0JyBdXG4gICAgICAgICwgaW5uZXIgID0gd2luZG93WyAnaW5uZXJIZWlnaHQnIF1cblxuICAgICAgaWYgKCBzZWxmLmNvbmZpZy52aWV3cG9ydCA9PSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkge1xuXG4gICAgICAgIHJldHVybiAoIGNsaWVudCA8IGlubmVyICkgPyBpbm5lciA6IGNsaWVudFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xpZW50XG4gICAgfSxcblxuICAgIHNjcm9sbFk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIHNlbGYuY29uZmlnLnZpZXdwb3J0ID09IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgKSByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0XG5cbiAgICAgIHJldHVybiBzZWxmLmNvbmZpZy52aWV3cG9ydC5zY3JvbGxUb3AgKyBzZWxmLmNvbmZpZy52aWV3cG9ydC5vZmZzZXRUb3BcbiAgICB9LFxuXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiggZWwgKSB7XG5cbiAgICAgIHZhciBvZmZzZXRUb3AgID0gMFxuICAgICAgICAsIG9mZnNldExlZnQgPSAwXG5cbiAgICAgIGRvIHtcblxuICAgICAgICBpZiAoICFpc05hTiggZWwub2Zmc2V0VG9wICApKSBvZmZzZXRUb3AgICs9IGVsLm9mZnNldFRvcFxuICAgICAgICBpZiAoICFpc05hTiggZWwub2Zmc2V0TGVmdCApKSBvZmZzZXRMZWZ0ICs9IGVsLm9mZnNldExlZnRcblxuICAgICAgfSB3aGlsZSAoIGVsID0gZWwub2Zmc2V0UGFyZW50IClcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICB0b3A6IG9mZnNldFRvcCxcbiAgICAgICAgbGVmdDogb2Zmc2V0TGVmdFxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0VsZW1JblZpZXdwb3J0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgdmFyIGVsSGVpZ2h0ID0gZWxlbS5kb21FbC5vZmZzZXRIZWlnaHRcbiAgICAgICAgLCBlbFRvcCAgICA9IHNlbGYuZ2V0T2Zmc2V0KCBlbGVtLmRvbUVsICkudG9wXG4gICAgICAgICwgZWxCb3R0b20gPSBlbFRvcCArIGVsSGVpZ2h0XG4gICAgICAgICwgdkZhY3RvciAgPSBlbGVtLmNvbmZpZy52RmFjdG9yIHx8IDBcblxuICAgICAgcmV0dXJuICggZWxUb3AgKyBlbEhlaWdodCAqIHZGYWN0b3IgPCBzZWxmLnNjcm9sbGVkICsgc2VsZi5nZXRWaWV3cG9ydEgoKSApXG4gICAgICAgICAgJiYgKCBlbEJvdHRvbSAtIGVsSGVpZ2h0ICogdkZhY3RvciA+IHNlbGYuc2Nyb2xsZWQgKVxuICAgICAgICAgIHx8ICggZWxlbS5kb21FbC5jdXJyZW50U3R5bGUgPyBlbGVtLmRvbUVsLmN1cnJlbnRTdHlsZSA6IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLmRvbUVsLCBudWxsICkgKS5wb3NpdGlvbiA9PSAnZml4ZWQnXG4gICAgfSxcblxuICAgIGlzTW9iaWxlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYVxuXG4gICAgICByZXR1cm4gKC8oaXBhZHxwbGF5Ym9va3xzaWxrfGFuZHJvaWR8YmJcXGQrfG1lZWdvKS4rbW9iaWxlfGF2YW50Z298YmFkYVxcL3xibGFja2JlcnJ5fGJsYXplcnxjb21wYWx8ZWxhaW5lfGZlbm5lY3xoaXB0b3B8aWVtb2JpbGV8aXAoaG9uZXxvZCl8aXJpc3xraW5kbGV8bGdlIHxtYWVtb3xtaWRwfG1tcHxtb2JpbGUuK2ZpcmVmb3h8bmV0ZnJvbnR8b3BlcmEgbShvYnxpbilpfHBhbG0oIG9zKT98cGhvbmV8cChpeGl8cmUpXFwvfHBsdWNrZXJ8cG9ja2V0fHBzcHxzZXJpZXMoNHw2KTB8c3ltYmlhbnx0cmVvfHVwXFwuKGJyb3dzZXJ8bGluayl8dm9kYWZvbmV8d2FwfHdpbmRvd3MgKGNlfHBob25lKXx4ZGF8eGlpbm8vaS50ZXN0KCBhZ2VudCApfHwvMTIwN3w2MzEwfDY1OTB8M2dzb3w0dGhwfDUwWzEtNl1pfDc3MHN8ODAyc3xhIHdhfGFiYWN8YWMoZXJ8b298c1xcLSl8YWkoa298cm4pfGFsKGF2fGNhfGNvKXxhbW9pfGFuKGV4fG55fHl3KXxhcHR1fGFyKGNofGdvKXxhcyh0ZXx1cyl8YXR0d3xhdShkaXxcXC1tfHIgfHMgKXxhdmFufGJlKGNrfGxsfG5xKXxiaShsYnxyZCl8YmwoYWN8YXopfGJyKGV8dil3fGJ1bWJ8YndcXC0obnx1KXxjNTVcXC98Y2FwaXxjY3dhfGNkbVxcLXxjZWxsfGNodG18Y2xkY3xjbWRcXC18Y28obXB8bmQpfGNyYXd8ZGEoaXR8bGx8bmcpfGRidGV8ZGNcXC1zfGRldml8ZGljYXxkbW9ifGRvKGN8cClvfGRzKDEyfFxcLWQpfGVsKDQ5fGFpKXxlbShsMnx1bCl8ZXIoaWN8azApfGVzbDh8ZXooWzQtN10wfG9zfHdhfHplKXxmZXRjfGZseShcXC18Xyl8ZzEgdXxnNTYwfGdlbmV8Z2ZcXC01fGdcXC1tb3xnbyhcXC53fG9kKXxncihhZHx1bil8aGFpZXxoY2l0fGhkXFwtKG18cHx0KXxoZWlcXC18aGkocHR8dGEpfGhwKCBpfGlwKXxoc1xcLWN8aHQoYyhcXC18IHxffGF8Z3xwfHN8dCl8dHApfGh1KGF3fHRjKXxpXFwtKDIwfGdvfG1hKXxpMjMwfGlhYyggfFxcLXxcXC8pfGlicm98aWRlYXxpZzAxfGlrb218aW0xa3xpbm5vfGlwYXF8aXJpc3xqYSh0fHYpYXxqYnJvfGplbXV8amlnc3xrZGRpfGtlaml8a2d0KCB8XFwvKXxrbG9ufGtwdCB8a3djXFwtfGt5byhjfGspfGxlKG5vfHhpKXxsZyggZ3xcXC8oa3xsfHUpfDUwfDU0fFxcLVthLXddKXxsaWJ3fGx5bnh8bTFcXC13fG0zZ2F8bTUwXFwvfG1hKHRlfHVpfHhvKXxtYygwMXwyMXxjYSl8bVxcLWNyfG1lKHJjfHJpKXxtaShvOHxvYXx0cyl8bW1lZnxtbygwMXwwMnxiaXxkZXxkb3x0KFxcLXwgfG98dil8enopfG10KDUwfHAxfHYgKXxtd2JwfG15d2F8bjEwWzAtMl18bjIwWzItM118bjMwKDB8Mil8bjUwKDB8Mnw1KXxuNygwKDB8MSl8MTApfG5lKChjfG0pXFwtfG9ufHRmfHdmfHdnfHd0KXxub2soNnxpKXxuenBofG8yaW18b3AodGl8d3YpfG9yYW58b3dnMXxwODAwfHBhbihhfGR8dCl8cGR4Z3xwZygxM3xcXC0oWzEtOF18YykpfHBoaWx8cGlyZXxwbChheXx1Yyl8cG5cXC0yfHBvKGNrfHJ0fHNlKXxwcm94fHBzaW98cHRcXC1nfHFhXFwtYXxxYygwN3wxMnwyMXwzMnw2MHxcXC1bMi03XXxpXFwtKXxxdGVrfHIzODB8cjYwMHxyYWtzfHJpbTl8cm8odmV8em8pfHM1NVxcL3xzYShnZXxtYXxtbXxtc3xueXx2YSl8c2MoMDF8aFxcLXxvb3xwXFwtKXxzZGtcXC98c2UoYyhcXC18MHwxKXw0N3xtY3xuZHxyaSl8c2doXFwtfHNoYXJ8c2llKFxcLXxtKXxza1xcLTB8c2woNDV8aWQpfHNtKGFsfGFyfGIzfGl0fHQ1KXxzbyhmdHxueSl8c3AoMDF8aFxcLXx2XFwtfHYgKXxzeSgwMXxtYil8dDIoMTh8NTApfHQ2KDAwfDEwfDE4KXx0YShndHxsayl8dGNsXFwtfHRkZ1xcLXx0ZWwoaXxtKXx0aW1cXC18dFxcLW1vfHRvKHBsfHNoKXx0cyg3MHxtXFwtfG0zfG01KXx0eFxcLTl8dXAoXFwuYnxnMXxzaSl8dXRzdHx2NDAwfHY3NTB8dmVyaXx2aShyZ3x0ZSl8dmsoNDB8NVswLTNdfFxcLXYpfHZtNDB8dm9kYXx2dWxjfHZ4KDUyfDUzfDYwfDYxfDcwfDgwfDgxfDgzfDg1fDk4KXx3M2MoXFwtfCApfHdlYmN8d2hpdHx3aShnIHxuY3xudyl8d21sYnx3b251fHg3MDB8eWFzXFwtfHlvdXJ8emV0b3x6dGVcXC0vaS50ZXN0KCBhZ2VudC5zdWJzdHIoIDAsIDQgKSkpID8gdHJ1ZSA6IGZhbHNlXG4gICAgfSxcblxuICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHNlbnNvciAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzZW5zb3InIClcbiAgICAgICAgLCBjc3NQcmVmaXggPSAnV2Via2l0LE1veixPLCcuc3BsaXQoICcsJyApXG4gICAgICAgICwgdGVzdHMgICAgID0gKCAndHJhbnNpdGlvbiAnICsgY3NzUHJlZml4LmpvaW4oICd0cmFuc2l0aW9uLCcgKSApLnNwbGl0KCAnLCcgKVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXN0cy5sZW5ndGg7IGkrKyApIHtcblxuICAgICAgICBpZiAoICFzZW5zb3Iuc3R5bGVbdGVzdHNbaV1dID09PSAnJyApIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHF1ZXJ5XG5cbiAgICAgIHF1ZXJ5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHNlbGYuY29uZmlnLnZpZXdwb3J0LnF1ZXJ5U2VsZWN0b3JBbGwoICdbZGF0YS1zcl0nICkgKVxuICAgICAgcXVlcnkuZm9yRWFjaChmdW5jdGlvbiAoIGVsICkge1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoICdkYXRhLXNyJyApXG4gICAgICB9KVxuICAgIH1cblxuICB9XG5cbiAgaGFuZGxlciA9IGZ1bmN0aW9uKCBlICkge1xuXG4gICAgaWYgKCAhc2VsZi5ibG9ja2VkICkge1xuXG4gICAgICBzZWxmLmJsb2NrZWQgID0gdHJ1ZVxuICAgICAgc2VsZi5zY3JvbGxlZCA9IHNlbGYuc2Nyb2xsWSgpXG5cbiAgICAgIF9yZXF1ZXN0QW5pbUZyYW1lKCBmdW5jdGlvbigpIHtcblxuICAgICAgICBzZWxmLmFuaW1hdGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBleHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0LCBzcmMgKSB7XG5cbiAgICBmb3IgKCB2YXIgcHJvcCBpbiBzcmMgKSB7XG5cbiAgICAgIGlmICggc3JjLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cbiAgICAgICAgdGFyZ2V0WyBwcm9wIF0gPSBzcmNbIHByb3AgXVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwuXG4gICAqL1xuICBfcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcblxuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgICB8fFxuICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lICB8fFxuICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICB8fFxuXG4gICAgICAgICAgZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dCggY2FsbGJhY2ssIDEwMDAgLyA2MCApXG4gICAgICAgICAgfVxuICB9KCkpXG5cbiAgcmV0dXJuIHNjcm9sbFJldmVhbFxuXG59KSggd2luZG93IClcblxucmV0dXJuIHNjcm9sbFJldmVhbDtcblxufSkpO1xuIl19
