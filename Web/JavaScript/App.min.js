(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * App.min.js
 * @description Require the main application modules.
 */

var DomParser = require('./Utilities/DomParser/Parser.js'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex(),
    componentParser;

// Register the base modules.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('parallaxStage', require('./Components/ParallaxStage/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentParser.
componentParser = new DomParser({
    constructors: componentStore.getIndex(),
    selector: 'component', // Equals [data-component="*"]
    defaultCallback: (function(instance, el, dataset) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        // Initialize the module.
        instance.initialize.call(instance, el, dataset);

        return instance;
    })
}).parse();
},{"./Components/ClassToggler/View.js":2,"./Components/ParallaxStage/View.js":3,"./Components/ScrollTo/View.js":4,"./Utilities/ComponentIndex/Util.js":5,"./Utilities/DomParser/Parser.js":7}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ClassToggler}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":6}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    setTransform = require('./../../Utilities/Helpers').setTransform,
    ParallaxStage;

/**
 * ParallaxStage
 * @description Creates a subtle parallax scrolling effect on some child elements.
 * @constructor
 */
ParallaxStage = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the parallax values will be based on.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ParallaxStage}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.targets = document.querySelectorAll(dataset.target || '[data-parallax]');
        this.set('lastScrollTop', 0);

        // Setup the rAF.
        var self = this,
            _animFrame;

        (function animloop(){
            self.render();
            _animFrame = window.requestAnimationFrame(animloop);
        }());

        return this;
    },

    render: function() {
        'use strict';

        var currentScrollTop = document.body.scrollTop,
            lastScrollTop = this.get('lastScrollTop');

        if(currentScrollTop === lastScrollTop) {
            return this;
        }

        this.set('lastScrollTop', currentScrollTop);
        this.adjustPositions(currentScrollTop);

        return this;
    },
    adjustPositions: function(scrollTop) {
        'use strict';

        var stageOffset = this.el.offsetTop,
            scrollPos = scrollTop - stageOffset;

        this.setElementsTransformValue(this.targets[0], scrollPos);
        this.setElementsTransformValue(this.targets[1], scrollPos);

        return this;
    },
    setElementsTransformValue: function(element, scrollPos) {
        'use strict';

        var val = Math.round(scrollPos / (Math.abs(element.dataset.parallaxfactor) || 1));

        setTransform(element, 'translateY(' + val + 'px)')

        return this;
    }
});

module.exports = ParallaxStage;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],4:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ScrollTo}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],5:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        console.info('Component ' + key + ' was already registered in this index.', this);
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],6:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll WeiÃŸ
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function() {
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":8}],7:[function(require,module,exports){
/**
 * Parse the DOM for the given selector. If the value matches an item in the given index, create instances of it.
 *
 * @module Modules/DomParser
 */

var DomParser;

/**
 * DomParser
 * @param args {Object} The options object which will configure the parser.
 * @constructor
 */
DomParser = function(args) {
	'use strict';

	this.defaultCallback = args.defaultCallback;
	this.selector = args.selector;
	this.index = args.constructors;

    return this;
};


/**
 * parse
 * @description Parse trough the DOM.
 * @memberof module:Modules/DomParser
 * @param args {Object} Several options which can be passed individually on each parse.
 * @returns {DomParser}
 */
DomParser.prototype.parse = function(args) {
	'use strict';

    args = args || {};

	var callback = args.callback || this.defaultCallback,
		elements = (args.context || window.document).querySelectorAll('[data-' + this.selector + ']'),
		i;

	if(!elements.length) {
		return this;
	}

	for (i in elements) {
		if(i === 'length' || i === 'item') {
			continue;
		}

        var el = elements[i],
            val = el.dataset[this.selector],
            Module = this.index[val];

        // Check if the attr's value is in the index.
        if (!Module) {
            console.info('Component "' + val + '" is not present in the index.');
        } else {
            this.createInstance(Module, el, callback);
        }
	}

	return this;
};


/**
 *
 * @param Constructor
 * @param el {HTMLElement} The element on which the component will mount upon.
 * @param cb {Function} The callback to execute after the instance was created.
 * @returns {DomParser}
 */
DomParser.prototype.createInstance = function(Constructor, el, cb) {
	'use strict';

	// Create the instance of the Module.
	var instance = new Constructor(el, el.dataset);

	if(cb) {
		cb.call(this, instance, el, el.dataset);
	}

	return this;
};


// Return the Constructor.
module.exports = DomParser;
},{}],8:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },
    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    },
    setTransform: function(element, prop) {
        'use strict';

        element.style.webkitTransform = prop;
        element.style.MozTransform = prop;
        element.style.msTransform = prop;
        element.style.OTransform = prop;
        element.style.transform = prop;
    }
};

module.exports = helpers;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRG9tUGFyc2VyL1BhcnNlci5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIEFwcC5taW4uanNcbiAqIEBkZXNjcmlwdGlvbiBSZXF1aXJlIHRoZSBtYWluIGFwcGxpY2F0aW9uIG1vZHVsZXMuXG4gKi9cblxudmFyIERvbVBhcnNlciA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0RvbVBhcnNlci9QYXJzZXIuanMnKSxcbiAgICBDb21wb25lbnRJbmRleCA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0NvbXBvbmVudEluZGV4L1V0aWwuanMnKSxcbiAgICBjb21wb25lbnRTdG9yZSA9IG5ldyBDb21wb25lbnRJbmRleCgpLFxuICAgIGNvbXBvbmVudFBhcnNlcjtcblxuLy8gUmVnaXN0ZXIgdGhlIGJhc2UgbW9kdWxlcy5cbmNvbXBvbmVudFN0b3JlLnJlZ2lzdGVyKCdjbGFzc1RvZ2dsZXInLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcigncGFyYWxsYXhTdGFnZScsIHJlcXVpcmUoJy4vQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3Rlcignc2Nyb2xsVG8nLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvU2Nyb2xsVG8vVmlldy5qcycpKTtcblxuLy8gU2V0cyB1cCB0aGUgY29tcG9uZW50UGFyc2VyLlxuY29tcG9uZW50UGFyc2VyID0gbmV3IERvbVBhcnNlcih7XG4gICAgY29uc3RydWN0b3JzOiBjb21wb25lbnRTdG9yZS5nZXRJbmRleCgpLFxuICAgIHNlbGVjdG9yOiAnY29tcG9uZW50JywgLy8gRXF1YWxzIFtkYXRhLWNvbXBvbmVudD1cIipcIl1cbiAgICBkZWZhdWx0Q2FsbGJhY2s6IChmdW5jdGlvbihpbnN0YW5jZSwgZWwsIGRhdGFzZXQpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmKCFpbnN0YW5jZS5pbml0aWFsaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBtb2R1bGUuXG4gICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUuY2FsbChpbnN0YW5jZSwgZWwsIGRhdGFzZXQpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9KVxufSkucGFyc2UoKTsiLCJ2YXIgY29tcG9uZW50UHJvdG90eXBlID0gcmVxdWlyZSgnY29tcG9uZW50UHJvdG90eXBlJyksXG4gICAgQ2xhc3NUb2dnbGVyO1xuXG4vKipcbiAqIENsYXNzVG9nZ2xlclxuICogQGRlc2NyaXB0aW9uIFRvZ2dsZXMgYSBjbGFzcyBvbiBhIHRhcmdldCBlbGVtZW50IG9uIGNsaWNrLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbkNsYXNzVG9nZ2xlciA9IGNvbXBvbmVudFByb3RvdHlwZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgRWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSBtb3VudGVkLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtDbGFzc1RvZ2dsZXJ9XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIGRhdGFzZXQpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFzZXQudGFyZ2V0KTtcbiAgICAgICAgdGhpcy5zZXQoJ2NsYXNzJywgZGF0YXNldC5jbGFzcyB8fCAnYWN0aXZlJyk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xlQ2xhc3NcbiAgICAgKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyB0aGUgY2xhc3Mgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtDbGFzc1RvZ2dsZXJ9XG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbC5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnKTtcbiAgICAgICAgdGhpcy50YXJnZXRbMF0uY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmdldCgnY2xhc3MnKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xhc3NUb2dnbGVyOyIsInZhciBjb21wb25lbnRQcm90b3R5cGUgPSByZXF1aXJlKCdjb21wb25lbnRQcm90b3R5cGUnKSxcbiAgICBzZXRUcmFuc2Zvcm0gPSByZXF1aXJlKCcuLy4uLy4uL1V0aWxpdGllcy9IZWxwZXJzJykuc2V0VHJhbnNmb3JtLFxuICAgIFBhcmFsbGF4U3RhZ2U7XG5cbi8qKlxuICogUGFyYWxsYXhTdGFnZVxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBzdWJ0bGUgcGFyYWxsYXggc2Nyb2xsaW5nIGVmZmVjdCBvbiBzb21lIGNoaWxkIGVsZW1lbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblBhcmFsbGF4U3RhZ2UgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIHBhcmFsbGF4IHZhbHVlcyB3aWxsIGJlIGJhc2VkIG9uLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtQYXJhbGxheFN0YWdlfVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBkYXRhc2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQgfHwgJ1tkYXRhLXBhcmFsbGF4XScpO1xuICAgICAgICB0aGlzLnNldCgnbGFzdFNjcm9sbFRvcCcsIDApO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSByQUYuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9hbmltRnJhbWU7XG5cbiAgICAgICAgKGZ1bmN0aW9uIGFuaW1sb29wKCl7XG4gICAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICAgICAgX2FuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWxvb3ApO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTY3JvbGxUb3AgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxhc3RTY3JvbGxUb3AgPSB0aGlzLmdldCgnbGFzdFNjcm9sbFRvcCcpO1xuXG4gICAgICAgIGlmKGN1cnJlbnRTY3JvbGxUb3AgPT09IGxhc3RTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXQoJ2xhc3RTY3JvbGxUb3AnLCBjdXJyZW50U2Nyb2xsVG9wKTtcbiAgICAgICAgdGhpcy5hZGp1c3RQb3NpdGlvbnMoY3VycmVudFNjcm9sbFRvcCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGp1c3RQb3NpdGlvbnM6IGZ1bmN0aW9uKHNjcm9sbFRvcCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIHN0YWdlT2Zmc2V0ID0gdGhpcy5lbC5vZmZzZXRUb3AsXG4gICAgICAgICAgICBzY3JvbGxQb3MgPSBzY3JvbGxUb3AgLSBzdGFnZU9mZnNldDtcblxuICAgICAgICB0aGlzLnNldEVsZW1lbnRzVHJhbnNmb3JtVmFsdWUodGhpcy50YXJnZXRzWzBdLCBzY3JvbGxQb3MpO1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRzVHJhbnNmb3JtVmFsdWUodGhpcy50YXJnZXRzWzFdLCBzY3JvbGxQb3MpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0RWxlbWVudHNUcmFuc2Zvcm1WYWx1ZTogZnVuY3Rpb24oZWxlbWVudCwgc2Nyb2xsUG9zKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgdmFsID0gTWF0aC5yb3VuZChzY3JvbGxQb3MgLyAoTWF0aC5hYnMoZWxlbWVudC5kYXRhc2V0LnBhcmFsbGF4ZmFjdG9yKSB8fCAxKSk7XG5cbiAgICAgICAgc2V0VHJhbnNmb3JtKGVsZW1lbnQsICd0cmFuc2xhdGVZKCcgKyB2YWwgKyAncHgpJylcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbGxheFN0YWdlOyIsInZhciBjb21wb25lbnRQcm90b3R5cGUgPSByZXF1aXJlKCdjb21wb25lbnRQcm90b3R5cGUnKSxcbiAgICBlYXNlSW5PdXRRdWFkID0gcmVxdWlyZSgnLi8uLi8uLi9VdGlsaXRpZXMvSGVscGVycycpLmVhc2VJbk91dFF1YWQsXG4gICAgU2Nyb2xsVG87XG5cbi8qKlxuICogU2Nyb2xsVG9cbiAqIEBkZXNjcmlwdGlvbiBTY3JvbGxzIHRvIGEgY2VydGFpbiB0YXJnZXQgZWxlbWVudCBvbiB0aGUgZWxlbWVudHMgY2xpY2suXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuU2Nyb2xsVG8gPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7U2Nyb2xsVG99XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZWwsIGRhdGFzZXQpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFzZXQudGFyZ2V0KVswXTtcbiAgICAgICAgdGhpcy5zZXQoJ2R1cmF0aW9uJywgZGF0YXNldC5kdXJhdGlvbiB8fCA2MDApO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvVGFyZ2V0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNjcm9sbFRvVGFyZ2V0XG4gICAgICogQGRlc2NyaXB0aW9uIFNjcm9sbHMgdG8gdGhlIHRhcmdldC5cbiAgICAgKiBAcmV0dXJucyB7U2Nyb2xsVG99XG4gICAgICovXG4gICAgc2Nyb2xsVG9UYXJnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgdG8gPSB0aGlzLnRhcmdldC5vZmZzZXRUb3AsXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0KCdkdXJhdGlvbicpLFxuICAgICAgICAgICAgc3RhcnQgPSBlbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgICAgICAgIGNoYW5nZSA9IHRvIC0gc3RhcnQsXG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IDAsXG4gICAgICAgICAgICBpbmNyZW1lbnQgPSAyMDtcblxuICAgICAgICB2YXIgYW5pbWF0ZVNjcm9sbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjdXJyZW50VGltZSArPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICB2YXIgdmFsID0gZWFzZUluT3V0UXVhZChjdXJyZW50VGltZSwgc3RhcnQsIGNoYW5nZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxUb3AgPSB2YWw7XG4gICAgICAgICAgICBpZihjdXJyZW50VGltZSA8IGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChhbmltYXRlU2Nyb2xsLCBpbmNyZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhbmltYXRlU2Nyb2xsKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2Nyb2xsVG87IiwidmFyIENvbXBvbmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdGhpcy5pbmRleCA9IHt9O1xufTtcbkNvbXBvbmVudEluZGV4LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKGtleSwgQ29uc3RydWN0b3IpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBpZigha2V5IHx8ICFDb25zdHJ1Y3RvciB8fCB0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgQ29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYodGhpcy5pbmRleFtrZXldKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnQ29tcG9uZW50ICcgKyBrZXkgKyAnIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWQgaW4gdGhpcyBpbmRleC4nLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluZGV4W2tleV0gPSBDb25zdHJ1Y3RvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5Db21wb25lbnRJbmRleC5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICByZXR1cm4gdGhpcy5pbmRleDtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudEluZGV4OyIsIi8qKlxuICogTW9kdWxlUHJvdG90eXBlXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIHNldCBvZiBoYW5keSBmdW5jdGlvbnMgYW5kIHJlZmVyZW5jZSB0aGVtIHRvIGEgdGFyZ2V0IGUuZy46XG4gKiBAYXV0aG9yIFR5bGwgV2Vpw59cbiAqL1xuXG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCcuLy4uL0hlbHBlcnMuanMnKS5leHRlbmQ7XG5cbnZhciBQcm90b3R5cGUgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbml0aWFsaXplXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBBIGR1bW15IGluaXRpYWxpemUgZnVuY3Rpb24gd2hpY2ggc2V0J3MgZ2l2ZW4gYXR0cmlidXRlcyBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyB7b2JqZWN0IHx8IHN0cmluZ30gVGhlIGF0dHJpYnV0ZShzKSB0byBzZXQgb24gdGhlIG1vZHVsZS5cbiAgICAgICAgICogQHJldHVybnMge1Byb3RvdHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgLy8gSWYgYXR0cmlidXRlcyB3aGVyZSBwYXNzZWQsIHNldCB0aGVtIG9uIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGlmKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gU2V0IGEga2V5ICYgdmFsIHBhaXIgb24gdGhlIG1vZHVsZSBhdHRyaWJ1dGVzIG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleS5cbiAgICAgICAgICogQHBhcmFtIHZhbCB7c3RyaW5nfSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHRhcmdldCB0byB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqLCBpZiB0cnVlIC0gc2V0IGVhY2gga2V5L3ZhbCBwYWlyLlxuICAgICAgICAgICAgaWYodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBrZXkuZm9yRWFjaChmdW5jdGlvbihvYmpLZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtvYmpLZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHNldCB0aGUga2V5L3ZhbCBwYWlyLlxuICAgICAgICAgICAgaWYodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdW5zZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFVuc2V0L0RlbGV0ZSBhIGtleSBmcm9tIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgdW5zZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1trZXldO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZ2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHZhbHVlIG9mIGFuIGtleSBpbiB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEBwYXJhbSBrZXkge3N0cmluZ30gVGhlIHRhcmdldCBrZXkgdG8gbG9vayBmb3IgaW4gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGFzXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgYm9vbCB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gYXR0cmlidXRlIHdhcyBzZXQgb24gdGhlIG1vZHVsZS5cbiAgICAgICAgICogQHBhcmFtIGF0dHIge3N0cmluZ30gVGhlIHRhcmdldCBrZXkgdG8gdGVzdC5cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGF0dHIpICE9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4dGVuZFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGluaXRpYXRvciBmdW5jdGlvbiBmb3IgZWFjaCBtb2R1bGUsIGludm9rZXMgYSBuZXcgbW9kdWxlIENvbnN0cnVjdG9yIGFuZCBleHRlbmRzIHRoZSBwcm90b3R5cGUgd2l0aCBhbGwgZnVuY3Rpb25zIGZvdW5kIGluIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKiBAZXhhbXBsZSBQcm90b3R5cGUuZXh0ZW5kKHtvYmplY3R9KTtcbiAgICAgICAgICogQHBhcmFtIHByb3RvdHlwZVByb3BzIHtvYmplY3R9IEEgc2V0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgY3JlYXRlZCBDb25zdHJ1Y3Rvci5cbiAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgLy8gUHJldmVudCBlbXB0eSBvYmplY3RzLlxuICAgICAgICAgICAgb2JqID0gb2JqID8gb2JqIDoge307XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBmdW5jdGlvbiB3cmFwcGVyLlxuICAgICAgICAgICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIHRhcmdldCBmdW5jdGlvbiB3aXRoIHRoZSBiYXNlIGZ1bmN0aW9ucywgYXMgd2VsbCBhcyB0aGUgcHJvdG9Qcm9wc1xuICAgICAgICAgICAgZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgdGhpcywgb2JqKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSB0YXJnZXQgZnVuY3Rpb24uXG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1peGluXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBNaXggYSBzZXQgb2YgZnVuY3Rpb25zIGludG8gdGhlIGN1cnJlbnQgcHJvdG90eXBlLlxuICAgICAgICAgKiBAZXhhbXBsZSB0aGlzLm1peGluKHsgZ2V0Rm91cjogZnVuY3Rpb24oKSB7IHJldHVybiAyKzI7IH0gfSk7XG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQge09iamVjdH0gVGhlIHByb3RvdHlwZSwgdG8gbWl4IHRoZSBPYmogaW50by5cbiAgICAgICAgICogQHBhcmFtIG9iaiB7b2JqZWN0fSBBIHNldCBvZiBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGV4dGVuZGVkIG9uIHRoZSBjdXJyZW50IHByb3RvdHlwZS5cbiAgICAgICAgICogQHJldHVybnMge1Byb3RvdHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIG1peGluOiBmdW5jdGlvbih0YXJnZXQsIG9iaikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgICBvYmogPSBvYmogPyBvYmogOiB7fTtcblxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMucHJvdG90eXBlO1xuXG4gICAgICAgICAgICBpZighdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdpdGggdGhlIGJhc2UgZnVuY3Rpb25zLCBhcyB3ZWxsIGFzIHRoZSBwcm90b1Byb3BzXG4gICAgICAgICAgICBleHRlbmQodGFyZ2V0LCBvYmopO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH07XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvdG90eXBlOyIsIi8qKlxuICogUGFyc2UgdGhlIERPTSBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLiBJZiB0aGUgdmFsdWUgbWF0Y2hlcyBhbiBpdGVtIGluIHRoZSBnaXZlbiBpbmRleCwgY3JlYXRlIGluc3RhbmNlcyBvZiBpdC5cbiAqXG4gKiBAbW9kdWxlIE1vZHVsZXMvRG9tUGFyc2VyXG4gKi9cblxudmFyIERvbVBhcnNlcjtcblxuLyoqXG4gKiBEb21QYXJzZXJcbiAqIEBwYXJhbSBhcmdzIHtPYmplY3R9IFRoZSBvcHRpb25zIG9iamVjdCB3aGljaCB3aWxsIGNvbmZpZ3VyZSB0aGUgcGFyc2VyLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbkRvbVBhcnNlciA9IGZ1bmN0aW9uKGFyZ3MpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHRoaXMuZGVmYXVsdENhbGxiYWNrID0gYXJncy5kZWZhdWx0Q2FsbGJhY2s7XG5cdHRoaXMuc2VsZWN0b3IgPSBhcmdzLnNlbGVjdG9yO1xuXHR0aGlzLmluZGV4ID0gYXJncy5jb25zdHJ1Y3RvcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBwYXJzZVxuICogQGRlc2NyaXB0aW9uIFBhcnNlIHRyb3VnaCB0aGUgRE9NLlxuICogQG1lbWJlcm9mIG1vZHVsZTpNb2R1bGVzL0RvbVBhcnNlclxuICogQHBhcmFtIGFyZ3Mge09iamVjdH0gU2V2ZXJhbCBvcHRpb25zIHdoaWNoIGNhbiBiZSBwYXNzZWQgaW5kaXZpZHVhbGx5IG9uIGVhY2ggcGFyc2UuXG4gKiBAcmV0dXJucyB7RG9tUGFyc2VyfVxuICovXG5Eb21QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oYXJncykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgICBhcmdzID0gYXJncyB8fCB7fTtcblxuXHR2YXIgY2FsbGJhY2sgPSBhcmdzLmNhbGxiYWNrIHx8IHRoaXMuZGVmYXVsdENhbGxiYWNrLFxuXHRcdGVsZW1lbnRzID0gKGFyZ3MuY29udGV4dCB8fCB3aW5kb3cuZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLScgKyB0aGlzLnNlbGVjdG9yICsgJ10nKSxcblx0XHRpO1xuXG5cdGlmKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGZvciAoaSBpbiBlbGVtZW50cykge1xuXHRcdGlmKGkgPT09ICdsZW5ndGgnIHx8IGkgPT09ICdpdGVtJykge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG4gICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2ldLFxuICAgICAgICAgICAgdmFsID0gZWwuZGF0YXNldFt0aGlzLnNlbGVjdG9yXSxcbiAgICAgICAgICAgIE1vZHVsZSA9IHRoaXMuaW5kZXhbdmFsXTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgYXR0cidzIHZhbHVlIGlzIGluIHRoZSBpbmRleC5cbiAgICAgICAgaWYgKCFNb2R1bGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnQ29tcG9uZW50IFwiJyArIHZhbCArICdcIiBpcyBub3QgcHJlc2VudCBpbiB0aGUgaW5kZXguJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUluc3RhbmNlKE1vZHVsZSwgZWwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSBDb25zdHJ1Y3RvclxuICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGNvbXBvbmVudCB3aWxsIG1vdW50IHVwb24uXG4gKiBAcGFyYW0gY2Ige0Z1bmN0aW9ufSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciB0aGUgaW5zdGFuY2Ugd2FzIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyB7RG9tUGFyc2VyfVxuICovXG5Eb21QYXJzZXIucHJvdG90eXBlLmNyZWF0ZUluc3RhbmNlID0gZnVuY3Rpb24oQ29uc3RydWN0b3IsIGVsLCBjYikge1xuXHQndXNlIHN0cmljdCc7XG5cblx0Ly8gQ3JlYXRlIHRoZSBpbnN0YW5jZSBvZiB0aGUgTW9kdWxlLlxuXHR2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoZWwsIGVsLmRhdGFzZXQpO1xuXG5cdGlmKGNiKSB7XG5cdFx0Y2IuY2FsbCh0aGlzLCBpbnN0YW5jZSwgZWwsIGVsLmRhdGFzZXQpO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8vIFJldHVybiB0aGUgQ29uc3RydWN0b3IuXG5tb2R1bGUuZXhwb3J0cyA9IERvbVBhcnNlcjsiLCJ2YXIgaGVscGVycyA9IHtcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICAgIGlmICggaSA9PT0gbGVuZ3RoICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb3B5SXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbihjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRpbWUtLTtcblxuICAgICAgICByZXR1cm4gLWNoYW5nZWRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSAtIDEpICsgc3RhcnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24oZWxlbWVudCwgcHJvcCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLk1velRyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubXNUcmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLk9UcmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHByb3A7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoZWxwZXJzOyJdfQ==
