(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * App.min.js
 * @description Require the main application modules.
 */

var ScrollReveal = require('scrollReveal'),
    DomParser = require('./Utilities/DomParser/Parser.js'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex(),
    componentParser;

// Register the base modules.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('parallaxStage', require('./Components/ParallaxStage/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentParser.
componentParser = new DomParser({
    constructors: componentStore.getIndex(),
    selector: 'component', // Equals [data-component="*"]
    defaultCallback: function(instance, el, dataset) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        // Initialize the module.
        instance.initialize.call(instance, el, dataset);

        return instance;
    }
}).parse();

var scrollReveal = new ScrollReveal();
},{"./Components/ClassToggler/View.js":2,"./Components/ParallaxStage/View.js":3,"./Components/ScrollTo/View.js":4,"./Utilities/ComponentIndex/Util.js":5,"./Utilities/DomParser/Parser.js":7,"scrollReveal":9}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ClassToggler}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":6}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    setTransform = require('./../../Utilities/Helpers').setTransform,
    ParallaxStage;

/**
 * ParallaxStage
 * @description Creates a subtle parallax scrolling effect on some child elements.
 * @constructor
 */
ParallaxStage = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the parallax values will be based on.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ParallaxStage}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.targets = document.querySelectorAll(dataset.target || '[data-parallax]');
        this.set('lastScrollTop', 0);

        // Setup the rAF.
        var self = this,
            _animFrame;

        (function animloop(){
            self.render();
            _animFrame = window.requestAnimationFrame(animloop);
        }());

        return this;
    },

    render: function() {
        'use strict';

        var currentScrollTop = document.body.scrollTop,
            lastScrollTop = this.get('lastScrollTop');

        if(currentScrollTop === lastScrollTop) {
            return this;
        }

        this.set('lastScrollTop', currentScrollTop);
        this.adjustPositions(currentScrollTop);

        return this;
    },
    adjustPositions: function(scrollTop) {
        'use strict';

        var stageOffset = this.el.offsetTop,
            scrollPos = scrollTop - stageOffset;

        this.setElementsTransformValue(this.targets[0], scrollPos);
        this.setElementsTransformValue(this.targets[1], scrollPos);

        return this;
    },
    setElementsTransformValue: function(element, scrollPos) {
        'use strict';

        var val = Math.round(scrollPos / (Math.abs(element.dataset.parallaxfactor) || 1));

        setTransform(element, 'translateY(' + val + 'px)');

        return this;
    }
});

module.exports = ParallaxStage;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],4:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ScrollTo}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],5:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        console.info('Component ' + key + ' was already registered in this index.', this);
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],6:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll WeiÃŸ
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function() {
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":8}],7:[function(require,module,exports){
/**
 * Parse the DOM for the given selector. If the value matches an item in the given index, create instances of it.
 *
 * @module Modules/DomParser
 */

var DomParser;

/**
 * DomParser
 * @param args {Object} The options object which will configure the parser.
 * @constructor
 */
DomParser = function(args) {
	'use strict';

	this.defaultCallback = args.defaultCallback;
	this.selector = args.selector;
	this.index = args.constructors;

    return this;
};


/**
 * parse
 * @description Parse trough the DOM.
 * @memberof module:Modules/DomParser
 * @param args {Object} Several options which can be passed individually on each parse.
 * @returns {DomParser}
 */
DomParser.prototype.parse = function(args) {
	'use strict';

    args = args || {};

	var callback = args.callback || this.defaultCallback,
		elements = (args.context || window.document).querySelectorAll('[data-' + this.selector + ']'),
		i;

	if(!elements.length) {
		return this;
	}

	for (i in elements) {
		if(i === 'length' || i === 'item') {
			continue;
		}

        var el = elements[i],
            val = el.dataset[this.selector],
            Module = this.index[val];

        // Check if the attr's value is in the index.
        if (!Module) {
            console.info('Component "' + val + '" is not present in the index.');
        } else {
            this.createInstance(Module, el, callback);
        }
	}

	return this;
};


/**
 *
 * @param Constructor
 * @param el {HTMLElement} The element on which the component will mount upon.
 * @param cb {Function} The callback to execute after the instance was created.
 * @returns {DomParser}
 */
DomParser.prototype.createInstance = function(Constructor, el, cb) {
	'use strict';

	// Create the instance of the Module.
	var instance = new Constructor(el, el.dataset);

	if(cb) {
		cb.call(this, instance, el, el.dataset);
	}

	return this;
};


// Return the Constructor.
module.exports = DomParser;
},{}],8:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },
    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    },
    setTransform: function(element, prop) {
        'use strict';

        element.style.webkitTransform = prop;
        element.style.MozTransform = prop;
        element.style.msTransform = prop;
        element.style.OTransform = prop;
        element.style.transform = prop;
    }
};

module.exports = helpers;
},{}],9:[function(require,module,exports){

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.scrollReveal = factory();
  }
}(this, function(require, exports, module) {

/*
                       _ _ _____                      _   _
                      | | |  __ \                    | | (_)
    ___  ___ _ __ ___ | | | |__) |_____   _____  __ _| |  _ ___
   / __|/ __| '__/ _ \| | |  _  // _ \ \ / / _ \/ _` | | | / __|
   \__ \ (__| | | (_) | | | | \ \  __/\ V /  __/ (_| | |_| \__ \
   |___/\___|_|  \___/|_|_|_|  \_\___| \_/ \___|\__,_|_(_) |___/ v2.1.0
                                                        _/ |
                                                       |__/

============================================================================*/

/**
 * scrollReveal.js (c) 2014 Julian Lloyd ( @julianlloyd )
 *
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */

window.scrollReveal = (function( window ) {

  'use strict'

  var _requestAnimFrame
    , extend
    , handler
    , self

  function scrollReveal( config ) {

    self         = this
    self.elems   = {}
    self.serial  = 1
    self.blocked = false
    self.config  = extend( self.defaults, config )

    if ( self.isMobile() && !self.config.mobile || !self.isSupported() ) {
      self.destroy()
      return
    }

    if ( self.config.viewport == window.document.documentElement ) {

      window.addEventListener( 'scroll', handler, false )
      window.addEventListener( 'resize', handler, false )

    } else self.config.viewport.addEventListener( 'scroll', handler, false )

    self.init( true )
  }

  scrollReveal.prototype = {

    defaults: {

      enter:    'bottom',
      move:     '8px',
      over:     '0.6s',
      wait:     '0s',
      easing:   'ease',

      scale:    { direction: 'up', power: '5%' },

      opacity:  0,
      mobile:   false,
      reset:    false,
      viewport: window.document.documentElement, // <HTML> element by default.

      /**
       *        'always' â€” delay every time an animation resets
       *        'once'   â€” delay only the first time an animation reveals
       *        'onload' - delay only for animations triggered by self.init()
       */
      delay:    'once',

      /**
       *        vFactor changes when an element is considered in the viewport;
       *        the default requires 60% of an element be visible.
       */
      vFactor:  0.60,

      complete: function( el ) {} // Note: reset animations do not complete.
    },

    /**
     * Queries the DOM, builds scrollReveal elements and triggers animation.
     * @param {boolean} flag â€” a hook for controlling delay on first load.
     */
    init: function( flag ) {

      var serial
        , elem
        , query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {

        serial      = self.serial++
        elem        = self.elems[ serial ] = { domEl: el }
        elem.config = self.configFactory( elem )
        elem.styles = self.styleFactory( elem )
        elem.seen   = false

        el.removeAttribute( 'data-sr' )
        el.setAttribute( 'style',

            elem.styles.inline
          + elem.styles.initial
        )
      })

      self.scrolled = self.scrollY()
      self.animate( flag )
    },

    /**
     * Applies and removes appropriate styles.
     * @param {boolean} flag â€” a hook for controlling delay on first load.
     */
    animate: function( flag ) {

      var key
        , elem
        , visible
        , complete

      /**
       * Cleans the DOM and removes completed elements from self.elems.
       * @param {integer} key â€” self.elems property key.
       */
      complete = function( key ) {

        var elem = self.elems[ key ]

        setTimeout(function() {

          elem.domEl.setAttribute( 'style', elem.styles.inline )
          elem.config.complete( elem.domEl )
          delete self.elems[ key ]

        }, elem.styles.duration )
      }

      /**
       * Begin loop.
       */
      for ( key in self.elems ) {
        if ( self.elems.hasOwnProperty( key ) ) {

          elem    = self.elems[ key ]
          visible = self.isElemInViewport( elem )

          if ( visible ) {

            if ( self.config.delay === 'always'
            || ( self.config.delay === 'onload' && flag )
            || ( self.config.delay === 'once'   && !elem.seen ) ) {

              /**
               * Use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.transition
              )

            } else {

              /**
               * Donâ€™t use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.reset
              )
            }

            elem.seen = true

            if ( !elem.config.reset && !elem.animating ) {

              /**
               * Reset is DISABLED for this element,
               * so letâ€™s count down to animation complete.
               */
              elem.animating = true
              complete( key )
            }
          }

          if ( !visible && elem.config.reset ) {

            /**
             * Reset is ENABLED for this element,
             * so letâ€™s apply its reset styles.
             */
            elem.domEl.setAttribute( 'style',

                elem.styles.inline
              + elem.styles.initial
              + elem.styles.reset
            )
          }
        }
      }

      self.blocked = false
    },

    /**
     * Parses an elements data-sr attribute, and returns a configuration object.
     * @param {object} elem â€” An object from self.elems.
     * @return {object}
     */
    configFactory: function( elem ) {

      var parsed = {}
        , config = {}
        , words  = elem.domEl.getAttribute( 'data-sr' ).split( /[, ]+/ )

      /**
       * Find and remove any syntax sugar.
       */
      words = self.filter( words )
      words.forEach(function( keyword, i ) {

        /**
         * Find keywords.
         */
        switch ( keyword ) {

          case 'enter':

            parsed.enter = words[ i + 1 ]
            return

          case 'wait':

            parsed.wait = words[ i + 1 ]
            return

          case 'move':

            parsed.move = words[ i + 1 ]
            return

          case 'ease':

            parsed.move = words[ i + 1 ]
            parsed.ease = 'ease'
            return

          case 'ease-in':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in'
            return

          case 'ease-in-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in-out'
            return

          case 'ease-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-out'
            return

          case 'hustle':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
            return

          case 'over':

            parsed.over = words[ i + 1 ]
            return

          case 'reset':

            if ( words[ i - 1 ] == 'no' ) parsed.reset = false
            else                          parsed.reset = true

            return

          case 'scale':

            parsed.scale = {}

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              return
            }

            parsed.scale.power = words[ i + 1 ]
            return

          default:
            return
        }
      })

      /**
       * Build default config object, then apply any
       * overrides parsed from the data-sr attribute.
       */
      config = extend( config, self.config )
      config = extend( config, parsed )

      if ( config.enter  == 'top'  || config.enter == 'bottom' ) config.axis = 'Y'
      if ( config.enter  == 'left' || config.enter == 'right'  ) config.axis = 'X'

      /**
       * Check for hustle easing.
       */
      if ( config.easing == 'hustle' ) config.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'

      /**
       * Letâ€™s make sure our our pixel distances are negative for top and left.
       * e.g. "enter top and move 25px" starts at 'top: -25px' in CSS.
       */
      if ( config.enter == 'top' || config.enter == 'left' ) config.move = '-' + config.move

      return config

    },

    /**
     * Generates styles based on an elements configuration property.
     * @param {object} elem â€” An object from self.elems.
     * @return {object}
     */
    styleFactory: function( elem ) {

      var transition
        , initial
        , target
        , reset
        , inline
        , build

      inline = ( elem.domEl.getAttribute( 'style' ) ) ? elem.domEl.getAttribute( 'style' ) + '; visibility: visible; ' : 'visibility: visible; '

      /**
       * Want to disable delay on mobile devices? Uncomment the line below.
       */
      //if ( self.isMobile() && self.config.mobile ) elem.config.wait = 0

      transition = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                  '-webkit-perspective: 1000;' +
          '-webkit-backface-visibility: hidden;'

      reset      = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                  '-webkit-perspective: 1000; ' +
          '-webkit-backface-visibility: hidden; '

      /**
       * Constructs initial and target styles.
       */
      build = function() {

        if ( parseInt( elem.config.move ) != 0 ) {

          initial += ' translate' + elem.config.axis + '(' + elem.config.move + ')'
          target  += ' translate' + elem.config.axis + '(0)'
        }

        if ( parseInt( elem.config.scale.power ) != 0 ) {

          if ( elem.config.scale.direction == 'up'   ) elem.config.scale.value = 1 - ( parseFloat( elem.config.scale.power ) * 0.01 )
          if ( elem.config.scale.direction == 'down' ) elem.config.scale.value = 1 + ( parseFloat( elem.config.scale.power ) * 0.01 )

          initial += ' scale(' + elem.config.scale.value + ')'
          target  += ' scale(1)'
        }

        initial += '; opacity: ' + elem.config.opacity + '; '
        target  += '; opacity: 1; ';
      }

      initial = 'transform:'
      target  = 'transform:'

      build()

      /**
       * Build again for webkit.
       */
      initial += '-webkit-transform:'
      target  += '-webkit-transform:'

      build()

      return {

        transition: transition,
        initial:    initial,
        target:     target,
        reset:      reset,
        inline:     inline,
        duration:   ( ( parseFloat( elem.config.over ) + parseFloat( elem.config.wait ) ) * 1000 )
      }
    },

    filter: function( words ) {

      var filtered  = []

      var sugar = [

        'from',
        'the',
        'and',
        'then',
        'but',
        'with',
        'please',
      ]

      words.forEach(function( word ) {

        if ( sugar.indexOf( word ) > -1 ) return

        filtered.push( word )
        return
      })

      return filtered
    },

    getViewportH: function() {

      var client = self.config.viewport[ 'clientHeight' ]
        , inner  = window[ 'innerHeight' ]

      if ( self.config.viewport == window.document.documentElement ) {

        return ( client < inner ) ? inner : client
      }

      return client
    },

    scrollY: function() {

      if ( self.config.viewport == window.document.documentElement ) return window.pageYOffset

      return self.config.viewport.scrollTop + self.config.viewport.offsetTop
    },

    getOffset: function( el ) {

      var offsetTop  = 0
        , offsetLeft = 0

      do {

        if ( !isNaN( el.offsetTop  )) offsetTop  += el.offsetTop
        if ( !isNaN( el.offsetLeft )) offsetLeft += el.offsetLeft

      } while ( el = el.offsetParent )

      return {

        top: offsetTop,
        left: offsetLeft
      }
    },

    isElemInViewport: function( elem ) {

      var elHeight = elem.domEl.offsetHeight
        , elTop    = self.getOffset( elem.domEl ).top
        , elBottom = elTop + elHeight
        , vFactor  = elem.config.vFactor || 0

      return ( elTop + elHeight * vFactor < self.scrolled + self.getViewportH() )
          && ( elBottom - elHeight * vFactor > self.scrolled )
          || ( elem.domEl.currentStyle ? elem.domEl.currentStyle : window.getComputedStyle( elem.domEl, null ) ).position == 'fixed'
    },

    isMobile: function() {

      var agent = navigator.userAgent || navigator.vendor || window.opera

      return (/(ipad|playbook|silk|android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test( agent )||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test( agent.substr( 0, 4 ))) ? true : false
    },

    isSupported: function() {

      var sensor    = document.createElement( 'sensor' )
        , cssPrefix = 'Webkit,Moz,O,'.split( ',' )
        , tests     = ( 'transition ' + cssPrefix.join( 'transition,' ) ).split( ',' )

      for ( var i = 0; i < tests.length; i++ ) {

        if ( !sensor.style[tests[i]] === '' ) return false
      }

      return true
    },

    destroy: function() {

      var query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {
        el.removeAttribute( 'data-sr' )
      })
    }

  }

  handler = function( e ) {

    if ( !self.blocked ) {

      self.blocked  = true
      self.scrolled = self.scrollY()

      _requestAnimFrame( function() {

        self.animate()
      })
    }
  }

  extend = function( target, src ) {

    for ( var prop in src ) {

      if ( src.hasOwnProperty( prop ) ) {

        target[ prop ] = src[ prop ]
      }
    }

    return target
  }

  /**
   * RequestAnimationFrame polyfill.
   */
  _requestAnimFrame = (function() {

    return window.requestAnimationFrame        ||
           window.webkitRequestAnimationFrame  ||
           window.mozRequestAnimationFrame     ||

          function( callback ) {

            window.setTimeout( callback, 1000 / 60 )
          }
  }())

  return scrollReveal

})( window )

return scrollReveal;

}));

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRG9tUGFyc2VyL1BhcnNlci5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9zY3JvbGxSZXZlYWwvZGlzdC9zY3JvbGxSZXZlYWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIEFwcC5taW4uanNcbiAqIEBkZXNjcmlwdGlvbiBSZXF1aXJlIHRoZSBtYWluIGFwcGxpY2F0aW9uIG1vZHVsZXMuXG4gKi9cblxudmFyIFNjcm9sbFJldmVhbCA9IHJlcXVpcmUoJ3Njcm9sbFJldmVhbCcpLFxuICAgIERvbVBhcnNlciA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0RvbVBhcnNlci9QYXJzZXIuanMnKSxcbiAgICBDb21wb25lbnRJbmRleCA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0NvbXBvbmVudEluZGV4L1V0aWwuanMnKSxcbiAgICBjb21wb25lbnRTdG9yZSA9IG5ldyBDb21wb25lbnRJbmRleCgpLFxuICAgIGNvbXBvbmVudFBhcnNlcjtcblxuLy8gUmVnaXN0ZXIgdGhlIGJhc2UgbW9kdWxlcy5cbmNvbXBvbmVudFN0b3JlLnJlZ2lzdGVyKCdjbGFzc1RvZ2dsZXInLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcigncGFyYWxsYXhTdGFnZScsIHJlcXVpcmUoJy4vQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3Rlcignc2Nyb2xsVG8nLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvU2Nyb2xsVG8vVmlldy5qcycpKTtcblxuLy8gU2V0cyB1cCB0aGUgY29tcG9uZW50UGFyc2VyLlxuY29tcG9uZW50UGFyc2VyID0gbmV3IERvbVBhcnNlcih7XG4gICAgY29uc3RydWN0b3JzOiBjb21wb25lbnRTdG9yZS5nZXRJbmRleCgpLFxuICAgIHNlbGVjdG9yOiAnY29tcG9uZW50JywgLy8gRXF1YWxzIFtkYXRhLWNvbXBvbmVudD1cIipcIl1cbiAgICBkZWZhdWx0Q2FsbGJhY2s6IGZ1bmN0aW9uKGluc3RhbmNlLCBlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYoIWluc3RhbmNlLmluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vZHVsZS5cbiAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZS5jYWxsKGluc3RhbmNlLCBlbCwgZGF0YXNldCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn0pLnBhcnNlKCk7XG5cbnZhciBzY3JvbGxSZXZlYWwgPSBuZXcgU2Nyb2xsUmV2ZWFsKCk7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIENsYXNzVG9nZ2xlcjtcblxuLyoqXG4gKiBDbGFzc1RvZ2dsZXJcbiAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIGEgY2xhc3Mgb24gYSB0YXJnZXQgZWxlbWVudCBvbiBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5DbGFzc1RvZ2dsZXIgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBkYXRhc2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhc2V0LnRhcmdldCk7XG4gICAgICAgIHRoaXMuc2V0KCdjbGFzcycsIGRhdGFzZXQuY2xhc3MgfHwgJ2FjdGl2ZScpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZUNsYXNzXG4gICAgICogQGRlc2NyaXB0aW9uIFRvZ2dsZXMgdGhlIGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudGFyZ2V0WzBdLmNsYXNzTGlzdC50b2dnbGUodGhpcy5nZXQoJ2NsYXNzJykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzVG9nZ2xlcjsiLCJ2YXIgY29tcG9uZW50UHJvdG90eXBlID0gcmVxdWlyZSgnY29tcG9uZW50UHJvdG90eXBlJyksXG4gICAgc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi8uLi8uLi9VdGlsaXRpZXMvSGVscGVycycpLnNldFRyYW5zZm9ybSxcbiAgICBQYXJhbGxheFN0YWdlO1xuXG4vKipcbiAqIFBhcmFsbGF4U3RhZ2VcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc3VidGxlIHBhcmFsbGF4IHNjcm9sbGluZyBlZmZlY3Qgb24gc29tZSBjaGlsZCBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QYXJhbGxheFN0YWdlID0gY29tcG9uZW50UHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9IFRoZSBFbGVtZW50IG9uIHdoaWNoIHRoZSBwYXJhbGxheCB2YWx1ZXMgd2lsbCBiZSBiYXNlZCBvbi5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7UGFyYWxsYXhTdGFnZX1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFzZXQudGFyZ2V0IHx8ICdbZGF0YS1wYXJhbGxheF0nKTtcbiAgICAgICAgdGhpcy5zZXQoJ2xhc3RTY3JvbGxUb3AnLCAwKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgckFGLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBfYW5pbUZyYW1lO1xuXG4gICAgICAgIChmdW5jdGlvbiBhbmltbG9vcCgpe1xuICAgICAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICAgICAgIF9hbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1sb29wKTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBsYXN0U2Nyb2xsVG9wID0gdGhpcy5nZXQoJ2xhc3RTY3JvbGxUb3AnKTtcblxuICAgICAgICBpZihjdXJyZW50U2Nyb2xsVG9wID09PSBsYXN0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0KCdsYXN0U2Nyb2xsVG9wJywgY3VycmVudFNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuYWRqdXN0UG9zaXRpb25zKGN1cnJlbnRTY3JvbGxUb3ApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRqdXN0UG9zaXRpb25zOiBmdW5jdGlvbihzY3JvbGxUb3ApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBzdGFnZU9mZnNldCA9IHRoaXMuZWwub2Zmc2V0VG9wLFxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gc2Nyb2xsVG9wIC0gc3RhZ2VPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlKHRoaXMudGFyZ2V0c1swXSwgc2Nyb2xsUG9zKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlKHRoaXMudGFyZ2V0c1sxXSwgc2Nyb2xsUG9zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldEVsZW1lbnRzVHJhbnNmb3JtVmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQsIHNjcm9sbFBvcykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIHZhbCA9IE1hdGgucm91bmQoc2Nyb2xsUG9zIC8gKE1hdGguYWJzKGVsZW1lbnQuZGF0YXNldC5wYXJhbGxheGZhY3RvcikgfHwgMSkpO1xuXG4gICAgICAgIHNldFRyYW5zZm9ybShlbGVtZW50LCAndHJhbnNsYXRlWSgnICsgdmFsICsgJ3B4KScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGF4U3RhZ2U7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIGVhc2VJbk91dFF1YWQgPSByZXF1aXJlKCcuLy4uLy4uL1V0aWxpdGllcy9IZWxwZXJzJykuZWFzZUluT3V0UXVhZCxcbiAgICBTY3JvbGxUbztcblxuLyoqXG4gKiBTY3JvbGxUb1xuICogQGRlc2NyaXB0aW9uIFNjcm9sbHMgdG8gYSBjZXJ0YWluIHRhcmdldCBlbGVtZW50IG9uIHRoZSBlbGVtZW50cyBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5TY3JvbGxUbyA9IGNvbXBvbmVudFByb3RvdHlwZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgRWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSBtb3VudGVkLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQpWzBdO1xuICAgICAgICB0aGlzLnNldCgnZHVyYXRpb24nLCBkYXRhc2V0LmR1cmF0aW9uIHx8IDYwMCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9UYXJnZXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xsVG9UYXJnZXRcbiAgICAgKiBAZGVzY3JpcHRpb24gU2Nyb2xscyB0byB0aGUgdGFyZ2V0LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBzY3JvbGxUb1RhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB0byA9IHRoaXMudGFyZ2V0Lm9mZnNldFRvcCxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoJ2R1cmF0aW9uJyksXG4gICAgICAgICAgICBzdGFydCA9IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgY2hhbmdlID0gdG8gLSBzdGFydCxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gMCxcbiAgICAgICAgICAgIGluY3JlbWVudCA9IDIwO1xuXG4gICAgICAgIHZhciBhbmltYXRlU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIHZhciB2YWwgPSBlYXNlSW5PdXRRdWFkKGN1cnJlbnRUaW1lLCBzdGFydCwgY2hhbmdlLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFuaW1hdGVTY3JvbGwsIGluY3JlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGVTY3JvbGwoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxUbzsiLCJ2YXIgQ29tcG9uZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmluZGV4ID0ge307XG59O1xuQ29tcG9uZW50SW5kZXgucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5LCBDb25zdHJ1Y3Rvcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmKCFrZXkgfHwgIUNvbnN0cnVjdG9yIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBDb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZih0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDb21wb25lbnQgJyArIGtleSArICcgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGlzIGluZGV4LicsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcbkNvbXBvbmVudEluZGV4LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmluZGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50SW5kZXg7IiwiLyoqXG4gKiBNb2R1bGVQcm90b3R5cGVcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc2V0IG9mIGhhbmR5IGZ1bmN0aW9ucyBhbmQgcmVmZXJlbmNlIHRoZW0gdG8gYSB0YXJnZXQgZS5nLjpcbiAqIEBhdXRob3IgVHlsbCBXZWnDn1xuICovXG5cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vSGVscGVycy5qcycpLmV4dGVuZDtcblxudmFyIFByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXRpYWxpemVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEEgZHVtbXkgaW5pdGlhbGl6ZSBmdW5jdGlvbiB3aGljaCBzZXQncyBnaXZlbiBhdHRyaWJ1dGVzIG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHtvYmplY3QgfHwgc3RyaW5nfSBUaGUgYXR0cmlidXRlKHMpIHRvIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBJZiBhdHRyaWJ1dGVzIHdoZXJlIHBhc3NlZCwgc2V0IHRoZW0gb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgaWYoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYSBrZXkgJiB2YWwgcGFpciBvbiB0aGUgbW9kdWxlIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gdmFsIHtzdHJpbmd9IFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmosIGlmIHRydWUgLSBzZXQgZWFjaCBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uKG9iaktleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W29iaktleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgc2V0IHRoZSBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bnNldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5zZXQvRGVsZXRlIGEga2V5IGZyb20gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB1bnNldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgdmFsdWUgb2YgYW4ga2V5IGluIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byBsb29rIGZvciBpbiB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBib29sIHdoaWNoIGluZGljYXRlcyBpZiBhbiBhdHRyaWJ1dGUgd2FzIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0ciB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgaW5pdGlhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIG1vZHVsZSwgaW52b2tlcyBhIG5ldyBtb2R1bGUgQ29uc3RydWN0b3IgYW5kIGV4dGVuZHMgdGhlIHByb3RvdHlwZSB3aXRoIGFsbCBmdW5jdGlvbnMgZm91bmQgaW4gdGhpcyBvYmplY3QuXG4gICAgICAgICAqIEBleGFtcGxlIFByb3RvdHlwZS5leHRlbmQoe29iamVjdH0pO1xuICAgICAgICAgKiBAcGFyYW0gcHJvdG90eXBlUHJvcHMge29iamVjdH0gQSBzZXQgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjcmVhdGVkIENvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgICBvYmogPSBvYmogPyBvYmogOiB7fTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGZ1bmN0aW9uIHdyYXBwZXIuXG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdpdGggdGhlIGJhc2UgZnVuY3Rpb25zLCBhcyB3ZWxsIGFzIHRoZSBwcm90b1Byb3BzXG4gICAgICAgICAgICBleHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB0aGlzLCBvYmopO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHRhcmdldCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWl4aW5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIE1peCBhIHNldCBvZiBmdW5jdGlvbnMgaW50byB0aGUgY3VycmVudCBwcm90b3R5cGUuXG4gICAgICAgICAqIEBleGFtcGxlIHRoaXMubWl4aW4oeyBnZXRGb3VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDIrMjsgfSB9KTtcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB7T2JqZWN0fSBUaGUgcHJvdG90eXBlLCB0byBtaXggdGhlIE9iaiBpbnRvLlxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtvYmplY3R9IEEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgb24gdGhlIGN1cnJlbnQgcHJvdG90eXBlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IGZ1bmN0aW9uKHRhcmdldCwgb2JqKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iaiA9IG9iaiA/IG9iaiA6IHt9O1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIGlmKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSB0YXJnZXQgZnVuY3Rpb24gd2l0aCB0aGUgYmFzZSBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIHByb3RvUHJvcHNcbiAgICAgICAgICAgIGV4dGVuZCh0YXJnZXQsIG9iaik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b3R5cGU7IiwiLyoqXG4gKiBQYXJzZSB0aGUgRE9NIGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIElmIHRoZSB2YWx1ZSBtYXRjaGVzIGFuIGl0ZW0gaW4gdGhlIGdpdmVuIGluZGV4LCBjcmVhdGUgaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIEBtb2R1bGUgTW9kdWxlcy9Eb21QYXJzZXJcbiAqL1xuXG52YXIgRG9tUGFyc2VyO1xuXG4vKipcbiAqIERvbVBhcnNlclxuICogQHBhcmFtIGFyZ3Mge09iamVjdH0gVGhlIG9wdGlvbnMgb2JqZWN0IHdoaWNoIHdpbGwgY29uZmlndXJlIHRoZSBwYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuRG9tUGFyc2VyID0gZnVuY3Rpb24oYXJncykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dGhpcy5kZWZhdWx0Q2FsbGJhY2sgPSBhcmdzLmRlZmF1bHRDYWxsYmFjaztcblx0dGhpcy5zZWxlY3RvciA9IGFyZ3Muc2VsZWN0b3I7XG5cdHRoaXMuaW5kZXggPSBhcmdzLmNvbnN0cnVjdG9ycztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIHBhcnNlXG4gKiBAZGVzY3JpcHRpb24gUGFyc2UgdHJvdWdoIHRoZSBET00uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOk1vZHVsZXMvRG9tUGFyc2VyXG4gKiBAcGFyYW0gYXJncyB7T2JqZWN0fSBTZXZlcmFsIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbmRpdmlkdWFsbHkgb24gZWFjaCBwYXJzZS5cbiAqIEByZXR1cm5zIHtEb21QYXJzZXJ9XG4gKi9cbkRvbVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG5cdHZhciBjYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgdGhpcy5kZWZhdWx0Q2FsbGJhY2ssXG5cdFx0ZWxlbWVudHMgPSAoYXJncy5jb250ZXh0IHx8IHdpbmRvdy5kb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtJyArIHRoaXMuc2VsZWN0b3IgKyAnXScpLFxuXHRcdGk7XG5cblx0aWYoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Zm9yIChpIGluIGVsZW1lbnRzKSB7XG5cdFx0aWYoaSA9PT0gJ2xlbmd0aCcgfHwgaSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cbiAgICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV0sXG4gICAgICAgICAgICB2YWwgPSBlbC5kYXRhc2V0W3RoaXMuc2VsZWN0b3JdLFxuICAgICAgICAgICAgTW9kdWxlID0gdGhpcy5pbmRleFt2YWxdO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhdHRyJ3MgdmFsdWUgaXMgaW4gdGhlIGluZGV4LlxuICAgICAgICBpZiAoIU1vZHVsZSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdDb21wb25lbnQgXCInICsgdmFsICsgJ1wiIGlzIG5vdCBwcmVzZW50IGluIHRoZSBpbmRleC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSW5zdGFuY2UoTW9kdWxlLCBlbCwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIENvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgbW91bnQgdXBvbi5cbiAqIEBwYXJhbSBjYiB7RnVuY3Rpb259IFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBpbnN0YW5jZSB3YXMgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtEb21QYXJzZXJ9XG4gKi9cbkRvbVBhcnNlci5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZWwsIGNiKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBDcmVhdGUgdGhlIGluc3RhbmNlIG9mIHRoZSBNb2R1bGUuXG5cdHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcihlbCwgZWwuZGF0YXNldCk7XG5cblx0aWYoY2IpIHtcblx0XHRjYi5jYWxsKHRoaXMsIGluc3RhbmNlLCBlbCwgZWwuZGF0YXNldCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBDb25zdHJ1Y3Rvci5cbm1vZHVsZS5leHBvcnRzID0gRG9tUGFyc2VyOyIsInZhciBoZWxwZXJzID0ge1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgICBpID0gMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcblxuICAgICAgICAgICAgLy8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBpID09PSBsZW5ndGggKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0WyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBjaGFuZ2VkVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VGltZS0tO1xuXG4gICAgICAgIHJldHVybiAtY2hhbmdlZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuTW96VHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuT1RyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gcHJvcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhlbHBlcnM7IiwiXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2Nyb2xsUmV2ZWFsID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICBfIF8gX19fX18gICAgICAgICAgICAgICAgICAgICAgXyAgIF9cbiAgICAgICAgICAgICAgICAgICAgICB8IHwgfCAgX18gXFwgICAgICAgICAgICAgICAgICAgIHwgfCAoXylcbiAgICBfX18gIF9fXyBfIF9fIF9fXyB8IHwgfCB8X18pIHxfX19fXyAgIF9fX19fICBfXyBffCB8ICBfIF9fX1xuICAgLyBfX3wvIF9ffCAnX18vIF8gXFx8IHwgfCAgXyAgLy8gXyBcXCBcXCAvIC8gXyBcXC8gX2AgfCB8IHwgLyBfX3xcbiAgIFxcX18gXFwgKF9ffCB8IHwgKF8pIHwgfCB8IHwgXFwgXFwgIF9fL1xcIFYgLyAgX18vIChffCB8IHxffCBcXF9fIFxcXG4gICB8X19fL1xcX19ffF98ICBcXF9fXy98X3xffF98ICBcXF9cXF9fX3wgXFxfLyBcXF9fX3xcXF9fLF98XyhfKSB8X19fLyB2Mi4xLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy8gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfXy9cblxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8qKlxuICogc2Nyb2xsUmV2ZWFsLmpzIChjKSAyMDE0IEp1bGlhbiBMbG95ZCAoIEBqdWxpYW5sbG95ZCApXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICovXG5cbndpbmRvdy5zY3JvbGxSZXZlYWwgPSAoZnVuY3Rpb24oIHdpbmRvdyApIHtcblxuICAndXNlIHN0cmljdCdcblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWVcbiAgICAsIGV4dGVuZFxuICAgICwgaGFuZGxlclxuICAgICwgc2VsZlxuXG4gIGZ1bmN0aW9uIHNjcm9sbFJldmVhbCggY29uZmlnICkge1xuXG4gICAgc2VsZiAgICAgICAgID0gdGhpc1xuICAgIHNlbGYuZWxlbXMgICA9IHt9XG4gICAgc2VsZi5zZXJpYWwgID0gMVxuICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlXG4gICAgc2VsZi5jb25maWcgID0gZXh0ZW5kKCBzZWxmLmRlZmF1bHRzLCBjb25maWcgKVxuXG4gICAgaWYgKCBzZWxmLmlzTW9iaWxlKCkgJiYgIXNlbGYuY29uZmlnLm1vYmlsZSB8fCAhc2VsZi5pc1N1cHBvcnRlZCgpICkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICggc2VsZi5jb25maWcudmlld3BvcnQgPT0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdzY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSApXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIGhhbmRsZXIsIGZhbHNlIClcblxuICAgIH0gZWxzZSBzZWxmLmNvbmZpZy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgaGFuZGxlciwgZmFsc2UgKVxuXG4gICAgc2VsZi5pbml0KCB0cnVlIClcbiAgfVxuXG4gIHNjcm9sbFJldmVhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBkZWZhdWx0czoge1xuXG4gICAgICBlbnRlcjogICAgJ2JvdHRvbScsXG4gICAgICBtb3ZlOiAgICAgJzhweCcsXG4gICAgICBvdmVyOiAgICAgJzAuNnMnLFxuICAgICAgd2FpdDogICAgICcwcycsXG4gICAgICBlYXNpbmc6ICAgJ2Vhc2UnLFxuXG4gICAgICBzY2FsZTogICAgeyBkaXJlY3Rpb246ICd1cCcsIHBvd2VyOiAnNSUnIH0sXG5cbiAgICAgIG9wYWNpdHk6ICAwLFxuICAgICAgbW9iaWxlOiAgIGZhbHNlLFxuICAgICAgcmVzZXQ6ICAgIGZhbHNlLFxuICAgICAgdmlld3BvcnQ6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIC8vIDxIVE1MPiBlbGVtZW50IGJ5IGRlZmF1bHQuXG5cbiAgICAgIC8qKlxuICAgICAgICogICAgICAgICdhbHdheXMnIOKAlCBkZWxheSBldmVyeSB0aW1lIGFuIGFuaW1hdGlvbiByZXNldHNcbiAgICAgICAqICAgICAgICAnb25jZScgICDigJQgZGVsYXkgb25seSB0aGUgZmlyc3QgdGltZSBhbiBhbmltYXRpb24gcmV2ZWFsc1xuICAgICAgICogICAgICAgICdvbmxvYWQnIC0gZGVsYXkgb25seSBmb3IgYW5pbWF0aW9ucyB0cmlnZ2VyZWQgYnkgc2VsZi5pbml0KClcbiAgICAgICAqL1xuICAgICAgZGVsYXk6ICAgICdvbmNlJyxcblxuICAgICAgLyoqXG4gICAgICAgKiAgICAgICAgdkZhY3RvciBjaGFuZ2VzIHdoZW4gYW4gZWxlbWVudCBpcyBjb25zaWRlcmVkIGluIHRoZSB2aWV3cG9ydDtcbiAgICAgICAqICAgICAgICB0aGUgZGVmYXVsdCByZXF1aXJlcyA2MCUgb2YgYW4gZWxlbWVudCBiZSB2aXNpYmxlLlxuICAgICAgICovXG4gICAgICB2RmFjdG9yOiAgMC42MCxcblxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCBlbCApIHt9IC8vIE5vdGU6IHJlc2V0IGFuaW1hdGlvbnMgZG8gbm90IGNvbXBsZXRlLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIHRoZSBET00sIGJ1aWxkcyBzY3JvbGxSZXZlYWwgZWxlbWVudHMgYW5kIHRyaWdnZXJzIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcg4oCUIGEgaG9vayBmb3IgY29udHJvbGxpbmcgZGVsYXkgb24gZmlyc3QgbG9hZC5cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiggZmxhZyApIHtcblxuICAgICAgdmFyIHNlcmlhbFxuICAgICAgICAsIGVsZW1cbiAgICAgICAgLCBxdWVyeVxuXG4gICAgICBxdWVyeSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBzZWxmLmNvbmZpZy52aWV3cG9ydC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtc3JdJyApIClcbiAgICAgIHF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKCBlbCApIHtcblxuICAgICAgICBzZXJpYWwgICAgICA9IHNlbGYuc2VyaWFsKytcbiAgICAgICAgZWxlbSAgICAgICAgPSBzZWxmLmVsZW1zWyBzZXJpYWwgXSA9IHsgZG9tRWw6IGVsIH1cbiAgICAgICAgZWxlbS5jb25maWcgPSBzZWxmLmNvbmZpZ0ZhY3RvcnkoIGVsZW0gKVxuICAgICAgICBlbGVtLnN0eWxlcyA9IHNlbGYuc3R5bGVGYWN0b3J5KCBlbGVtIClcbiAgICAgICAgZWxlbS5zZWVuICAgPSBmYWxzZVxuXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtc3InIClcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLFxuXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmVcbiAgICAgICAgICArIGVsZW0uc3R5bGVzLmluaXRpYWxcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgc2VsZi5zY3JvbGxlZCA9IHNlbGYuc2Nyb2xsWSgpXG4gICAgICBzZWxmLmFuaW1hdGUoIGZsYWcgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuZCByZW1vdmVzIGFwcHJvcHJpYXRlIHN0eWxlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcg4oCUIGEgaG9vayBmb3IgY29udHJvbGxpbmcgZGVsYXkgb24gZmlyc3QgbG9hZC5cbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbiggZmxhZyApIHtcblxuICAgICAgdmFyIGtleVxuICAgICAgICAsIGVsZW1cbiAgICAgICAgLCB2aXNpYmxlXG4gICAgICAgICwgY29tcGxldGVcblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhbnMgdGhlIERPTSBhbmQgcmVtb3ZlcyBjb21wbGV0ZWQgZWxlbWVudHMgZnJvbSBzZWxmLmVsZW1zLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBrZXkg4oCUIHNlbGYuZWxlbXMgcHJvcGVydHkga2V5LlxuICAgICAgICovXG4gICAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGVsZW0gPSBzZWxmLmVsZW1zWyBrZXkgXVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgZWxlbS5zdHlsZXMuaW5saW5lIClcbiAgICAgICAgICBlbGVtLmNvbmZpZy5jb21wbGV0ZSggZWxlbS5kb21FbCApXG4gICAgICAgICAgZGVsZXRlIHNlbGYuZWxlbXNbIGtleSBdXG5cbiAgICAgICAgfSwgZWxlbS5zdHlsZXMuZHVyYXRpb24gKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJlZ2luIGxvb3AuXG4gICAgICAgKi9cbiAgICAgIGZvciAoIGtleSBpbiBzZWxmLmVsZW1zICkge1xuICAgICAgICBpZiAoIHNlbGYuZWxlbXMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXG4gICAgICAgICAgZWxlbSAgICA9IHNlbGYuZWxlbXNbIGtleSBdXG4gICAgICAgICAgdmlzaWJsZSA9IHNlbGYuaXNFbGVtSW5WaWV3cG9ydCggZWxlbSApXG5cbiAgICAgICAgICBpZiAoIHZpc2libGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2VsZi5jb25maWcuZGVsYXkgPT09ICdhbHdheXMnXG4gICAgICAgICAgICB8fCAoIHNlbGYuY29uZmlnLmRlbGF5ID09PSAnb25sb2FkJyAmJiBmbGFnIClcbiAgICAgICAgICAgIHx8ICggc2VsZi5jb25maWcuZGVsYXkgPT09ICdvbmNlJyAgICYmICFlbGVtLnNlZW4gKSApIHtcblxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogVXNlIGRlbGF5LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoICdzdHlsZScsXG5cbiAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZVxuICAgICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy50cmFuc2l0aW9uXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogRG9u4oCZdCB1c2UgZGVsYXkuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSggJ3N0eWxlJyxcblxuICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lXG4gICAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy50YXJnZXRcbiAgICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnJlc2V0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbS5zZWVuID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoICFlbGVtLmNvbmZpZy5yZXNldCAmJiAhZWxlbS5hbmltYXRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlc2V0IGlzIERJU0FCTEVEIGZvciB0aGlzIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAqIHNvIGxldOKAmXMgY291bnQgZG93biB0byBhbmltYXRpb24gY29tcGxldGUuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBlbGVtLmFuaW1hdGluZyA9IHRydWVcbiAgICAgICAgICAgICAgY29tcGxldGUoIGtleSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCAhdmlzaWJsZSAmJiBlbGVtLmNvbmZpZy5yZXNldCApIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCBpcyBFTkFCTEVEIGZvciB0aGlzIGVsZW1lbnQsXG4gICAgICAgICAgICAgKiBzbyBsZXTigJlzIGFwcGx5IGl0cyByZXNldCBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLFxuXG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lXG4gICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMuaW5pdGlhbFxuICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnJlc2V0XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBlbGVtZW50cyBkYXRhLXNyIGF0dHJpYnV0ZSwgYW5kIHJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbSDigJQgQW4gb2JqZWN0IGZyb20gc2VsZi5lbGVtcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uZmlnRmFjdG9yeTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgIHZhciBwYXJzZWQgPSB7fVxuICAgICAgICAsIGNvbmZpZyA9IHt9XG4gICAgICAgICwgd29yZHMgID0gZWxlbS5kb21FbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXNyJyApLnNwbGl0KCAvWywgXSsvIClcblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGFuZCByZW1vdmUgYW55IHN5bnRheCBzdWdhci5cbiAgICAgICAqL1xuICAgICAgd29yZHMgPSBzZWxmLmZpbHRlciggd29yZHMgKVxuICAgICAgd29yZHMuZm9yRWFjaChmdW5jdGlvbigga2V5d29yZCwgaSApIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBrZXl3b3Jkcy5cbiAgICAgICAgICovXG4gICAgICAgIHN3aXRjaCAoIGtleXdvcmQgKSB7XG5cbiAgICAgICAgICBjYXNlICdlbnRlcic6XG5cbiAgICAgICAgICAgIHBhcnNlZC5lbnRlciA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ3dhaXQnOlxuXG4gICAgICAgICAgICBwYXJzZWQud2FpdCA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ21vdmUnOlxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2Vhc2UnOlxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzZSA9ICdlYXNlJ1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLWluJzpcblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgICAgICAgICAgPSAnZWFzZS1pbidcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlICAgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcGFyc2VkLmVhc2luZyA9ICdlYXNlLWluJ1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLWluLW91dCc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgKyAxIF0gPT0gJ3VwJyB8fCB3b3Jkc1sgaSArIDEgXSA9PSAnZG93bicgKSB7XG5cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLmRpcmVjdGlvbiA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciAgICAgPSB3b3Jkc1sgaSArIDIgXVxuICAgICAgICAgICAgICBwYXJzZWQuZWFzaW5nICAgICAgICAgID0gJ2Vhc2UtaW4tb3V0J1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2Vhc2UtaW4tb3V0J1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLW91dCc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgKyAxIF0gPT0gJ3VwJyB8fCB3b3Jkc1sgaSArIDEgXSA9PSAnZG93bicgKSB7XG5cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLmRpcmVjdGlvbiA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciAgICAgPSB3b3Jkc1sgaSArIDIgXVxuICAgICAgICAgICAgICBwYXJzZWQuZWFzaW5nICAgICAgICAgID0gJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdodXN0bGUnOlxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpICsgMSBdID09ICd1cCcgfHwgd29yZHNbIGkgKyAxIF0gPT0gJ2Rvd24nICkge1xuXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5kaXJlY3Rpb24gPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgICAgID0gd29yZHNbIGkgKyAyIF1cbiAgICAgICAgICAgICAgcGFyc2VkLmVhc2luZyAgICAgICAgICA9ICdjdWJpYy1iZXppZXIoIDAuNiwgMC4yLCAwLjEsIDEgKSdcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlICAgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcGFyc2VkLmVhc2luZyA9ICdjdWJpYy1iZXppZXIoIDAuNiwgMC4yLCAwLjEsIDEgKSdcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnb3Zlcic6XG5cbiAgICAgICAgICAgIHBhcnNlZC5vdmVyID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAncmVzZXQnOlxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpIC0gMSBdID09ICdubycgKSBwYXJzZWQucmVzZXQgPSBmYWxzZVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnJlc2V0ID0gdHJ1ZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcblxuICAgICAgICAgICAgcGFyc2VkLnNjYWxlID0ge31cblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8qKlxuICAgICAgICogQnVpbGQgZGVmYXVsdCBjb25maWcgb2JqZWN0LCB0aGVuIGFwcGx5IGFueVxuICAgICAgICogb3ZlcnJpZGVzIHBhcnNlZCBmcm9tIHRoZSBkYXRhLXNyIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgY29uZmlnID0gZXh0ZW5kKCBjb25maWcsIHNlbGYuY29uZmlnIClcbiAgICAgIGNvbmZpZyA9IGV4dGVuZCggY29uZmlnLCBwYXJzZWQgKVxuXG4gICAgICBpZiAoIGNvbmZpZy5lbnRlciAgPT0gJ3RvcCcgIHx8IGNvbmZpZy5lbnRlciA9PSAnYm90dG9tJyApIGNvbmZpZy5heGlzID0gJ1knXG4gICAgICBpZiAoIGNvbmZpZy5lbnRlciAgPT0gJ2xlZnQnIHx8IGNvbmZpZy5lbnRlciA9PSAncmlnaHQnICApIGNvbmZpZy5heGlzID0gJ1gnXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgZm9yIGh1c3RsZSBlYXNpbmcuXG4gICAgICAgKi9cbiAgICAgIGlmICggY29uZmlnLmVhc2luZyA9PSAnaHVzdGxlJyApIGNvbmZpZy5lYXNpbmcgPSAnY3ViaWMtYmV6aWVyKCAwLjYsIDAuMiwgMC4xLCAxICknXG5cbiAgICAgIC8qKlxuICAgICAgICogTGV04oCZcyBtYWtlIHN1cmUgb3VyIG91ciBwaXhlbCBkaXN0YW5jZXMgYXJlIG5lZ2F0aXZlIGZvciB0b3AgYW5kIGxlZnQuXG4gICAgICAgKiBlLmcuIFwiZW50ZXIgdG9wIGFuZCBtb3ZlIDI1cHhcIiBzdGFydHMgYXQgJ3RvcDogLTI1cHgnIGluIENTUy5cbiAgICAgICAqL1xuICAgICAgaWYgKCBjb25maWcuZW50ZXIgPT0gJ3RvcCcgfHwgY29uZmlnLmVudGVyID09ICdsZWZ0JyApIGNvbmZpZy5tb3ZlID0gJy0nICsgY29uZmlnLm1vdmVcblxuICAgICAgcmV0dXJuIGNvbmZpZ1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBzdHlsZXMgYmFzZWQgb24gYW4gZWxlbWVudHMgY29uZmlndXJhdGlvbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbSDigJQgQW4gb2JqZWN0IGZyb20gc2VsZi5lbGVtcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgc3R5bGVGYWN0b3J5OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgdmFyIHRyYW5zaXRpb25cbiAgICAgICAgLCBpbml0aWFsXG4gICAgICAgICwgdGFyZ2V0XG4gICAgICAgICwgcmVzZXRcbiAgICAgICAgLCBpbmxpbmVcbiAgICAgICAgLCBidWlsZFxuXG4gICAgICBpbmxpbmUgPSAoIGVsZW0uZG9tRWwuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICkgKSA/IGVsZW0uZG9tRWwuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICkgKyAnOyB2aXNpYmlsaXR5OiB2aXNpYmxlOyAnIDogJ3Zpc2liaWxpdHk6IHZpc2libGU7ICdcblxuICAgICAgLyoqXG4gICAgICAgKiBXYW50IHRvIGRpc2FibGUgZGVsYXkgb24gbW9iaWxlIGRldmljZXM/IFVuY29tbWVudCB0aGUgbGluZSBiZWxvdy5cbiAgICAgICAqL1xuICAgICAgLy9pZiAoIHNlbGYuaXNNb2JpbGUoKSAmJiBzZWxmLmNvbmZpZy5tb2JpbGUgKSBlbGVtLmNvbmZpZy53YWl0ID0gMFxuXG4gICAgICB0cmFuc2l0aW9uID0gJy13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gJyArIGVsZW0uY29uZmlnLm92ZXIgKyAnICcgKyBlbGVtLmNvbmZpZy5lYXNpbmcgKyAnICcgKyBlbGVtLmNvbmZpZy53YWl0ICsgJywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgJyArIGVsZW0uY29uZmlnLndhaXQgKyAnOyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJyAgICAgICAgICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgJyArIGVsZW0uY29uZmlnLndhaXQgKyAnLCBvcGFjaXR5ICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAnICsgZWxlbS5jb25maWcud2FpdCArICc7ICcgK1xuICAgICAgICAgICAgICAgICAgJy13ZWJraXQtcGVyc3BlY3RpdmU6IDEwMDA7JyArXG4gICAgICAgICAgJy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOydcblxuICAgICAgcmVzZXQgICAgICA9ICctd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwcywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgMHM7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zaXRpb246IHRyYW5zZm9ybSAnICAgICAgICAgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwcywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgMHM7ICcgK1xuICAgICAgICAgICAgICAgICAgJy13ZWJraXQtcGVyc3BlY3RpdmU6IDEwMDA7ICcgK1xuICAgICAgICAgICctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgJ1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgaW5pdGlhbCBhbmQgdGFyZ2V0IHN0eWxlcy5cbiAgICAgICAqL1xuICAgICAgYnVpbGQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIHBhcnNlSW50KCBlbGVtLmNvbmZpZy5tb3ZlICkgIT0gMCApIHtcblxuICAgICAgICAgIGluaXRpYWwgKz0gJyB0cmFuc2xhdGUnICsgZWxlbS5jb25maWcuYXhpcyArICcoJyArIGVsZW0uY29uZmlnLm1vdmUgKyAnKSdcbiAgICAgICAgICB0YXJnZXQgICs9ICcgdHJhbnNsYXRlJyArIGVsZW0uY29uZmlnLmF4aXMgKyAnKDApJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYXJzZUludCggZWxlbS5jb25maWcuc2NhbGUucG93ZXIgKSAhPSAwICkge1xuXG4gICAgICAgICAgaWYgKCBlbGVtLmNvbmZpZy5zY2FsZS5kaXJlY3Rpb24gPT0gJ3VwJyAgICkgZWxlbS5jb25maWcuc2NhbGUudmFsdWUgPSAxIC0gKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5zY2FsZS5wb3dlciApICogMC4wMSApXG4gICAgICAgICAgaWYgKCBlbGVtLmNvbmZpZy5zY2FsZS5kaXJlY3Rpb24gPT0gJ2Rvd24nICkgZWxlbS5jb25maWcuc2NhbGUudmFsdWUgPSAxICsgKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5zY2FsZS5wb3dlciApICogMC4wMSApXG5cbiAgICAgICAgICBpbml0aWFsICs9ICcgc2NhbGUoJyArIGVsZW0uY29uZmlnLnNjYWxlLnZhbHVlICsgJyknXG4gICAgICAgICAgdGFyZ2V0ICArPSAnIHNjYWxlKDEpJ1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbCArPSAnOyBvcGFjaXR5OiAnICsgZWxlbS5jb25maWcub3BhY2l0eSArICc7ICdcbiAgICAgICAgdGFyZ2V0ICArPSAnOyBvcGFjaXR5OiAxOyAnO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsID0gJ3RyYW5zZm9ybTonXG4gICAgICB0YXJnZXQgID0gJ3RyYW5zZm9ybTonXG5cbiAgICAgIGJ1aWxkKClcblxuICAgICAgLyoqXG4gICAgICAgKiBCdWlsZCBhZ2FpbiBmb3Igd2Via2l0LlxuICAgICAgICovXG4gICAgICBpbml0aWFsICs9ICctd2Via2l0LXRyYW5zZm9ybTonXG4gICAgICB0YXJnZXQgICs9ICctd2Via2l0LXRyYW5zZm9ybTonXG5cbiAgICAgIGJ1aWxkKClcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgICBpbml0aWFsOiAgICBpbml0aWFsLFxuICAgICAgICB0YXJnZXQ6ICAgICB0YXJnZXQsXG4gICAgICAgIHJlc2V0OiAgICAgIHJlc2V0LFxuICAgICAgICBpbmxpbmU6ICAgICBpbmxpbmUsXG4gICAgICAgIGR1cmF0aW9uOiAgICggKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5vdmVyICkgKyBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy53YWl0ICkgKSAqIDEwMDAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCB3b3JkcyApIHtcblxuICAgICAgdmFyIGZpbHRlcmVkICA9IFtdXG5cbiAgICAgIHZhciBzdWdhciA9IFtcblxuICAgICAgICAnZnJvbScsXG4gICAgICAgICd0aGUnLFxuICAgICAgICAnYW5kJyxcbiAgICAgICAgJ3RoZW4nLFxuICAgICAgICAnYnV0JyxcbiAgICAgICAgJ3dpdGgnLFxuICAgICAgICAncGxlYXNlJyxcbiAgICAgIF1cblxuICAgICAgd29yZHMuZm9yRWFjaChmdW5jdGlvbiggd29yZCApIHtcblxuICAgICAgICBpZiAoIHN1Z2FyLmluZGV4T2YoIHdvcmQgKSA+IC0xICkgcmV0dXJuXG5cbiAgICAgICAgZmlsdGVyZWQucHVzaCggd29yZCApXG4gICAgICAgIHJldHVyblxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGZpbHRlcmVkXG4gICAgfSxcblxuICAgIGdldFZpZXdwb3J0SDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBjbGllbnQgPSBzZWxmLmNvbmZpZy52aWV3cG9ydFsgJ2NsaWVudEhlaWdodCcgXVxuICAgICAgICAsIGlubmVyICA9IHdpbmRvd1sgJ2lubmVySGVpZ2h0JyBdXG5cbiAgICAgIGlmICggc2VsZi5jb25maWcudmlld3BvcnQgPT0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcblxuICAgICAgICByZXR1cm4gKCBjbGllbnQgPCBpbm5lciApID8gaW5uZXIgOiBjbGllbnRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsaWVudFxuICAgIH0sXG5cbiAgICBzY3JvbGxZOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCBzZWxmLmNvbmZpZy52aWV3cG9ydCA9PSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuXG4gICAgICByZXR1cm4gc2VsZi5jb25maWcudmlld3BvcnQuc2Nyb2xsVG9wICsgc2VsZi5jb25maWcudmlld3BvcnQub2Zmc2V0VG9wXG4gICAgfSxcblxuICAgIGdldE9mZnNldDogZnVuY3Rpb24oIGVsICkge1xuXG4gICAgICB2YXIgb2Zmc2V0VG9wICA9IDBcbiAgICAgICAgLCBvZmZzZXRMZWZ0ID0gMFxuXG4gICAgICBkbyB7XG5cbiAgICAgICAgaWYgKCAhaXNOYU4oIGVsLm9mZnNldFRvcCAgKSkgb2Zmc2V0VG9wICArPSBlbC5vZmZzZXRUb3BcbiAgICAgICAgaWYgKCAhaXNOYU4oIGVsLm9mZnNldExlZnQgKSkgb2Zmc2V0TGVmdCArPSBlbC5vZmZzZXRMZWZ0XG5cbiAgICAgIH0gd2hpbGUgKCBlbCA9IGVsLm9mZnNldFBhcmVudCApXG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNFbGVtSW5WaWV3cG9ydDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgIHZhciBlbEhlaWdodCA9IGVsZW0uZG9tRWwub2Zmc2V0SGVpZ2h0XG4gICAgICAgICwgZWxUb3AgICAgPSBzZWxmLmdldE9mZnNldCggZWxlbS5kb21FbCApLnRvcFxuICAgICAgICAsIGVsQm90dG9tID0gZWxUb3AgKyBlbEhlaWdodFxuICAgICAgICAsIHZGYWN0b3IgID0gZWxlbS5jb25maWcudkZhY3RvciB8fCAwXG5cbiAgICAgIHJldHVybiAoIGVsVG9wICsgZWxIZWlnaHQgKiB2RmFjdG9yIDwgc2VsZi5zY3JvbGxlZCArIHNlbGYuZ2V0Vmlld3BvcnRIKCkgKVxuICAgICAgICAgICYmICggZWxCb3R0b20gLSBlbEhlaWdodCAqIHZGYWN0b3IgPiBzZWxmLnNjcm9sbGVkIClcbiAgICAgICAgICB8fCAoIGVsZW0uZG9tRWwuY3VycmVudFN0eWxlID8gZWxlbS5kb21FbC5jdXJyZW50U3R5bGUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbS5kb21FbCwgbnVsbCApICkucG9zaXRpb24gPT0gJ2ZpeGVkJ1xuICAgIH0sXG5cbiAgICBpc01vYmlsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmFcblxuICAgICAgcmV0dXJuICgvKGlwYWR8cGxheWJvb2t8c2lsa3xhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIChjZXxwaG9uZSl8eGRhfHhpaW5vL2kudGVzdCggYWdlbnQgKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCggYWdlbnQuc3Vic3RyKCAwLCA0ICkpKSA/IHRydWUgOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBzZW5zb3IgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc2Vuc29yJyApXG4gICAgICAgICwgY3NzUHJlZml4ID0gJ1dlYmtpdCxNb3osTywnLnNwbGl0KCAnLCcgKVxuICAgICAgICAsIHRlc3RzICAgICA9ICggJ3RyYW5zaXRpb24gJyArIGNzc1ByZWZpeC5qb2luKCAndHJhbnNpdGlvbiwnICkgKS5zcGxpdCggJywnIClcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgaWYgKCAhc2Vuc29yLnN0eWxlW3Rlc3RzW2ldXSA9PT0gJycgKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBxdWVyeVxuXG4gICAgICBxdWVyeSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBzZWxmLmNvbmZpZy52aWV3cG9ydC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtc3JdJyApIClcbiAgICAgIHF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKCBlbCApIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS1zcicgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgfVxuXG4gIGhhbmRsZXIgPSBmdW5jdGlvbiggZSApIHtcblxuICAgIGlmICggIXNlbGYuYmxvY2tlZCApIHtcblxuICAgICAgc2VsZi5ibG9ja2VkICA9IHRydWVcbiAgICAgIHNlbGYuc2Nyb2xsZWQgPSBzZWxmLnNjcm9sbFkoKVxuXG4gICAgICBfcmVxdWVzdEFuaW1GcmFtZSggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgc2VsZi5hbmltYXRlKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCwgc3JjICkge1xuXG4gICAgZm9yICggdmFyIHByb3AgaW4gc3JjICkge1xuXG4gICAgICBpZiAoIHNyYy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXG4gICAgICAgIHRhcmdldFsgcHJvcCBdID0gc3JjWyBwcm9wIF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsLlxuICAgKi9cbiAgX3JlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICAgfHxcbiAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSAgfHxcbiAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcblxuICAgICAgICAgIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGNhbGxiYWNrLCAxMDAwIC8gNjAgKVxuICAgICAgICAgIH1cbiAgfSgpKVxuXG4gIHJldHVybiBzY3JvbGxSZXZlYWxcblxufSkoIHdpbmRvdyApXG5cbnJldHVybiBzY3JvbGxSZXZlYWw7XG5cbn0pKTtcbiJdfQ==
