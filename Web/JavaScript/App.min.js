(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * App.min.js
 * @description Require the main application modules.
 */

var DomParser = require('./Utilities/DomParser/Parser.js'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex(),
    componentParser;

// Register the base modules.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentParser.
componentParser = new DomParser({
    constructors: componentStore.getIndex(),
    selector: 'component', // Equals [data-component="*"]
    defaultCallback: function(instance, el, dataset) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        // Initialize the module.
        instance.initialize.call(instance, el, dataset);

        return instance;
    }
}).parse();
},{"./Components/ClassToggler/View.js":2,"./Components/ScrollTo/View.js":3,"./Utilities/ComponentIndex/Util.js":4,"./Utilities/DomParser/Parser.js":6}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ClassToggler}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":5}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ScrollTo}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":7,"componentPrototype":5}],4:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        console.info('Component ' + key + ' was already registered in this index.', this);
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],5:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll WeiÃŸ
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function() {
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":7}],6:[function(require,module,exports){
/**
 * Parse the DOM for the given selector. If the value matches an item in the given index, create instances of it.
 *
 * @module Modules/DomParser
 */

var DomParser;

/**
 * DomParser
 * @param args {Object} The options object which will configure the parser.
 * @constructor
 */
DomParser = function(args) {
	'use strict';

	this.defaultCallback = args.defaultCallback;
	this.selector = args.selector;
	this.index = args.constructors;

    return this;
};


/**
 * parse
 * @description Parse trough the DOM.
 * @memberof module:Modules/DomParser
 * @param args {Object} Several options which can be passed individually on each parse.
 * @returns {DomParser}
 */
DomParser.prototype.parse = function(args) {
	'use strict';

    args = args || {};

	var callback = args.callback || this.defaultCallback,
		elements = (args.context || window.document).querySelectorAll('[data-' + this.selector + ']'),
		i;

	if(!elements.length) {
		return this;
	}

	for (i in elements) {
		if(i === 'length' || i === 'item') {
			continue;
		}

        var el = elements[i],
            val = el.dataset[this.selector],
            Module = this.index[val];

        // Check if the attr's value is in the index.
        if (!Module) {
            console.info('Component "' + val + '" is not present in the index.');
        } else {
            this.createInstance(Module, el, callback);
        }
	}

	return this;
};


/**
 *
 * @param Constructor
 * @param el {HTMLElement} The element on which the component will mount upon.
 * @param cb {Function} The callback to execute after the instance was created.
 * @returns {DomParser}
 */
DomParser.prototype.createInstance = function(Constructor, el, cb) {
	'use strict';

	// Create the instance of the Module.
	var instance = new Constructor(el, el.dataset);

	if(cb) {
		cb.call(this, instance, el, el.dataset);
	}

	return this;
};


// Return the Constructor.
module.exports = DomParser;
},{}],7:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },
    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    }
};

module.exports = helpers;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRG9tUGFyc2VyL1BhcnNlci5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBBcHAubWluLmpzXG4gKiBAZGVzY3JpcHRpb24gUmVxdWlyZSB0aGUgbWFpbiBhcHBsaWNhdGlvbiBtb2R1bGVzLlxuICovXG5cbnZhciBEb21QYXJzZXIgPSByZXF1aXJlKCcuL1V0aWxpdGllcy9Eb21QYXJzZXIvUGFyc2VyLmpzJyksXG4gICAgQ29tcG9uZW50SW5kZXggPSByZXF1aXJlKCcuL1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzJyksXG4gICAgY29tcG9uZW50U3RvcmUgPSBuZXcgQ29tcG9uZW50SW5kZXgoKSxcbiAgICBjb21wb25lbnRQYXJzZXI7XG5cbi8vIFJlZ2lzdGVyIHRoZSBiYXNlIG1vZHVsZXMuXG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcignY2xhc3NUb2dnbGVyJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL0NsYXNzVG9nZ2xlci9WaWV3LmpzJykpO1xuY29tcG9uZW50U3RvcmUucmVnaXN0ZXIoJ3Njcm9sbFRvJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL1Njcm9sbFRvL1ZpZXcuanMnKSk7XG5cbi8vIFNldHMgdXAgdGhlIGNvbXBvbmVudFBhcnNlci5cbmNvbXBvbmVudFBhcnNlciA9IG5ldyBEb21QYXJzZXIoe1xuICAgIGNvbnN0cnVjdG9yczogY29tcG9uZW50U3RvcmUuZ2V0SW5kZXgoKSxcbiAgICBzZWxlY3RvcjogJ2NvbXBvbmVudCcsIC8vIEVxdWFscyBbZGF0YS1jb21wb25lbnQ9XCIqXCJdXG4gICAgZGVmYXVsdENhbGxiYWNrOiBmdW5jdGlvbihpbnN0YW5jZSwgZWwsIGRhdGFzZXQpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGlmKCFpbnN0YW5jZS5pbml0aWFsaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBtb2R1bGUuXG4gICAgICAgIGluc3RhbmNlLmluaXRpYWxpemUuY2FsbChpbnN0YW5jZSwgZWwsIGRhdGFzZXQpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59KS5wYXJzZSgpOyIsInZhciBjb21wb25lbnRQcm90b3R5cGUgPSByZXF1aXJlKCdjb21wb25lbnRQcm90b3R5cGUnKSxcbiAgICBDbGFzc1RvZ2dsZXI7XG5cbi8qKlxuICogQ2xhc3NUb2dnbGVyXG4gKiBAZGVzY3JpcHRpb24gVG9nZ2xlcyBhIGNsYXNzIG9uIGEgdGFyZ2V0IGVsZW1lbnQgb24gY2xpY2suXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuQ2xhc3NUb2dnbGVyID0gY29tcG9uZW50UHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9IFRoZSBFbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciB3aWxsIGJlIG1vdW50ZWQuXG4gICAgICogQHBhcmFtIGRhdGFzZXQge09iamVjdH0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0Zm9yIHRoZSBDb21wb25lbnQuXG4gICAgICogQHJldHVybnMge0NsYXNzVG9nZ2xlcn1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQpO1xuICAgICAgICB0aGlzLnNldCgnY2xhc3MnLCBkYXRhc2V0LmNsYXNzIHx8ICdhY3RpdmUnKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdGhpcy50b2dnbGVDbGFzcygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGVDbGFzc1xuICAgICAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIHRoZSBjbGFzcyBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0NsYXNzVG9nZ2xlcn1cbiAgICAgKi9cbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB0aGlzLmVsLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLnRhcmdldFswXS5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuZ2V0KCdjbGFzcycpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGFzc1RvZ2dsZXI7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIGVhc2VJbk91dFF1YWQgPSByZXF1aXJlKCcuLy4uLy4uL1V0aWxpdGllcy9IZWxwZXJzJykuZWFzZUluT3V0UXVhZCxcbiAgICBTY3JvbGxUbztcblxuLyoqXG4gKiBTY3JvbGxUb1xuICogQGRlc2NyaXB0aW9uIFNjcm9sbHMgdG8gYSBjZXJ0YWluIHRhcmdldCBlbGVtZW50IG9uIHRoZSBlbGVtZW50cyBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5TY3JvbGxUbyA9IGNvbXBvbmVudFByb3RvdHlwZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgRWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSBtb3VudGVkLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQpWzBdO1xuICAgICAgICB0aGlzLnNldCgnZHVyYXRpb24nLCBkYXRhc2V0LmR1cmF0aW9uIHx8IDYwMCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9UYXJnZXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xsVG9UYXJnZXRcbiAgICAgKiBAZGVzY3JpcHRpb24gU2Nyb2xscyB0byB0aGUgdGFyZ2V0LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBzY3JvbGxUb1RhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB0byA9IHRoaXMudGFyZ2V0Lm9mZnNldFRvcCxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoJ2R1cmF0aW9uJyksXG4gICAgICAgICAgICBzdGFydCA9IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgY2hhbmdlID0gdG8gLSBzdGFydCxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gMCxcbiAgICAgICAgICAgIGluY3JlbWVudCA9IDIwO1xuXG4gICAgICAgIHZhciBhbmltYXRlU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIHZhciB2YWwgPSBlYXNlSW5PdXRRdWFkKGN1cnJlbnRUaW1lLCBzdGFydCwgY2hhbmdlLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFuaW1hdGVTY3JvbGwsIGluY3JlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGVTY3JvbGwoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxUbzsiLCJ2YXIgQ29tcG9uZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmluZGV4ID0ge307XG59O1xuQ29tcG9uZW50SW5kZXgucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5LCBDb25zdHJ1Y3Rvcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmKCFrZXkgfHwgIUNvbnN0cnVjdG9yIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBDb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZih0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCdDb21wb25lbnQgJyArIGtleSArICcgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBpbiB0aGlzIGluZGV4LicsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcbkNvbXBvbmVudEluZGV4LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmluZGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50SW5kZXg7IiwiLyoqXG4gKiBNb2R1bGVQcm90b3R5cGVcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc2V0IG9mIGhhbmR5IGZ1bmN0aW9ucyBhbmQgcmVmZXJlbmNlIHRoZW0gdG8gYSB0YXJnZXQgZS5nLjpcbiAqIEBhdXRob3IgVHlsbCBXZWnDn1xuICovXG5cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vSGVscGVycy5qcycpLmV4dGVuZDtcblxudmFyIFByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXRpYWxpemVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEEgZHVtbXkgaW5pdGlhbGl6ZSBmdW5jdGlvbiB3aGljaCBzZXQncyBnaXZlbiBhdHRyaWJ1dGVzIG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHtvYmplY3QgfHwgc3RyaW5nfSBUaGUgYXR0cmlidXRlKHMpIHRvIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBJZiBhdHRyaWJ1dGVzIHdoZXJlIHBhc3NlZCwgc2V0IHRoZW0gb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgaWYoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYSBrZXkgJiB2YWwgcGFpciBvbiB0aGUgbW9kdWxlIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gdmFsIHtzdHJpbmd9IFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmosIGlmIHRydWUgLSBzZXQgZWFjaCBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uKG9iaktleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W29iaktleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgc2V0IHRoZSBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bnNldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5zZXQvRGVsZXRlIGEga2V5IGZyb20gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB1bnNldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgdmFsdWUgb2YgYW4ga2V5IGluIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byBsb29rIGZvciBpbiB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBib29sIHdoaWNoIGluZGljYXRlcyBpZiBhbiBhdHRyaWJ1dGUgd2FzIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0ciB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgaW5pdGlhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIG1vZHVsZSwgaW52b2tlcyBhIG5ldyBtb2R1bGUgQ29uc3RydWN0b3IgYW5kIGV4dGVuZHMgdGhlIHByb3RvdHlwZSB3aXRoIGFsbCBmdW5jdGlvbnMgZm91bmQgaW4gdGhpcyBvYmplY3QuXG4gICAgICAgICAqIEBleGFtcGxlIFByb3RvdHlwZS5leHRlbmQoe29iamVjdH0pO1xuICAgICAgICAgKiBAcGFyYW0gcHJvdG90eXBlUHJvcHMge29iamVjdH0gQSBzZXQgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjcmVhdGVkIENvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgICBvYmogPSBvYmogPyBvYmogOiB7fTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGZ1bmN0aW9uIHdyYXBwZXIuXG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdpdGggdGhlIGJhc2UgZnVuY3Rpb25zLCBhcyB3ZWxsIGFzIHRoZSBwcm90b1Byb3BzXG4gICAgICAgICAgICBleHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB0aGlzLCBvYmopO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHRhcmdldCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWl4aW5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIE1peCBhIHNldCBvZiBmdW5jdGlvbnMgaW50byB0aGUgY3VycmVudCBwcm90b3R5cGUuXG4gICAgICAgICAqIEBleGFtcGxlIHRoaXMubWl4aW4oeyBnZXRGb3VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDIrMjsgfSB9KTtcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB7T2JqZWN0fSBUaGUgcHJvdG90eXBlLCB0byBtaXggdGhlIE9iaiBpbnRvLlxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtvYmplY3R9IEEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgb24gdGhlIGN1cnJlbnQgcHJvdG90eXBlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IGZ1bmN0aW9uKHRhcmdldCwgb2JqKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iaiA9IG9iaiA/IG9iaiA6IHt9O1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIGlmKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSB0YXJnZXQgZnVuY3Rpb24gd2l0aCB0aGUgYmFzZSBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIHByb3RvUHJvcHNcbiAgICAgICAgICAgIGV4dGVuZCh0YXJnZXQsIG9iaik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b3R5cGU7IiwiLyoqXG4gKiBQYXJzZSB0aGUgRE9NIGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIElmIHRoZSB2YWx1ZSBtYXRjaGVzIGFuIGl0ZW0gaW4gdGhlIGdpdmVuIGluZGV4LCBjcmVhdGUgaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIEBtb2R1bGUgTW9kdWxlcy9Eb21QYXJzZXJcbiAqL1xuXG52YXIgRG9tUGFyc2VyO1xuXG4vKipcbiAqIERvbVBhcnNlclxuICogQHBhcmFtIGFyZ3Mge09iamVjdH0gVGhlIG9wdGlvbnMgb2JqZWN0IHdoaWNoIHdpbGwgY29uZmlndXJlIHRoZSBwYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuRG9tUGFyc2VyID0gZnVuY3Rpb24oYXJncykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dGhpcy5kZWZhdWx0Q2FsbGJhY2sgPSBhcmdzLmRlZmF1bHRDYWxsYmFjaztcblx0dGhpcy5zZWxlY3RvciA9IGFyZ3Muc2VsZWN0b3I7XG5cdHRoaXMuaW5kZXggPSBhcmdzLmNvbnN0cnVjdG9ycztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIHBhcnNlXG4gKiBAZGVzY3JpcHRpb24gUGFyc2UgdHJvdWdoIHRoZSBET00uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOk1vZHVsZXMvRG9tUGFyc2VyXG4gKiBAcGFyYW0gYXJncyB7T2JqZWN0fSBTZXZlcmFsIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbmRpdmlkdWFsbHkgb24gZWFjaCBwYXJzZS5cbiAqIEByZXR1cm5zIHtEb21QYXJzZXJ9XG4gKi9cbkRvbVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG5cdHZhciBjYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgdGhpcy5kZWZhdWx0Q2FsbGJhY2ssXG5cdFx0ZWxlbWVudHMgPSAoYXJncy5jb250ZXh0IHx8IHdpbmRvdy5kb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtJyArIHRoaXMuc2VsZWN0b3IgKyAnXScpLFxuXHRcdGk7XG5cblx0aWYoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Zm9yIChpIGluIGVsZW1lbnRzKSB7XG5cdFx0aWYoaSA9PT0gJ2xlbmd0aCcgfHwgaSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cbiAgICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV0sXG4gICAgICAgICAgICB2YWwgPSBlbC5kYXRhc2V0W3RoaXMuc2VsZWN0b3JdLFxuICAgICAgICAgICAgTW9kdWxlID0gdGhpcy5pbmRleFt2YWxdO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhdHRyJ3MgdmFsdWUgaXMgaW4gdGhlIGluZGV4LlxuICAgICAgICBpZiAoIU1vZHVsZSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdDb21wb25lbnQgXCInICsgdmFsICsgJ1wiIGlzIG5vdCBwcmVzZW50IGluIHRoZSBpbmRleC4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlSW5zdGFuY2UoTW9kdWxlLCBlbCwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIENvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgY29tcG9uZW50IHdpbGwgbW91bnQgdXBvbi5cbiAqIEBwYXJhbSBjYiB7RnVuY3Rpb259IFRoZSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBpbnN0YW5jZSB3YXMgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtEb21QYXJzZXJ9XG4gKi9cbkRvbVBhcnNlci5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbihDb25zdHJ1Y3RvciwgZWwsIGNiKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHQvLyBDcmVhdGUgdGhlIGluc3RhbmNlIG9mIHRoZSBNb2R1bGUuXG5cdHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcihlbCwgZWwuZGF0YXNldCk7XG5cblx0aWYoY2IpIHtcblx0XHRjYi5jYWxsKHRoaXMsIGluc3RhbmNlLCBlbCwgZWwuZGF0YXNldCk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuLy8gUmV0dXJuIHRoZSBDb25zdHJ1Y3Rvci5cbm1vZHVsZS5leHBvcnRzID0gRG9tUGFyc2VyOyIsInZhciBoZWxwZXJzID0ge1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgICAgICBpID0gMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuICAgICAgICAgICAgZGVlcCA9IHRhcmdldDtcblxuICAgICAgICAgICAgLy8gU2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbih0YXJnZXQpICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICAgICAgaWYgKCBpID09PSBsZW5ndGggKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gdGFyZ2V0WyBuYW1lIF07XG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gY29weSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0galF1ZXJ5LmlzQXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuICAgIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBjaGFuZ2VkVmFsdWUsIGR1cmF0aW9uKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBjdXJyZW50VGltZSAvPSBkdXJhdGlvbiAvIDI7XG4gICAgICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkVmFsdWUgLyAyICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50VGltZS0tO1xuXG4gICAgICAgIHJldHVybiAtY2hhbmdlZFZhbHVlIC8gMiAqIChjdXJyZW50VGltZSAqIChjdXJyZW50VGltZSAtIDIpIC0gMSkgKyBzdGFydFZhbHVlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGVscGVyczsiXX0=
