(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * App.min.js
 * @description Require the main application modules.
 */

var DomParser = require('./Utilities/DomParser/Parser.js'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex(),
    componentParser;

// Register the base modules.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('parallaxStage', require('./Components/ParallaxStage/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentParser.
componentParser = new DomParser({
    constructors: componentStore.getIndex(),
    selector: 'component', // Equals [data-component="*"]
    defaultCallback: function(instance, el, dataset) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        // Initialize the module.
        instance.initialize.call(instance, el, dataset);

        return instance;
    }
}).parse();
},{"./Components/ClassToggler/View.js":2,"./Components/ParallaxStage/View.js":3,"./Components/ScrollTo/View.js":4,"./Utilities/ComponentIndex/Util.js":5,"./Utilities/DomParser/Parser.js":7}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ClassToggler}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":6}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    setTransform = require('./../../Utilities/Helpers').setTransform,
    ParallaxStage;

/**
 * ParallaxStage
 * @description Creates a subtle parallax scrolling effect on some child elements.
 * @constructor
 */
ParallaxStage = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the parallax values will be based on.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ParallaxStage}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.targets = document.querySelectorAll(dataset.target || '[data-parallax]');
        this.set('lastScrollTop', 0);

        // Setup the rAF.
        var self = this,
            _animFrame;

        (function animloop(){
            self.render();
            _animFrame = window.requestAnimationFrame(animloop);
        }());

        return this;
    },

    render: function() {
        'use strict';

        var currentScrollTop = document.body.scrollTop,
            lastScrollTop = this.get('lastScrollTop');

        if(currentScrollTop === lastScrollTop) {
            return this;
        }

        this.set('lastScrollTop', currentScrollTop);
        this.adjustPositions(currentScrollTop);

        return this;
    },
    adjustPositions: function(scrollTop) {
        'use strict';

        var stageOffset = this.el.offsetTop,
            scrollPos = scrollTop - stageOffset;

        this.setElementsTransformValue(this.targets[0], scrollPos);
        this.setElementsTransformValue(this.targets[1], scrollPos);

        return this;
    },
    setElementsTransformValue: function(element, scrollPos) {
        'use strict';

        var val = Math.round(scrollPos / (Math.abs(element.dataset.parallaxfactor) || 1));

        setTransform(element, 'translateY(' + val + 'px)');

        return this;
    }
});

module.exports = ParallaxStage;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],4:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @param el {HTMLElement} The Element on which the event listener will be mounted.
     * @param dataset {Object} The configuration objectfor the Component.
     * @returns {ScrollTo}
     */
    initialize: function(el, dataset) {
        'use strict';

        this.el = el;
        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":8,"componentPrototype":6}],5:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        ;
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],6:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll WeiÃŸ
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function() {
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":8}],7:[function(require,module,exports){
/**
 * Parse the DOM for the given selector. If the value matches an item in the given index, create instances of it.
 *
 * @module Modules/DomParser
 */

var DomParser;

/**
 * DomParser
 * @param args {Object} The options object which will configure the parser.
 * @constructor
 */
DomParser = function(args) {
	'use strict';

	this.defaultCallback = args.defaultCallback;
	this.selector = args.selector;
	this.index = args.constructors;

    return this;
};


/**
 * parse
 * @description Parse trough the DOM.
 * @memberof module:Modules/DomParser
 * @param args {Object} Several options which can be passed individually on each parse.
 * @returns {DomParser}
 */
DomParser.prototype.parse = function(args) {
	'use strict';

    args = args || {};

	var callback = args.callback || this.defaultCallback,
		elements = (args.context || window.document).querySelectorAll('[data-' + this.selector + ']'),
		i;

	if(!elements.length) {
		return this;
	}

	for (i in elements) {
		if(i === 'length' || i === 'item') {
			continue;
		}

        var el = elements[i],
            val = el.dataset[this.selector],
            Module = this.index[val];

        // Check if the attr's value is in the index.
        if (!Module) {
            ;
        } else {
            this.createInstance(Module, el, callback);
        }
	}

	return this;
};


/**
 *
 * @param Constructor
 * @param el {HTMLElement} The element on which the component will mount upon.
 * @param cb {Function} The callback to execute after the instance was created.
 * @returns {DomParser}
 */
DomParser.prototype.createInstance = function(Constructor, el, cb) {
	'use strict';

	// Create the instance of the Module.
	var instance = new Constructor(el, el.dataset);

	if(cb) {
		cb.call(this, instance, el, el.dataset);
	}

	return this;
};


// Return the Constructor.
module.exports = DomParser;
},{}],8:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },
    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    },
    setTransform: function(element, prop) {
        'use strict';

        element.style.webkitTransform = prop;
        element.style.MozTransform = prop;
        element.style.msTransform = prop;
        element.style.OTransform = prop;
        element.style.transform = prop;
    }
};

module.exports = helpers;
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRG9tUGFyc2VyL1BhcnNlci5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAqIEFwcC5taW4uanNcbiAqIEBkZXNjcmlwdGlvbiBSZXF1aXJlIHRoZSBtYWluIGFwcGxpY2F0aW9uIG1vZHVsZXMuXG4gKi9cblxudmFyIERvbVBhcnNlciA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0RvbVBhcnNlci9QYXJzZXIuanMnKSxcbiAgICBDb21wb25lbnRJbmRleCA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0NvbXBvbmVudEluZGV4L1V0aWwuanMnKSxcbiAgICBjb21wb25lbnRTdG9yZSA9IG5ldyBDb21wb25lbnRJbmRleCgpLFxuICAgIGNvbXBvbmVudFBhcnNlcjtcblxuLy8gUmVnaXN0ZXIgdGhlIGJhc2UgbW9kdWxlcy5cbmNvbXBvbmVudFN0b3JlLnJlZ2lzdGVyKCdjbGFzc1RvZ2dsZXInLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcigncGFyYWxsYXhTdGFnZScsIHJlcXVpcmUoJy4vQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMnKSk7XG5jb21wb25lbnRTdG9yZS5yZWdpc3Rlcignc2Nyb2xsVG8nLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvU2Nyb2xsVG8vVmlldy5qcycpKTtcblxuLy8gU2V0cyB1cCB0aGUgY29tcG9uZW50UGFyc2VyLlxuY29tcG9uZW50UGFyc2VyID0gbmV3IERvbVBhcnNlcih7XG4gICAgY29uc3RydWN0b3JzOiBjb21wb25lbnRTdG9yZS5nZXRJbmRleCgpLFxuICAgIHNlbGVjdG9yOiAnY29tcG9uZW50JywgLy8gRXF1YWxzIFtkYXRhLWNvbXBvbmVudD1cIipcIl1cbiAgICBkZWZhdWx0Q2FsbGJhY2s6IGZ1bmN0aW9uKGluc3RhbmNlLCBlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYoIWluc3RhbmNlLmluaXRpYWxpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIG1vZHVsZS5cbiAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZS5jYWxsKGluc3RhbmNlLCBlbCwgZGF0YXNldCk7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbn0pLnBhcnNlKCk7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIENsYXNzVG9nZ2xlcjtcblxuLyoqXG4gKiBDbGFzc1RvZ2dsZXJcbiAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIGEgY2xhc3Mgb24gYSB0YXJnZXQgZWxlbWVudCBvbiBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5DbGFzc1RvZ2dsZXIgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIGVsIHtIVE1MRWxlbWVudH0gVGhlIEVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgbW91bnRlZC5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGVsLCBkYXRhc2V0KSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhc2V0LnRhcmdldCk7XG4gICAgICAgIHRoaXMuc2V0KCdjbGFzcycsIGRhdGFzZXQuY2xhc3MgfHwgJ2FjdGl2ZScpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZUNsYXNzXG4gICAgICogQGRlc2NyaXB0aW9uIFRvZ2dsZXMgdGhlIGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudGFyZ2V0WzBdLmNsYXNzTGlzdC50b2dnbGUodGhpcy5nZXQoJ2NsYXNzJykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzVG9nZ2xlcjsiLCJ2YXIgY29tcG9uZW50UHJvdG90eXBlID0gcmVxdWlyZSgnY29tcG9uZW50UHJvdG90eXBlJyksXG4gICAgc2V0VHJhbnNmb3JtID0gcmVxdWlyZSgnLi8uLi8uLi9VdGlsaXRpZXMvSGVscGVycycpLnNldFRyYW5zZm9ybSxcbiAgICBQYXJhbGxheFN0YWdlO1xuXG4vKipcbiAqIFBhcmFsbGF4U3RhZ2VcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc3VidGxlIHBhcmFsbGF4IHNjcm9sbGluZyBlZmZlY3Qgb24gc29tZSBjaGlsZCBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5QYXJhbGxheFN0YWdlID0gY29tcG9uZW50UHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9IFRoZSBFbGVtZW50IG9uIHdoaWNoIHRoZSBwYXJhbGxheCB2YWx1ZXMgd2lsbCBiZSBiYXNlZCBvbi5cbiAgICAgKiBAcGFyYW0gZGF0YXNldCB7T2JqZWN0fSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3Rmb3IgdGhlIENvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJucyB7UGFyYWxsYXhTdGFnZX1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGRhdGFzZXQudGFyZ2V0IHx8ICdbZGF0YS1wYXJhbGxheF0nKTtcbiAgICAgICAgdGhpcy5zZXQoJ2xhc3RTY3JvbGxUb3AnLCAwKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgckFGLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBfYW5pbUZyYW1lO1xuXG4gICAgICAgIChmdW5jdGlvbiBhbmltbG9vcCgpe1xuICAgICAgICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICAgICAgICAgIF9hbmltRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1sb29wKTtcbiAgICAgICAgfSgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBjdXJyZW50U2Nyb2xsVG9wID0gZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBsYXN0U2Nyb2xsVG9wID0gdGhpcy5nZXQoJ2xhc3RTY3JvbGxUb3AnKTtcblxuICAgICAgICBpZihjdXJyZW50U2Nyb2xsVG9wID09PSBsYXN0U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0KCdsYXN0U2Nyb2xsVG9wJywgY3VycmVudFNjcm9sbFRvcCk7XG4gICAgICAgIHRoaXMuYWRqdXN0UG9zaXRpb25zKGN1cnJlbnRTY3JvbGxUb3ApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRqdXN0UG9zaXRpb25zOiBmdW5jdGlvbihzY3JvbGxUb3ApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBzdGFnZU9mZnNldCA9IHRoaXMuZWwub2Zmc2V0VG9wLFxuICAgICAgICAgICAgc2Nyb2xsUG9zID0gc2Nyb2xsVG9wIC0gc3RhZ2VPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlKHRoaXMudGFyZ2V0c1swXSwgc2Nyb2xsUG9zKTtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlKHRoaXMudGFyZ2V0c1sxXSwgc2Nyb2xsUG9zKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldEVsZW1lbnRzVHJhbnNmb3JtVmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQsIHNjcm9sbFBvcykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIHZhbCA9IE1hdGgucm91bmQoc2Nyb2xsUG9zIC8gKE1hdGguYWJzKGVsZW1lbnQuZGF0YXNldC5wYXJhbGxheGZhY3RvcikgfHwgMSkpO1xuXG4gICAgICAgIHNldFRyYW5zZm9ybShlbGVtZW50LCAndHJhbnNsYXRlWSgnICsgdmFsICsgJ3B4KScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFsbGF4U3RhZ2U7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIGVhc2VJbk91dFF1YWQgPSByZXF1aXJlKCcuLy4uLy4uL1V0aWxpdGllcy9IZWxwZXJzJykuZWFzZUluT3V0UXVhZCxcbiAgICBTY3JvbGxUbztcblxuLyoqXG4gKiBTY3JvbGxUb1xuICogQGRlc2NyaXB0aW9uIFNjcm9sbHMgdG8gYSBjZXJ0YWluIHRhcmdldCBlbGVtZW50IG9uIHRoZSBlbGVtZW50cyBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5TY3JvbGxUbyA9IGNvbXBvbmVudFByb3RvdHlwZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS5cbiAgICAgKiBAcGFyYW0gZWwge0hUTUxFbGVtZW50fSBUaGUgRWxlbWVudCBvbiB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXIgd2lsbCBiZSBtb3VudGVkLlxuICAgICAqIEBwYXJhbSBkYXRhc2V0IHtPYmplY3R9IFRoZSBjb25maWd1cmF0aW9uIG9iamVjdGZvciB0aGUgQ29tcG9uZW50LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihlbCwgZGF0YXNldCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQpWzBdO1xuICAgICAgICB0aGlzLnNldCgnZHVyYXRpb24nLCBkYXRhc2V0LmR1cmF0aW9uIHx8IDYwMCk7XG5cbiAgICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9UYXJnZXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2Nyb2xsVG9UYXJnZXRcbiAgICAgKiBAZGVzY3JpcHRpb24gU2Nyb2xscyB0byB0aGUgdGFyZ2V0LlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBzY3JvbGxUb1RhcmdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB0byA9IHRoaXMudGFyZ2V0Lm9mZnNldFRvcCxcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXQoJ2R1cmF0aW9uJyksXG4gICAgICAgICAgICBzdGFydCA9IGVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgY2hhbmdlID0gdG8gLSBzdGFydCxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gMCxcbiAgICAgICAgICAgIGluY3JlbWVudCA9IDIwO1xuXG4gICAgICAgIHZhciBhbmltYXRlU2Nyb2xsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lICs9IGluY3JlbWVudDtcbiAgICAgICAgICAgIHZhciB2YWwgPSBlYXNlSW5PdXRRdWFkKGN1cnJlbnRUaW1lLCBzdGFydCwgY2hhbmdlLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHZhbDtcbiAgICAgICAgICAgIGlmKGN1cnJlbnRUaW1lIDwgZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFuaW1hdGVTY3JvbGwsIGluY3JlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGVTY3JvbGwoKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JvbGxUbzsiLCJ2YXIgQ29tcG9uZW50SW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB0aGlzLmluZGV4ID0ge307XG59O1xuQ29tcG9uZW50SW5kZXgucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24oa2V5LCBDb25zdHJ1Y3Rvcikge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGlmKCFrZXkgfHwgIUNvbnN0cnVjdG9yIHx8IHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBDb25zdHJ1Y3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZih0aGlzLmluZGV4W2tleV0pIHtcbiAgICAgICAgO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZXhba2V5XSA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcbkNvbXBvbmVudEluZGV4LnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHJldHVybiB0aGlzLmluZGV4O1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50SW5kZXg7IiwiLyoqXG4gKiBNb2R1bGVQcm90b3R5cGVcbiAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc2V0IG9mIGhhbmR5IGZ1bmN0aW9ucyBhbmQgcmVmZXJlbmNlIHRoZW0gdG8gYSB0YXJnZXQgZS5nLjpcbiAqIEBhdXRob3IgVHlsbCBXZWnDn1xuICovXG5cblxudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vLi4vSGVscGVycy5qcycpLmV4dGVuZDtcblxudmFyIFByb3RvdHlwZSA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXRpYWxpemVcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEEgZHVtbXkgaW5pdGlhbGl6ZSBmdW5jdGlvbiB3aGljaCBzZXQncyBnaXZlbiBhdHRyaWJ1dGVzIG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIHtvYmplY3QgfHwgc3RyaW5nfSBUaGUgYXR0cmlidXRlKHMpIHRvIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oYXR0cmlidXRlcykge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBJZiBhdHRyaWJ1dGVzIHdoZXJlIHBhc3NlZCwgc2V0IHRoZW0gb24gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgaWYoYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYSBrZXkgJiB2YWwgcGFpciBvbiB0aGUgbW9kdWxlIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gdmFsIHtzdHJpbmd9IFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgdGFyZ2V0IHRvIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmosIGlmIHRydWUgLSBzZXQgZWFjaCBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uKG9iaktleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W29iaktleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHN0cmluZywgc2V0IHRoZSBrZXkvdmFsIHBhaXIuXG4gICAgICAgICAgICBpZih0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bnNldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gVW5zZXQvRGVsZXRlIGEga2V5IGZyb20gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICB1bnNldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW2tleV07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgdmFsdWUgb2YgYW4ga2V5IGluIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHBhcmFtIGtleSB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byBsb29rIGZvciBpbiB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYXNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBib29sIHdoaWNoIGluZGljYXRlcyBpZiBhbiBhdHRyaWJ1dGUgd2FzIHNldCBvbiB0aGUgbW9kdWxlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0ciB7c3RyaW5nfSBUaGUgdGFyZ2V0IGtleSB0byB0ZXN0LlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXh0ZW5kXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgaW5pdGlhdG9yIGZ1bmN0aW9uIGZvciBlYWNoIG1vZHVsZSwgaW52b2tlcyBhIG5ldyBtb2R1bGUgQ29uc3RydWN0b3IgYW5kIGV4dGVuZHMgdGhlIHByb3RvdHlwZSB3aXRoIGFsbCBmdW5jdGlvbnMgZm91bmQgaW4gdGhpcyBvYmplY3QuXG4gICAgICAgICAqIEBleGFtcGxlIFByb3RvdHlwZS5leHRlbmQoe29iamVjdH0pO1xuICAgICAgICAgKiBAcGFyYW0gcHJvdG90eXBlUHJvcHMge29iamVjdH0gQSBzZXQgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcHJvdG90eXBlIG9mIHRoZSBjcmVhdGVkIENvbnN0cnVjdG9yLlxuICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGVtcHR5IG9iamVjdHMuXG4gICAgICAgICAgICBvYmogPSBvYmogPyBvYmogOiB7fTtcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIGVtcHR5IGZ1bmN0aW9uIHdyYXBwZXIuXG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgdGFyZ2V0IGZ1bmN0aW9uIHdpdGggdGhlIGJhc2UgZnVuY3Rpb25zLCBhcyB3ZWxsIGFzIHRoZSBwcm90b1Byb3BzXG4gICAgICAgICAgICBleHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB0aGlzLCBvYmopO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHRhcmdldCBmdW5jdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWl4aW5cbiAgICAgICAgICogQGRlc2NyaXB0aW9uIE1peCBhIHNldCBvZiBmdW5jdGlvbnMgaW50byB0aGUgY3VycmVudCBwcm90b3R5cGUuXG4gICAgICAgICAqIEBleGFtcGxlIHRoaXMubWl4aW4oeyBnZXRGb3VyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDIrMjsgfSB9KTtcbiAgICAgICAgICogQHBhcmFtIHRhcmdldCB7T2JqZWN0fSBUaGUgcHJvdG90eXBlLCB0byBtaXggdGhlIE9iaiBpbnRvLlxuICAgICAgICAgKiBAcGFyYW0gb2JqIHtvYmplY3R9IEEgc2V0IG9mIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgZXh0ZW5kZWQgb24gdGhlIGN1cnJlbnQgcHJvdG90eXBlLlxuICAgICAgICAgKiBAcmV0dXJucyB7UHJvdG90eXBlfVxuICAgICAgICAgKi9cbiAgICAgICAgbWl4aW46IGZ1bmN0aW9uKHRhcmdldCwgb2JqKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iaiA9IG9iaiA/IG9iaiA6IHt9O1xuXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5wcm90b3R5cGU7XG5cbiAgICAgICAgICAgIGlmKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSB0YXJnZXQgZnVuY3Rpb24gd2l0aCB0aGUgYmFzZSBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIHByb3RvUHJvcHNcbiAgICAgICAgICAgIGV4dGVuZCh0YXJnZXQsIG9iaik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm90b3R5cGU7IiwiLyoqXG4gKiBQYXJzZSB0aGUgRE9NIGZvciB0aGUgZ2l2ZW4gc2VsZWN0b3IuIElmIHRoZSB2YWx1ZSBtYXRjaGVzIGFuIGl0ZW0gaW4gdGhlIGdpdmVuIGluZGV4LCBjcmVhdGUgaW5zdGFuY2VzIG9mIGl0LlxuICpcbiAqIEBtb2R1bGUgTW9kdWxlcy9Eb21QYXJzZXJcbiAqL1xuXG52YXIgRG9tUGFyc2VyO1xuXG4vKipcbiAqIERvbVBhcnNlclxuICogQHBhcmFtIGFyZ3Mge09iamVjdH0gVGhlIG9wdGlvbnMgb2JqZWN0IHdoaWNoIHdpbGwgY29uZmlndXJlIHRoZSBwYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuRG9tUGFyc2VyID0gZnVuY3Rpb24oYXJncykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dGhpcy5kZWZhdWx0Q2FsbGJhY2sgPSBhcmdzLmRlZmF1bHRDYWxsYmFjaztcblx0dGhpcy5zZWxlY3RvciA9IGFyZ3Muc2VsZWN0b3I7XG5cdHRoaXMuaW5kZXggPSBhcmdzLmNvbnN0cnVjdG9ycztcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIHBhcnNlXG4gKiBAZGVzY3JpcHRpb24gUGFyc2UgdHJvdWdoIHRoZSBET00uXG4gKiBAbWVtYmVyb2YgbW9kdWxlOk1vZHVsZXMvRG9tUGFyc2VyXG4gKiBAcGFyYW0gYXJncyB7T2JqZWN0fSBTZXZlcmFsIG9wdGlvbnMgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbmRpdmlkdWFsbHkgb24gZWFjaCBwYXJzZS5cbiAqIEByZXR1cm5zIHtEb21QYXJzZXJ9XG4gKi9cbkRvbVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG5cdHZhciBjYWxsYmFjayA9IGFyZ3MuY2FsbGJhY2sgfHwgdGhpcy5kZWZhdWx0Q2FsbGJhY2ssXG5cdFx0ZWxlbWVudHMgPSAoYXJncy5jb250ZXh0IHx8IHdpbmRvdy5kb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtJyArIHRoaXMuc2VsZWN0b3IgKyAnXScpLFxuXHRcdGk7XG5cblx0aWYoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0Zm9yIChpIGluIGVsZW1lbnRzKSB7XG5cdFx0aWYoaSA9PT0gJ2xlbmd0aCcgfHwgaSA9PT0gJ2l0ZW0nKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cbiAgICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV0sXG4gICAgICAgICAgICB2YWwgPSBlbC5kYXRhc2V0W3RoaXMuc2VsZWN0b3JdLFxuICAgICAgICAgICAgTW9kdWxlID0gdGhpcy5pbmRleFt2YWxdO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBhdHRyJ3MgdmFsdWUgaXMgaW4gdGhlIGluZGV4LlxuICAgICAgICBpZiAoIU1vZHVsZSkge1xuICAgICAgICAgICAgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbnN0YW5jZShNb2R1bGUsIGVsLCBjYWxsYmFjayk7XG4gICAgICAgIH1cblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqXG4gKiBAcGFyYW0gQ29uc3RydWN0b3JcbiAqIEBwYXJhbSBlbCB7SFRNTEVsZW1lbnR9IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBjb21wb25lbnQgd2lsbCBtb3VudCB1cG9uLlxuICogQHBhcmFtIGNiIHtGdW5jdGlvbn0gVGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGluc3RhbmNlIHdhcyBjcmVhdGVkLlxuICogQHJldHVybnMge0RvbVBhcnNlcn1cbiAqL1xuRG9tUGFyc2VyLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBlbCwgY2IpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdC8vIENyZWF0ZSB0aGUgaW5zdGFuY2Ugb2YgdGhlIE1vZHVsZS5cblx0dmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKGVsLCBlbC5kYXRhc2V0KTtcblxuXHRpZihjYikge1xuXHRcdGNiLmNhbGwodGhpcywgaW5zdGFuY2UsIGVsLCBlbC5kYXRhc2V0KTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG4vLyBSZXR1cm4gdGhlIENvbnN0cnVjdG9yLlxubW9kdWxlLmV4cG9ydHMgPSBEb21QYXJzZXI7IiwidmFyIGhlbHBlcnMgPSB7XG4gICAgZXh0ZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgICAvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICAvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWpRdWVyeS5pc0Z1bmN0aW9uKHRhcmdldCkgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgICBpZiAoIGkgPT09IGxlbmd0aCApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIGlmICggKG9wdGlvbnMgPSBhcmd1bWVudHNbIGkgXSkgIT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG4gICAgICAgICAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG4gICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24oY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGNoYW5nZWRWYWx1ZSwgZHVyYXRpb24pIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZWRWYWx1ZSAvIDIgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRUaW1lLS07XG5cbiAgICAgICAgcmV0dXJuIC1jaGFuZ2VkVmFsdWUgLyAyICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XG4gICAgfSxcbiAgICBzZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5Nb3pUcmFuc2Zvcm0gPSBwcm9wO1xuICAgICAgICBlbGVtZW50LnN0eWxlLm1zVHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5PVHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBwcm9wO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGVscGVyczsiXX0=
