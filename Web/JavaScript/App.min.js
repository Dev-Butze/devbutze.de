(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ComponentDomParser = require("componentdomparser"),
    ScrollReveal = require('scrollReveal'),
    ComponentIndex = require('./Utilities/ComponentIndex/Util.js'),
    componentStore = new ComponentIndex(),
    parser, scrollReveal;

// Register the components.
componentStore.register('classToggler', require('./Components/ClassToggler/View.js'));
componentStore.register('parallaxStage', require('./Components/ParallaxStage/View.js'));
componentStore.register('scrollTo', require('./Components/ScrollTo/View.js'));

// Sets up the componentDomParser and parse for all component nodes.
parser = new ComponentDomParser({
    dataSelector: 'component', // Equals [data-component="*"]
    componentIndex: componentStore.getIndex(),
    componentDidMountCallback: function(instance) {
        'use strict';

        if(!instance.initialize) {
            return instance;
        }

        instance.initialize();

        return instance;
    }
}).parse();

scrollReveal = new ScrollReveal();
},{"./Components/ClassToggler/View.js":2,"./Components/ParallaxStage/View.js":3,"./Components/ScrollTo/View.js":4,"./Utilities/ComponentIndex/Util.js":5,"componentdomparser":8,"scrollReveal":9}],2:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    ClassToggler;

/**
 * ClassToggler
 * @description Toggles a class on a target element on click.
 * @constructor
 */
ClassToggler = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @returns {ClassToggler}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.target = document.querySelectorAll(dataset.target);
        this.set('class', dataset.class || 'active');

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.toggleClass();
        }.bind(this));

        return this;
    },

    /**
     * toggleClass
     * @description Toggles the class on the target element.
     * @returns {ClassToggler}
     */
    toggleClass: function() {
        'use strict';

        this.el.classList.toggle('active');
        this.target[0].classList.toggle(this.get('class'));

        return this;
    }
});

module.exports = ClassToggler;
},{"componentPrototype":6}],3:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    forEach = require('./../../Utilities/Helpers').forEach,
    setTransform = require('./../../Utilities/Helpers').setTransform,
    ParallaxStage;

/**
 * ParallaxStage
 * @description Creates a subtle parallax scrolling effect on some child elements.
 * @constructor
 */
ParallaxStage = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @returns {ParallaxStage}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.targets = document.querySelectorAll(dataset.target || '[data-parallax]');
        this.set('lastScrollTop', 0);

        // Setup the rAF.
        var self = this,
            _animFrame;

        (function animloop(){
            self.render();
            _animFrame = window.requestAnimationFrame(animloop);
        }());

        return this;
    },

    /**
     * render
     * @description Renders the state of the component, depending on the last scrolled position.
     * @returns {ParallaxStage}
     */
    render: function() {
        'use strict';

        var currentScrollTop = document.body.scrollTop,
            lastScrollTop = this.get('lastScrollTop');

        if(currentScrollTop === lastScrollTop) {
            return this;
        }

        this.set('lastScrollTop', currentScrollTop);
        this.adjustTargetPositions(currentScrollTop);

        return this;
    },

    /**
     * adjustTargetPositions
     * @description Loops over each target node and calls the transform method to adjust it's position.
     * @param scrollTop {Number} The current scroll position of the document/target node.
     * @returns {ParallaxStage}
     */
    adjustTargetPositions: function(scrollTop) {
        'use strict';

        var stageOffset = this.el.offsetTop,
            scrollPos = scrollTop - stageOffset;

        forEach(this.targets, function(index, item) {
            var elementScrollPos = this.calculateElementsScrollPosition(item, scrollPos);

            this.setElementsTransformValue(item, elementScrollPos);
        }.bind(this));

        return this;
    },

    /**
     * calculateElementsScrollPosition
     * @param element {HTMLElement} The node on which the calculation is based on.
     * @param scrollPos {Number} The scroll position of the instance's node.
     * @returns {number}
     */
    calculateElementsScrollPosition: function(element, scrollPos) {
        'use strict';

        var parallaxFactor = (Math.abs(element.dataset.parallaxfactor) || 1);

        return Math.round(scrollPos / parallaxFactor);
    },

    /**
     * setElementsTransformValue
     * @param element {HTMLElement} The node on which the calculation is based on.
     * @param scrollPos {Number} The scroll position of the instance's node.
     * @returns {ParallaxStage}
     */
    setElementsTransformValue: function(element, scrollPos) {
        'use strict';

        setTransform(element, 'translateY(' + scrollPos + 'px)');

        return this;
    }
});

module.exports = ParallaxStage;
},{"./../../Utilities/Helpers":7,"componentPrototype":6}],4:[function(require,module,exports){
var componentPrototype = require('componentPrototype'),
    easeInOutQuad = require('./../../Utilities/Helpers').easeInOutQuad,
    ScrollTo;

/**
 * ScrollTo
 * @description Scrolls to a certain target element on the elements click.
 * @constructor
 */
ScrollTo = componentPrototype.extend({
    /**
     * initialize
     * @description Initializes the module.
     * @returns {ScrollTo}
     */
    initialize: function() {
        'use strict';

        var dataset = this.el.dataset;

        this.target = document.querySelectorAll(dataset.target)[0];
        this.set('duration', dataset.duration || 600);

        this.el.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();

            this.scrollToTarget();
        }.bind(this));

        return this;
    },

    /**
     * scrollToTarget
     * @description Scrolls to the target.
     * @returns {ScrollTo}
     */
    scrollToTarget: function() {
        'use strict';

        var element = document.body,
            to = this.target.offsetTop,
            duration = this.get('duration'),
            start = element.scrollTop,
            change = to - start,
            currentTime = 0,
            increment = 20;

        var animateScroll = function(){
            currentTime += increment;
            var val = easeInOutQuad(currentTime, start, change, duration);
            element.scrollTop = val;
            if(currentTime < duration) {
                setTimeout(animateScroll, increment);
            }
        };
        animateScroll();

        return this;
    }
});

module.exports = ScrollTo;
},{"./../../Utilities/Helpers":7,"componentPrototype":6}],5:[function(require,module,exports){
var ComponentIndex = function() {
    'use strict';

    this.index = {};
};
ComponentIndex.prototype.register = function(key, Constructor) {
    'use strict';

    if(!key || !Constructor || typeof key !== 'string' || typeof Constructor !== 'function') {
        return this;
    }

    if(this.index[key]) {
        console.info('Component ' + key + ' was already registered in this index.', this);
    } else {
        this.index[key] = Constructor;
    }

    return this;
};
ComponentIndex.prototype.getIndex = function() {
    'use strict';

    return this.index;
};



module.exports = ComponentIndex;
},{}],6:[function(require,module,exports){
/**
 * ModulePrototype
 * @description Creates a set of handy functions and reference them to a target e.g.:
 * @author Tyll Weiß
 */


var extend = require('./../Helpers.js').extend;

var Prototype = {
        /**
         * initialize
         * @description A dummy initialize function which set's given attributes on the module.
         * @param attributes {object || string} The attribute(s) to set on the module.
         * @returns {Prototype}
         */
        initialize: function(attributes) {
            'use strict';

            // If attributes where passed, set them on the constructor.
            if(attributes) {
                this.set(attributes);
            }

            return this;
        },

        /**
         * set
         * @description Set a key & val pair on the module attributes object.
         * @param key {string} The target key.
         * @param val {string} The value to set.
         * @returns {Prototype}
         */
        set: function(key, val) {
            'use strict';

            // Set the target to the attributes obj.
            var target = this.attributes;

            // Check if the first argument is an obj, if true - set each key/val pair.
            if(typeof key === 'object') {
                key.forEach(function(objKey, value) {
                    target[objKey] = value;
                }.bind(this));

                return this;
            }

            // If the first argument is a string, set the key/val pair.
            if(typeof key === 'string') {
                target[key] = val;

                return this;
            }

            return this;
        },

        /**
         * unset
         * @description Unset/Delete a key from the attributes obj.
         * @param key
         * @returns {Prototype}
         */
        unset: function(key) {
            'use strict';
            delete this.attributes[key];

            return this;
        },

        /**
         * get
         * @description Get the value of an key in the attributes obj.
         * @param key {string} The target key to look for in the attributes obj.
         * @returns {*}
         */
        get: function(key) {
            'use strict';

            return this.attributes[key];
        },

        /**
         * has
         * @description Returns a bool which indicates if an attribute was set on the module.
         * @param attr {string} The target key to test.
         * @returns {boolean}
         */
        has: function(attr) {
            'use strict';

            return this.get(attr) != null;
        },

        /**
         * extend
         * @description The initiator function for each module, invokes a new module Constructor and extends the prototype with all functions found in this object.
         * @example Prototype.extend({object});
         * @param prototypeProps {object} A set of functions which will be applied to the prototype of the created Constructor.
         * @returns {Function}
         */
        extend: function(obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            // Create an empty function wrapper.
            var Constructor = function(el) {
                this.el = el;
                this.attributes = {};
            };

            // Extend the target function with the base functions, as well as the protoProps
            extend(Constructor.prototype, this, obj);

            // Return the target function.
            return Constructor;
        },

        /**
         * mixin
         * @description Mix a set of functions into the current prototype.
         * @example this.mixin({ getFour: function() { return 2+2; } });
         * @param target {Object} The prototype, to mix the Obj into.
         * @param obj {object} A set of functions that will be extended on the current prototype.
         * @returns {Prototype}
         */
        mixin: function(target, obj) {
            'use strict';

            // Prevent empty objects.
            obj = obj ? obj : {};

            target = target || this.prototype;

            if(!target) {
                return this;
            }

            // Extend the target function with the base functions, as well as the protoProps
            extend(target, obj);

            return this;
        }
    };

module.exports = Prototype;
},{"./../Helpers.js":7}],7:[function(require,module,exports){
var helpers = {
    extend: function() {
        'use strict';

        var options, name, src, copy, copyIsArray, clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;

        // Handle a deep copy situation
        if ( typeof target === "boolean" ) {
            deep = target;

            // Skip the boolean and the target
            target = arguments[ i ] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if ( i === length ) {
            target = this;
            i--;
        }

        for ( ; i < length; i++ ) {
            // Only deal with non-null/undefined values
            if ( (options = arguments[ i ]) != null ) {
                // Extend the base object
                for ( name in options ) {
                    src = target[ name ];
                    copy = options[ name ];

                    // Prevent never-ending loop
                    if ( target === copy ) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
                        if ( copyIsArray ) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[ name ] = jQuery.extend( deep, clone, copy );

                        // Don't bring in undefined values
                    } else if ( copy !== undefined ) {
                        target[ name ] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    },

    forEach: function (array, callback, scope) {
        'use strict';

        for (var i = 0; i < array.length; i++) {
            callback.call(scope, i, array[i]); // passes back stuff we need
        }
    },

    easeInOutQuad: function(currentTime, startValue, changedValue, duration) {
        'use strict';

        currentTime /= duration / 2;
        if (currentTime < 1) {
            return changedValue / 2 * currentTime * currentTime + startValue;
        }

        currentTime--;

        return -changedValue / 2 * (currentTime * (currentTime - 2) - 1) + startValue;
    },

    setTransform: function(element, prop) {
        'use strict';

        element.style.webkitTransform = prop;
        element.style.MozTransform = prop;
        element.style.msTransform = prop;
        element.style.OTransform = prop;
        element.style.transform = prop;
    }
};

module.exports = helpers;
},{}],8:[function(require,module,exports){
/* ComponentDomParser 0.0.1 | @license ISC */

(function (global, factory) {
    "use strict";

    // If the env is browserify, export the factory using the module object.
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global);

        // If the env is AMD, register the Module as 'ComponentDomParser'.
    } else if (global.define && typeof global.define === "function" && global.define.amd) {
        global.define("ComponentDomParser", [], function () {
            return factory(global);
        });

        // If the env is a browser(without CJS or AMD support), export the factory into the global window object.
    } else {
        global.ComponentDomParser = factory(global);
    }
})(window, function (global) {
    "use strict";

    var doc = global.document;

    /*
     * ComponentDomParser
     * @param options {Object} The options Object which initializes the parser.
     * @example
     * // Initialize a new instance of the ComponentDomParser.
     * var parser = new window.ComponentDomParser({
     *     dataSelector: 'app',
     *     componentIndex: {
     *         'myApplication': function(el) { el.innerHTML = 'myApplication initialized!' }
     *     },
     *     componentDidMountCallback: function(instance) {
     *         console.log(instance);
     *     }
     * });
     *
     * // Parse the document for all [data-app] nodes.
     * parser.parse();
     * @constructor
     */
    var ComponentDomParser = function (options) {
        this._checkForRequiredConstants(options);

        this.contextElement = options.contextElement || doc.body;
        this.dataSelector = options.dataSelector;
        this.componentIndex = options.componentIndex;
        this.componentDidMountCallback = options.componentDidMountCallback;
    };

    ComponentDomParser.prototype._checkForRequiredConstants = function (options) {
        if (!options) {
            throw new Error("ComponentDomParser Error: No option object was specified.");
        }

        if (!options.dataSelector) {
            throw new Error("ComponentDomParser Error: No dataSelector was specified.");
        }

        if (!options.componentIndex) {
            throw new Error("ComponentDomParser Error: No componentIndex was specified.");
        }

        if (options.componentDidMountCallback && typeof options.componentDidMountCallback !== "function") {
            throw new Error("ComponentDomParser Error: The componentDidMountCallback option must be a function.");
        }
    };

    ComponentDomParser.prototype.parse = function () {
        var elementNodeList = this.contextElement.querySelectorAll("[data-" + this.dataSelector + "]");
        var elementNodes = Array.prototype.slice.call(elementNodeList, 0);
        var self = this;

        elementNodes.forEach(function (node) {
            var componentKey = node.dataset[self.dataSelector];
            var Component = self.componentIndex[componentKey];

            if (Component) {
                self._mountComponent(node, Component);
            } else {
                console.info("ComponentDomParser Info: Component \"" + componentKey + "\" is not present in the passed componentIndex:", self.componentIndex);
            }
        });

        return this;
    };

    ComponentDomParser.prototype._mountComponent = function (node, Component) {
        var instance = new Component(node);

        if (this.componentDidMountCallback) {
            this.componentDidMountCallback(instance);
        }

        return instance;
    };


    return ComponentDomParser;
});

},{}],9:[function(require,module,exports){

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require, exports, module);
  } else {
    root.scrollReveal = factory();
  }
}(this, function(require, exports, module) {

/*
                       _ _ _____                      _   _
                      | | |  __ \                    | | (_)
    ___  ___ _ __ ___ | | | |__) |_____   _____  __ _| |  _ ___
   / __|/ __| '__/ _ \| | |  _  // _ \ \ / / _ \/ _` | | | / __|
   \__ \ (__| | | (_) | | | | \ \  __/\ V /  __/ (_| | |_| \__ \
   |___/\___|_|  \___/|_|_|_|  \_\___| \_/ \___|\__,_|_(_) |___/ v2.1.0
                                                        _/ |
                                                       |__/

============================================================================*/

/**
 * scrollReveal.js (c) 2014 Julian Lloyd ( @julianlloyd )
 *
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license.php
 */

window.scrollReveal = (function( window ) {

  'use strict'

  var _requestAnimFrame
    , extend
    , handler
    , self

  function scrollReveal( config ) {

    self         = this
    self.elems   = {}
    self.serial  = 1
    self.blocked = false
    self.config  = extend( self.defaults, config )

    if ( self.isMobile() && !self.config.mobile || !self.isSupported() ) {
      self.destroy()
      return
    }

    if ( self.config.viewport == window.document.documentElement ) {

      window.addEventListener( 'scroll', handler, false )
      window.addEventListener( 'resize', handler, false )

    } else self.config.viewport.addEventListener( 'scroll', handler, false )

    self.init( true )
  }

  scrollReveal.prototype = {

    defaults: {

      enter:    'bottom',
      move:     '8px',
      over:     '0.6s',
      wait:     '0s',
      easing:   'ease',

      scale:    { direction: 'up', power: '5%' },

      opacity:  0,
      mobile:   false,
      reset:    false,
      viewport: window.document.documentElement, // <HTML> element by default.

      /**
       *        'always' — delay every time an animation resets
       *        'once'   — delay only the first time an animation reveals
       *        'onload' - delay only for animations triggered by self.init()
       */
      delay:    'once',

      /**
       *        vFactor changes when an element is considered in the viewport;
       *        the default requires 60% of an element be visible.
       */
      vFactor:  0.60,

      complete: function( el ) {} // Note: reset animations do not complete.
    },

    /**
     * Queries the DOM, builds scrollReveal elements and triggers animation.
     * @param {boolean} flag — a hook for controlling delay on first load.
     */
    init: function( flag ) {

      var serial
        , elem
        , query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {

        serial      = self.serial++
        elem        = self.elems[ serial ] = { domEl: el }
        elem.config = self.configFactory( elem )
        elem.styles = self.styleFactory( elem )
        elem.seen   = false

        el.removeAttribute( 'data-sr' )
        el.setAttribute( 'style',

            elem.styles.inline
          + elem.styles.initial
        )
      })

      self.scrolled = self.scrollY()
      self.animate( flag )
    },

    /**
     * Applies and removes appropriate styles.
     * @param {boolean} flag — a hook for controlling delay on first load.
     */
    animate: function( flag ) {

      var key
        , elem
        , visible
        , complete

      /**
       * Cleans the DOM and removes completed elements from self.elems.
       * @param {integer} key — self.elems property key.
       */
      complete = function( key ) {

        var elem = self.elems[ key ]

        setTimeout(function() {

          elem.domEl.setAttribute( 'style', elem.styles.inline )
          elem.config.complete( elem.domEl )
          delete self.elems[ key ]

        }, elem.styles.duration )
      }

      /**
       * Begin loop.
       */
      for ( key in self.elems ) {
        if ( self.elems.hasOwnProperty( key ) ) {

          elem    = self.elems[ key ]
          visible = self.isElemInViewport( elem )

          if ( visible ) {

            if ( self.config.delay === 'always'
            || ( self.config.delay === 'onload' && flag )
            || ( self.config.delay === 'once'   && !elem.seen ) ) {

              /**
               * Use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.transition
              )

            } else {

              /**
               * Don’t use delay.
               */
              elem.domEl.setAttribute( 'style',

                  elem.styles.inline
                + elem.styles.target
                + elem.styles.reset
              )
            }

            elem.seen = true

            if ( !elem.config.reset && !elem.animating ) {

              /**
               * Reset is DISABLED for this element,
               * so let’s count down to animation complete.
               */
              elem.animating = true
              complete( key )
            }
          }

          if ( !visible && elem.config.reset ) {

            /**
             * Reset is ENABLED for this element,
             * so let’s apply its reset styles.
             */
            elem.domEl.setAttribute( 'style',

                elem.styles.inline
              + elem.styles.initial
              + elem.styles.reset
            )
          }
        }
      }

      self.blocked = false
    },

    /**
     * Parses an elements data-sr attribute, and returns a configuration object.
     * @param {object} elem — An object from self.elems.
     * @return {object}
     */
    configFactory: function( elem ) {

      var parsed = {}
        , config = {}
        , words  = elem.domEl.getAttribute( 'data-sr' ).split( /[, ]+/ )

      /**
       * Find and remove any syntax sugar.
       */
      words = self.filter( words )
      words.forEach(function( keyword, i ) {

        /**
         * Find keywords.
         */
        switch ( keyword ) {

          case 'enter':

            parsed.enter = words[ i + 1 ]
            return

          case 'wait':

            parsed.wait = words[ i + 1 ]
            return

          case 'move':

            parsed.move = words[ i + 1 ]
            return

          case 'ease':

            parsed.move = words[ i + 1 ]
            parsed.ease = 'ease'
            return

          case 'ease-in':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in'
            return

          case 'ease-in-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-in-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-in-out'
            return

          case 'ease-out':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'ease-out'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'ease-out'
            return

          case 'hustle':

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              parsed.easing          = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
              return
            }

            parsed.move   = words[ i + 1 ]
            parsed.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'
            return

          case 'over':

            parsed.over = words[ i + 1 ]
            return

          case 'reset':

            if ( words[ i - 1 ] == 'no' ) parsed.reset = false
            else                          parsed.reset = true

            return

          case 'scale':

            parsed.scale = {}

            if ( words[ i + 1 ] == 'up' || words[ i + 1 ] == 'down' ) {

              parsed.scale.direction = words[ i + 1 ]
              parsed.scale.power     = words[ i + 2 ]
              return
            }

            parsed.scale.power = words[ i + 1 ]
            return

          default:
            return
        }
      })

      /**
       * Build default config object, then apply any
       * overrides parsed from the data-sr attribute.
       */
      config = extend( config, self.config )
      config = extend( config, parsed )

      if ( config.enter  == 'top'  || config.enter == 'bottom' ) config.axis = 'Y'
      if ( config.enter  == 'left' || config.enter == 'right'  ) config.axis = 'X'

      /**
       * Check for hustle easing.
       */
      if ( config.easing == 'hustle' ) config.easing = 'cubic-bezier( 0.6, 0.2, 0.1, 1 )'

      /**
       * Let’s make sure our our pixel distances are negative for top and left.
       * e.g. "enter top and move 25px" starts at 'top: -25px' in CSS.
       */
      if ( config.enter == 'top' || config.enter == 'left' ) config.move = '-' + config.move

      return config

    },

    /**
     * Generates styles based on an elements configuration property.
     * @param {object} elem — An object from self.elems.
     * @return {object}
     */
    styleFactory: function( elem ) {

      var transition
        , initial
        , target
        , reset
        , inline
        , build

      inline = ( elem.domEl.getAttribute( 'style' ) ) ? elem.domEl.getAttribute( 'style' ) + '; visibility: visible; ' : 'visibility: visible; '

      /**
       * Want to disable delay on mobile devices? Uncomment the line below.
       */
      //if ( self.isMobile() && self.config.mobile ) elem.config.wait = 0

      transition = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + ', opacity ' + elem.config.over + ' ' + elem.config.easing + ' ' + elem.config.wait + '; ' +
                  '-webkit-perspective: 1000;' +
          '-webkit-backface-visibility: hidden;'

      reset      = '-webkit-transition: -webkit-transform ' + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                           'transition: transform '         + elem.config.over + ' ' + elem.config.easing + ' 0s, opacity ' + elem.config.over + ' ' + elem.config.easing + ' 0s; ' +
                  '-webkit-perspective: 1000; ' +
          '-webkit-backface-visibility: hidden; '

      /**
       * Constructs initial and target styles.
       */
      build = function() {

        if ( parseInt( elem.config.move ) != 0 ) {

          initial += ' translate' + elem.config.axis + '(' + elem.config.move + ')'
          target  += ' translate' + elem.config.axis + '(0)'
        }

        if ( parseInt( elem.config.scale.power ) != 0 ) {

          if ( elem.config.scale.direction == 'up'   ) elem.config.scale.value = 1 - ( parseFloat( elem.config.scale.power ) * 0.01 )
          if ( elem.config.scale.direction == 'down' ) elem.config.scale.value = 1 + ( parseFloat( elem.config.scale.power ) * 0.01 )

          initial += ' scale(' + elem.config.scale.value + ')'
          target  += ' scale(1)'
        }

        initial += '; opacity: ' + elem.config.opacity + '; '
        target  += '; opacity: 1; ';
      }

      initial = 'transform:'
      target  = 'transform:'

      build()

      /**
       * Build again for webkit.
       */
      initial += '-webkit-transform:'
      target  += '-webkit-transform:'

      build()

      return {

        transition: transition,
        initial:    initial,
        target:     target,
        reset:      reset,
        inline:     inline,
        duration:   ( ( parseFloat( elem.config.over ) + parseFloat( elem.config.wait ) ) * 1000 )
      }
    },

    filter: function( words ) {

      var filtered  = []

      var sugar = [

        'from',
        'the',
        'and',
        'then',
        'but',
        'with',
        'please',
      ]

      words.forEach(function( word ) {

        if ( sugar.indexOf( word ) > -1 ) return

        filtered.push( word )
        return
      })

      return filtered
    },

    getViewportH: function() {

      var client = self.config.viewport[ 'clientHeight' ]
        , inner  = window[ 'innerHeight' ]

      if ( self.config.viewport == window.document.documentElement ) {

        return ( client < inner ) ? inner : client
      }

      return client
    },

    scrollY: function() {

      if ( self.config.viewport == window.document.documentElement ) return window.pageYOffset

      return self.config.viewport.scrollTop + self.config.viewport.offsetTop
    },

    getOffset: function( el ) {

      var offsetTop  = 0
        , offsetLeft = 0

      do {

        if ( !isNaN( el.offsetTop  )) offsetTop  += el.offsetTop
        if ( !isNaN( el.offsetLeft )) offsetLeft += el.offsetLeft

      } while ( el = el.offsetParent )

      return {

        top: offsetTop,
        left: offsetLeft
      }
    },

    isElemInViewport: function( elem ) {

      var elHeight = elem.domEl.offsetHeight
        , elTop    = self.getOffset( elem.domEl ).top
        , elBottom = elTop + elHeight
        , vFactor  = elem.config.vFactor || 0

      return ( elTop + elHeight * vFactor < self.scrolled + self.getViewportH() )
          && ( elBottom - elHeight * vFactor > self.scrolled )
          || ( elem.domEl.currentStyle ? elem.domEl.currentStyle : window.getComputedStyle( elem.domEl, null ) ).position == 'fixed'
    },

    isMobile: function() {

      var agent = navigator.userAgent || navigator.vendor || window.opera

      return (/(ipad|playbook|silk|android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test( agent )||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test( agent.substr( 0, 4 ))) ? true : false
    },

    isSupported: function() {

      var sensor    = document.createElement( 'sensor' )
        , cssPrefix = 'Webkit,Moz,O,'.split( ',' )
        , tests     = ( 'transition ' + cssPrefix.join( 'transition,' ) ).split( ',' )

      for ( var i = 0; i < tests.length; i++ ) {

        if ( !sensor.style[tests[i]] === '' ) return false
      }

      return true
    },

    destroy: function() {

      var query

      query = Array.prototype.slice.call( self.config.viewport.querySelectorAll( '[data-sr]' ) )
      query.forEach(function ( el ) {
        el.removeAttribute( 'data-sr' )
      })
    }

  }

  handler = function( e ) {

    if ( !self.blocked ) {

      self.blocked  = true
      self.scrolled = self.scrollY()

      _requestAnimFrame( function() {

        self.animate()
      })
    }
  }

  extend = function( target, src ) {

    for ( var prop in src ) {

      if ( src.hasOwnProperty( prop ) ) {

        target[ prop ] = src[ prop ]
      }
    }

    return target
  }

  /**
   * RequestAnimationFrame polyfill.
   */
  _requestAnimFrame = (function() {

    return window.requestAnimationFrame        ||
           window.webkitRequestAnimationFrame  ||
           window.mozRequestAnimationFrame     ||

          function( callback ) {

            window.setTimeout( callback, 1000 / 60 )
          }
  }())

  return scrollReveal

})( window )

return scrollReveal;

}));

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQXBwLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L0NvbXBvbmVudHMvQ2xhc3NUb2dnbGVyL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9QYXJhbGxheFN0YWdlL1ZpZXcuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvQ29tcG9uZW50cy9TY3JvbGxUby9WaWV3LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9Db21wb25lbnRQcm90b3R5cGUvVXRpbC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvSGVscGVycy5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9jb21wb25lbnRkb21wYXJzZXIvRGlzdC9Db21wb25lbnREb21QYXJzZXIuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9ub2RlX21vZHVsZXMvc2Nyb2xsUmV2ZWFsL2Rpc3Qvc2Nyb2xsUmV2ZWFsLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIENvbXBvbmVudERvbVBhcnNlciA9IHJlcXVpcmUoXCJjb21wb25lbnRkb21wYXJzZXJcIiksXG4gICAgU2Nyb2xsUmV2ZWFsID0gcmVxdWlyZSgnc2Nyb2xsUmV2ZWFsJyksXG4gICAgQ29tcG9uZW50SW5kZXggPSByZXF1aXJlKCcuL1V0aWxpdGllcy9Db21wb25lbnRJbmRleC9VdGlsLmpzJyksXG4gICAgY29tcG9uZW50U3RvcmUgPSBuZXcgQ29tcG9uZW50SW5kZXgoKSxcbiAgICBwYXJzZXIsIHNjcm9sbFJldmVhbDtcblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudHMuXG5jb21wb25lbnRTdG9yZS5yZWdpc3RlcignY2xhc3NUb2dnbGVyJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL0NsYXNzVG9nZ2xlci9WaWV3LmpzJykpO1xuY29tcG9uZW50U3RvcmUucmVnaXN0ZXIoJ3BhcmFsbGF4U3RhZ2UnLCByZXF1aXJlKCcuL0NvbXBvbmVudHMvUGFyYWxsYXhTdGFnZS9WaWV3LmpzJykpO1xuY29tcG9uZW50U3RvcmUucmVnaXN0ZXIoJ3Njcm9sbFRvJywgcmVxdWlyZSgnLi9Db21wb25lbnRzL1Njcm9sbFRvL1ZpZXcuanMnKSk7XG5cbi8vIFNldHMgdXAgdGhlIGNvbXBvbmVudERvbVBhcnNlciBhbmQgcGFyc2UgZm9yIGFsbCBjb21wb25lbnQgbm9kZXMuXG5wYXJzZXIgPSBuZXcgQ29tcG9uZW50RG9tUGFyc2VyKHtcbiAgICBkYXRhU2VsZWN0b3I6ICdjb21wb25lbnQnLCAvLyBFcXVhbHMgW2RhdGEtY29tcG9uZW50PVwiKlwiXVxuICAgIGNvbXBvbmVudEluZGV4OiBjb21wb25lbnRTdG9yZS5nZXRJbmRleCgpLFxuICAgIGNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2s6IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBpZighaW5zdGFuY2UuaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zdGFuY2UuaW5pdGlhbGl6ZSgpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59KS5wYXJzZSgpO1xuXG5zY3JvbGxSZXZlYWwgPSBuZXcgU2Nyb2xsUmV2ZWFsKCk7IiwidmFyIGNvbXBvbmVudFByb3RvdHlwZSA9IHJlcXVpcmUoJ2NvbXBvbmVudFByb3RvdHlwZScpLFxuICAgIENsYXNzVG9nZ2xlcjtcblxuLyoqXG4gKiBDbGFzc1RvZ2dsZXJcbiAqIEBkZXNjcmlwdGlvbiBUb2dnbGVzIGEgY2xhc3Mgb24gYSB0YXJnZXQgZWxlbWVudCBvbiBjbGljay5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5DbGFzc1RvZ2dsZXIgPSBjb21wb25lbnRQcm90b3R5cGUuZXh0ZW5kKHtcbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBtb2R1bGUuXG4gICAgICogQHJldHVybnMge0NsYXNzVG9nZ2xlcn1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5lbC5kYXRhc2V0O1xuXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhc2V0LnRhcmdldCk7XG4gICAgICAgIHRoaXMuc2V0KCdjbGFzcycsIGRhdGFzZXQuY2xhc3MgfHwgJ2FjdGl2ZScpO1xuXG4gICAgICAgIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUNsYXNzKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZUNsYXNzXG4gICAgICogQGRlc2NyaXB0aW9uIFRvZ2dsZXMgdGhlIGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7Q2xhc3NUb2dnbGVyfVxuICAgICAqL1xuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG4gICAgICAgIHRoaXMudGFyZ2V0WzBdLmNsYXNzTGlzdC50b2dnbGUodGhpcy5nZXQoJ2NsYXNzJykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsYXNzVG9nZ2xlcjsiLCJ2YXIgY29tcG9uZW50UHJvdG90eXBlID0gcmVxdWlyZSgnY29tcG9uZW50UHJvdG90eXBlJyksXG4gICAgZm9yRWFjaCA9IHJlcXVpcmUoJy4vLi4vLi4vVXRpbGl0aWVzL0hlbHBlcnMnKS5mb3JFYWNoLFxuICAgIHNldFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vLi4vLi4vVXRpbGl0aWVzL0hlbHBlcnMnKS5zZXRUcmFuc2Zvcm0sXG4gICAgUGFyYWxsYXhTdGFnZTtcblxuLyoqXG4gKiBQYXJhbGxheFN0YWdlXG4gKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIHN1YnRsZSBwYXJhbGxheCBzY3JvbGxpbmcgZWZmZWN0IG9uIHNvbWUgY2hpbGQgZWxlbWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuUGFyYWxsYXhTdGFnZSA9IGNvbXBvbmVudFByb3RvdHlwZS5leHRlbmQoe1xuICAgIC8qKlxuICAgICAqIGluaXRpYWxpemVcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1vZHVsZS5cbiAgICAgKiBAcmV0dXJucyB7UGFyYWxsYXhTdGFnZX1cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5lbC5kYXRhc2V0O1xuXG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZGF0YXNldC50YXJnZXQgfHwgJ1tkYXRhLXBhcmFsbGF4XScpO1xuICAgICAgICB0aGlzLnNldCgnbGFzdFNjcm9sbFRvcCcsIDApO1xuXG4gICAgICAgIC8vIFNldHVwIHRoZSByQUYuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIF9hbmltRnJhbWU7XG5cbiAgICAgICAgKGZ1bmN0aW9uIGFuaW1sb29wKCl7XG4gICAgICAgICAgICBzZWxmLnJlbmRlcigpO1xuICAgICAgICAgICAgX2FuaW1GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWxvb3ApO1xuICAgICAgICB9KCkpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW5kZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVycyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCwgZGVwZW5kaW5nIG9uIHRoZSBsYXN0IHNjcm9sbGVkIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQYXJhbGxheFN0YWdlfVxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgY3VycmVudFNjcm9sbFRvcCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgbGFzdFNjcm9sbFRvcCA9IHRoaXMuZ2V0KCdsYXN0U2Nyb2xsVG9wJyk7XG5cbiAgICAgICAgaWYoY3VycmVudFNjcm9sbFRvcCA9PT0gbGFzdFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldCgnbGFzdFNjcm9sbFRvcCcsIGN1cnJlbnRTY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmFkanVzdFRhcmdldFBvc2l0aW9ucyhjdXJyZW50U2Nyb2xsVG9wKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYWRqdXN0VGFyZ2V0UG9zaXRpb25zXG4gICAgICogQGRlc2NyaXB0aW9uIExvb3BzIG92ZXIgZWFjaCB0YXJnZXQgbm9kZSBhbmQgY2FsbHMgdGhlIHRyYW5zZm9ybSBtZXRob2QgdG8gYWRqdXN0IGl0J3MgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHNjcm9sbFRvcCB7TnVtYmVyfSBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50L3RhcmdldCBub2RlLlxuICAgICAqIEByZXR1cm5zIHtQYXJhbGxheFN0YWdlfVxuICAgICAqL1xuICAgIGFkanVzdFRhcmdldFBvc2l0aW9uczogZnVuY3Rpb24oc2Nyb2xsVG9wKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICB2YXIgc3RhZ2VPZmZzZXQgPSB0aGlzLmVsLm9mZnNldFRvcCxcbiAgICAgICAgICAgIHNjcm9sbFBvcyA9IHNjcm9sbFRvcCAtIHN0YWdlT2Zmc2V0O1xuXG4gICAgICAgIGZvckVhY2godGhpcy50YXJnZXRzLCBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRTY3JvbGxQb3MgPSB0aGlzLmNhbGN1bGF0ZUVsZW1lbnRzU2Nyb2xsUG9zaXRpb24oaXRlbSwgc2Nyb2xsUG9zKTtcblxuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50c1RyYW5zZm9ybVZhbHVlKGl0ZW0sIGVsZW1lbnRTY3JvbGxQb3MpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVFbGVtZW50c1Njcm9sbFBvc2l0aW9uXG4gICAgICogQHBhcmFtIGVsZW1lbnQge0hUTUxFbGVtZW50fSBUaGUgbm9kZSBvbiB3aGljaCB0aGUgY2FsY3VsYXRpb24gaXMgYmFzZWQgb24uXG4gICAgICogQHBhcmFtIHNjcm9sbFBvcyB7TnVtYmVyfSBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBpbnN0YW5jZSdzIG5vZGUuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVFbGVtZW50c1Njcm9sbFBvc2l0aW9uOiBmdW5jdGlvbihlbGVtZW50LCBzY3JvbGxQb3MpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBwYXJhbGxheEZhY3RvciA9IChNYXRoLmFicyhlbGVtZW50LmRhdGFzZXQucGFyYWxsYXhmYWN0b3IpIHx8IDEpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHNjcm9sbFBvcyAvIHBhcmFsbGF4RmFjdG9yKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2V0RWxlbWVudHNUcmFuc2Zvcm1WYWx1ZVxuICAgICAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH0gVGhlIG5vZGUgb24gd2hpY2ggdGhlIGNhbGN1bGF0aW9uIGlzIGJhc2VkIG9uLlxuICAgICAqIEBwYXJhbSBzY3JvbGxQb3Mge051bWJlcn0gVGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgaW5zdGFuY2UncyBub2RlLlxuICAgICAqIEByZXR1cm5zIHtQYXJhbGxheFN0YWdlfVxuICAgICAqL1xuICAgIHNldEVsZW1lbnRzVHJhbnNmb3JtVmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQsIHNjcm9sbFBvcykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgc2V0VHJhbnNmb3JtKGVsZW1lbnQsICd0cmFuc2xhdGVZKCcgKyBzY3JvbGxQb3MgKyAncHgpJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFyYWxsYXhTdGFnZTsiLCJ2YXIgY29tcG9uZW50UHJvdG90eXBlID0gcmVxdWlyZSgnY29tcG9uZW50UHJvdG90eXBlJyksXG4gICAgZWFzZUluT3V0UXVhZCA9IHJlcXVpcmUoJy4vLi4vLi4vVXRpbGl0aWVzL0hlbHBlcnMnKS5lYXNlSW5PdXRRdWFkLFxuICAgIFNjcm9sbFRvO1xuXG4vKipcbiAqIFNjcm9sbFRvXG4gKiBAZGVzY3JpcHRpb24gU2Nyb2xscyB0byBhIGNlcnRhaW4gdGFyZ2V0IGVsZW1lbnQgb24gdGhlIGVsZW1lbnRzIGNsaWNrLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblNjcm9sbFRvID0gY29tcG9uZW50UHJvdG90eXBlLmV4dGVuZCh7XG4gICAgLyoqXG4gICAgICogaW5pdGlhbGl6ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgbW9kdWxlLlxuICAgICAqIEByZXR1cm5zIHtTY3JvbGxUb31cbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBkYXRhc2V0ID0gdGhpcy5lbC5kYXRhc2V0O1xuXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChkYXRhc2V0LnRhcmdldClbMF07XG4gICAgICAgIHRoaXMuc2V0KCdkdXJhdGlvbicsIGRhdGFzZXQuZHVyYXRpb24gfHwgNjAwKTtcblxuICAgICAgICB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb1RhcmdldCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzY3JvbGxUb1RhcmdldFxuICAgICAqIEBkZXNjcmlwdGlvbiBTY3JvbGxzIHRvIHRoZSB0YXJnZXQuXG4gICAgICogQHJldHVybnMge1Njcm9sbFRvfVxuICAgICAqL1xuICAgIHNjcm9sbFRvVGFyZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIHRvID0gdGhpcy50YXJnZXQub2Zmc2V0VG9wLFxuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldCgnZHVyYXRpb24nKSxcbiAgICAgICAgICAgIHN0YXJ0ID0gZWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgICAgICBjaGFuZ2UgPSB0byAtIHN0YXJ0LFxuICAgICAgICAgICAgY3VycmVudFRpbWUgPSAwLFxuICAgICAgICAgICAgaW5jcmVtZW50ID0gMjA7XG5cbiAgICAgICAgdmFyIGFuaW1hdGVTY3JvbGwgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY3VycmVudFRpbWUgKz0gaW5jcmVtZW50O1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVhc2VJbk91dFF1YWQoY3VycmVudFRpbWUsIHN0YXJ0LCBjaGFuZ2UsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsO1xuICAgICAgICAgICAgaWYoY3VycmVudFRpbWUgPCBkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYW5pbWF0ZVNjcm9sbCwgaW5jcmVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYW5pbWF0ZVNjcm9sbCgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjcm9sbFRvOyIsInZhciBDb21wb25lbnRJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHRoaXMuaW5kZXggPSB7fTtcbn07XG5Db21wb25lbnRJbmRleC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihrZXksIENvbnN0cnVjdG9yKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgaWYoIWtleSB8fCAhQ29uc3RydWN0b3IgfHwgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIENvbnN0cnVjdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmKHRoaXMuaW5kZXhba2V5XSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJ0NvbXBvbmVudCAnICsga2V5ICsgJyB3YXMgYWxyZWFkeSByZWdpc3RlcmVkIGluIHRoaXMgaW5kZXguJywgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmRleFtrZXldID0gQ29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuQ29tcG9uZW50SW5kZXgucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgcmV0dXJuIHRoaXMuaW5kZXg7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnRJbmRleDsiLCIvKipcbiAqIE1vZHVsZVByb3RvdHlwZVxuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBzZXQgb2YgaGFuZHkgZnVuY3Rpb25zIGFuZCByZWZlcmVuY2UgdGhlbSB0byBhIHRhcmdldCBlLmcuOlxuICogQGF1dGhvciBUeWxsIFdlacOfXG4gKi9cblxuXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnLi8uLi9IZWxwZXJzLmpzJykuZXh0ZW5kO1xuXG52YXIgUHJvdG90eXBlID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogaW5pdGlhbGl6ZVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gQSBkdW1teSBpbml0aWFsaXplIGZ1bmN0aW9uIHdoaWNoIHNldCdzIGdpdmVuIGF0dHJpYnV0ZXMgb24gdGhlIG1vZHVsZS5cbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZXMge29iamVjdCB8fCBzdHJpbmd9IFRoZSBhdHRyaWJ1dGUocykgdG8gc2V0IG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIElmIGF0dHJpYnV0ZXMgd2hlcmUgcGFzc2VkLCBzZXQgdGhlbSBvbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBpZihhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFNldCBhIGtleSAmIHZhbCBwYWlyIG9uIHRoZSBtb2R1bGUgYXR0cmlidXRlcyBvYmplY3QuXG4gICAgICAgICAqIEBwYXJhbSBrZXkge3N0cmluZ30gVGhlIHRhcmdldCBrZXkuXG4gICAgICAgICAqIEBwYXJhbSB2YWwge3N0cmluZ30gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgICAgICogQHJldHVybnMge1Byb3RvdHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSB0YXJnZXQgdG8gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iaiwgaWYgdHJ1ZSAtIHNldCBlYWNoIGtleS92YWwgcGFpci5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAga2V5LmZvckVhY2goZnVuY3Rpb24ob2JqS2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbb2JqS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBzZXQgdGhlIGtleS92YWwgcGFpci5cbiAgICAgICAgICAgIGlmKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuc2V0XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBVbnNldC9EZWxldGUgYSBrZXkgZnJvbSB0aGUgYXR0cmlidXRlcyBvYmouXG4gICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICogQHJldHVybnMge1Byb3RvdHlwZX1cbiAgICAgICAgICovXG4gICAgICAgIHVuc2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNba2V5XTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldFxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSB2YWx1ZSBvZiBhbiBrZXkgaW4gdGhlIGF0dHJpYnV0ZXMgb2JqLlxuICAgICAgICAgKiBAcGFyYW0ga2V5IHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5IHRvIGxvb2sgZm9yIGluIHRoZSBhdHRyaWJ1dGVzIG9iai5cbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGhhc1xuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhIGJvb2wgd2hpY2ggaW5kaWNhdGVzIGlmIGFuIGF0dHJpYnV0ZSB3YXMgc2V0IG9uIHRoZSBtb2R1bGUuXG4gICAgICAgICAqIEBwYXJhbSBhdHRyIHtzdHJpbmd9IFRoZSB0YXJnZXQga2V5IHRvIHRlc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChhdHRyKSAhPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHRlbmRcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBpbml0aWF0b3IgZnVuY3Rpb24gZm9yIGVhY2ggbW9kdWxlLCBpbnZva2VzIGEgbmV3IG1vZHVsZSBDb25zdHJ1Y3RvciBhbmQgZXh0ZW5kcyB0aGUgcHJvdG90eXBlIHdpdGggYWxsIGZ1bmN0aW9ucyBmb3VuZCBpbiB0aGlzIG9iamVjdC5cbiAgICAgICAgICogQGV4YW1wbGUgUHJvdG90eXBlLmV4dGVuZCh7b2JqZWN0fSk7XG4gICAgICAgICAqIEBwYXJhbSBwcm90b3R5cGVQcm9wcyB7b2JqZWN0fSBBIHNldCBvZiBmdW5jdGlvbnMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwcm90b3R5cGUgb2YgdGhlIGNyZWF0ZWQgQ29uc3RydWN0b3IuXG4gICAgICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgZW1wdHkgb2JqZWN0cy5cbiAgICAgICAgICAgIG9iaiA9IG9iaiA/IG9iaiA6IHt9O1xuXG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gZW1wdHkgZnVuY3Rpb24gd3JhcHBlci5cbiAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSB0YXJnZXQgZnVuY3Rpb24gd2l0aCB0aGUgYmFzZSBmdW5jdGlvbnMsIGFzIHdlbGwgYXMgdGhlIHByb3RvUHJvcHNcbiAgICAgICAgICAgIGV4dGVuZChDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHRoaXMsIG9iaik7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgdGFyZ2V0IGZ1bmN0aW9uLlxuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtaXhpblxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gTWl4IGEgc2V0IG9mIGZ1bmN0aW9ucyBpbnRvIHRoZSBjdXJyZW50IHByb3RvdHlwZS5cbiAgICAgICAgICogQGV4YW1wbGUgdGhpcy5taXhpbih7IGdldEZvdXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMisyOyB9IH0pO1xuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IHtPYmplY3R9IFRoZSBwcm90b3R5cGUsIHRvIG1peCB0aGUgT2JqIGludG8uXG4gICAgICAgICAqIEBwYXJhbSBvYmoge29iamVjdH0gQSBzZXQgb2YgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSBleHRlbmRlZCBvbiB0aGUgY3VycmVudCBwcm90b3R5cGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtQcm90b3R5cGV9XG4gICAgICAgICAqL1xuICAgICAgICBtaXhpbjogZnVuY3Rpb24odGFyZ2V0LCBvYmopIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgLy8gUHJldmVudCBlbXB0eSBvYmplY3RzLlxuICAgICAgICAgICAgb2JqID0gb2JqID8gb2JqIDoge307XG5cbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCB0aGlzLnByb3RvdHlwZTtcblxuICAgICAgICAgICAgaWYoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRlbmQgdGhlIHRhcmdldCBmdW5jdGlvbiB3aXRoIHRoZSBiYXNlIGZ1bmN0aW9ucywgYXMgd2VsbCBhcyB0aGUgcHJvdG9Qcm9wc1xuICAgICAgICAgICAgZXh0ZW5kKHRhcmdldCwgb2JqKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3RvdHlwZTsiLCJ2YXIgaGVscGVycyA9IHtcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzWzBdIHx8IHt9LFxuICAgICAgICAgICAgaSA9IDEsXG4gICAgICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSBcImJvb2xlYW5cIiApIHtcbiAgICAgICAgICAgIGRlZXAgPSB0YXJnZXQ7XG5cbiAgICAgICAgICAgIC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sgaSBdIHx8IHt9O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICAgIGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICAgIGlmICggaSA9PT0gbGVuZ3RoICkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuICAgICAgICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2UgaWYgd2UncmUgbWVyZ2luZyBwbGFpbiBvYmplY3RzIG9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoIGpRdWVyeS5pc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGpRdWVyeS5pc0FycmF5KGNvcHkpKSApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBjb3B5SXNBcnJheSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5SXNBcnJheSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gY29weTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uIChhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNjb3BlLCBpLCBhcnJheVtpXSk7IC8vIHBhc3NlcyBiYWNrIHN0dWZmIHdlIG5lZWRcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlYXNlSW5PdXRRdWFkOiBmdW5jdGlvbihjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgY2hhbmdlZFZhbHVlLCBkdXJhdGlvbikge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlZFZhbHVlIC8gMiAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRpbWUtLTtcblxuICAgICAgICByZXR1cm4gLWNoYW5nZWRWYWx1ZSAvIDIgKiAoY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSAtIDEpICsgc3RhcnRWYWx1ZTtcbiAgICB9LFxuXG4gICAgc2V0VHJhbnNmb3JtOiBmdW5jdGlvbihlbGVtZW50LCBwcm9wKSB7XG4gICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuTW96VHJhbnNmb3JtID0gcHJvcDtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5tc1RyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuT1RyYW5zZm9ybSA9IHByb3A7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gcHJvcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhlbHBlcnM7IiwiLyogQ29tcG9uZW50RG9tUGFyc2VyIDAuMC4xIHwgQGxpY2Vuc2UgSVNDICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBJZiB0aGUgZW52IGlzIGJyb3dzZXJpZnksIGV4cG9ydCB0aGUgZmFjdG9yeSB1c2luZyB0aGUgbW9kdWxlIG9iamVjdC5cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbCk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVudiBpcyBBTUQsIHJlZ2lzdGVyIHRoZSBNb2R1bGUgYXMgJ0NvbXBvbmVudERvbVBhcnNlcicuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZGVmaW5lICYmIHR5cGVvZiBnbG9iYWwuZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZ2xvYmFsLmRlZmluZS5hbWQpIHtcbiAgICAgICAgZ2xvYmFsLmRlZmluZShcIkNvbXBvbmVudERvbVBhcnNlclwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoZ2xvYmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVudiBpcyBhIGJyb3dzZXIod2l0aG91dCBDSlMgb3IgQU1EIHN1cHBvcnQpLCBleHBvcnQgdGhlIGZhY3RvcnkgaW50byB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLkNvbXBvbmVudERvbVBhcnNlciA9IGZhY3RvcnkoZ2xvYmFsKTtcbiAgICB9XG59KSh3aW5kb3csIGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG5cbiAgICAvKlxuICAgICAqIENvbXBvbmVudERvbVBhcnNlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFRoZSBvcHRpb25zIE9iamVjdCB3aGljaCBpbml0aWFsaXplcyB0aGUgcGFyc2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gSW5pdGlhbGl6ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgQ29tcG9uZW50RG9tUGFyc2VyLlxuICAgICAqIHZhciBwYXJzZXIgPSBuZXcgd2luZG93LkNvbXBvbmVudERvbVBhcnNlcih7XG4gICAgICogICAgIGRhdGFTZWxlY3RvcjogJ2FwcCcsXG4gICAgICogICAgIGNvbXBvbmVudEluZGV4OiB7XG4gICAgICogICAgICAgICAnbXlBcHBsaWNhdGlvbic6IGZ1bmN0aW9uKGVsKSB7IGVsLmlubmVySFRNTCA9ICdteUFwcGxpY2F0aW9uIGluaXRpYWxpemVkIScgfVxuICAgICAqICAgICB9LFxuICAgICAqICAgICBjb21wb25lbnREaWRNb3VudENhbGxiYWNrOiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgICAqICAgICAgICAgY29uc29sZS5sb2coaW5zdGFuY2UpO1xuICAgICAqICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBQYXJzZSB0aGUgZG9jdW1lbnQgZm9yIGFsbCBbZGF0YS1hcHBdIG5vZGVzLlxuICAgICAqIHBhcnNlci5wYXJzZSgpO1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBDb21wb25lbnREb21QYXJzZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9jaGVja0ZvclJlcXVpcmVkQ29uc3RhbnRzKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dEVsZW1lbnQgPSBvcHRpb25zLmNvbnRleHRFbGVtZW50IHx8IGRvYy5ib2R5O1xuICAgICAgICB0aGlzLmRhdGFTZWxlY3RvciA9IG9wdGlvbnMuZGF0YVNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEluZGV4ID0gb3B0aW9ucy5jb21wb25lbnRJbmRleDtcbiAgICAgICAgdGhpcy5jb21wb25lbnREaWRNb3VudENhbGxiYWNrID0gb3B0aW9ucy5jb21wb25lbnREaWRNb3VudENhbGxiYWNrO1xuICAgIH07XG5cbiAgICBDb21wb25lbnREb21QYXJzZXIucHJvdG90eXBlLl9jaGVja0ZvclJlcXVpcmVkQ29uc3RhbnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnREb21QYXJzZXIgRXJyb3I6IE5vIG9wdGlvbiBvYmplY3Qgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW9wdGlvbnMuZGF0YVNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnREb21QYXJzZXIgRXJyb3I6IE5vIGRhdGFTZWxlY3RvciB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5jb21wb25lbnRJbmRleCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50RG9tUGFyc2VyIEVycm9yOiBObyBjb21wb25lbnRJbmRleCB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMuY29tcG9uZW50RGlkTW91bnRDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnREb21QYXJzZXIgRXJyb3I6IFRoZSBjb21wb25lbnREaWRNb3VudENhbGxiYWNrIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENvbXBvbmVudERvbVBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50Tm9kZUxpc3QgPSB0aGlzLmNvbnRleHRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1cIiArIHRoaXMuZGF0YVNlbGVjdG9yICsgXCJdXCIpO1xuICAgICAgICB2YXIgZWxlbWVudE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudE5vZGVMaXN0LCAwKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGVsZW1lbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50S2V5ID0gbm9kZS5kYXRhc2V0W3NlbGYuZGF0YVNlbGVjdG9yXTtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSBzZWxmLmNvbXBvbmVudEluZGV4W2NvbXBvbmVudEtleV07XG5cbiAgICAgICAgICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9tb3VudENvbXBvbmVudChub2RlLCBDb21wb25lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXCJDb21wb25lbnREb21QYXJzZXIgSW5mbzogQ29tcG9uZW50IFxcXCJcIiArIGNvbXBvbmVudEtleSArIFwiXFxcIiBpcyBub3QgcHJlc2VudCBpbiB0aGUgcGFzc2VkIGNvbXBvbmVudEluZGV4OlwiLCBzZWxmLmNvbXBvbmVudEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIENvbXBvbmVudERvbVBhcnNlci5wcm90b3R5cGUuX21vdW50Q29tcG9uZW50ID0gZnVuY3Rpb24gKG5vZGUsIENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KG5vZGUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudERpZE1vdW50Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50RGlkTW91bnRDYWxsYmFjayhpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcblxuXG4gICAgcmV0dXJuIENvbXBvbmVudERvbVBhcnNlcjtcbn0pO1xuIiwiXG4oZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3Quc2Nyb2xsUmV2ZWFsID0gZmFjdG9yeSgpO1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICBfIF8gX19fX18gICAgICAgICAgICAgICAgICAgICAgXyAgIF9cbiAgICAgICAgICAgICAgICAgICAgICB8IHwgfCAgX18gXFwgICAgICAgICAgICAgICAgICAgIHwgfCAoXylcbiAgICBfX18gIF9fXyBfIF9fIF9fXyB8IHwgfCB8X18pIHxfX19fXyAgIF9fX19fICBfXyBffCB8ICBfIF9fX1xuICAgLyBfX3wvIF9ffCAnX18vIF8gXFx8IHwgfCAgXyAgLy8gXyBcXCBcXCAvIC8gXyBcXC8gX2AgfCB8IHwgLyBfX3xcbiAgIFxcX18gXFwgKF9ffCB8IHwgKF8pIHwgfCB8IHwgXFwgXFwgIF9fL1xcIFYgLyAgX18vIChffCB8IHxffCBcXF9fIFxcXG4gICB8X19fL1xcX19ffF98ICBcXF9fXy98X3xffF98ICBcXF9cXF9fX3wgXFxfLyBcXF9fX3xcXF9fLF98XyhfKSB8X19fLyB2Mi4xLjBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy8gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxfXy9cblxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8qKlxuICogc2Nyb2xsUmV2ZWFsLmpzIChjKSAyMDE0IEp1bGlhbiBMbG95ZCAoIEBqdWxpYW5sbG95ZCApXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICovXG5cbndpbmRvdy5zY3JvbGxSZXZlYWwgPSAoZnVuY3Rpb24oIHdpbmRvdyApIHtcblxuICAndXNlIHN0cmljdCdcblxuICB2YXIgX3JlcXVlc3RBbmltRnJhbWVcbiAgICAsIGV4dGVuZFxuICAgICwgaGFuZGxlclxuICAgICwgc2VsZlxuXG4gIGZ1bmN0aW9uIHNjcm9sbFJldmVhbCggY29uZmlnICkge1xuXG4gICAgc2VsZiAgICAgICAgID0gdGhpc1xuICAgIHNlbGYuZWxlbXMgICA9IHt9XG4gICAgc2VsZi5zZXJpYWwgID0gMVxuICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlXG4gICAgc2VsZi5jb25maWcgID0gZXh0ZW5kKCBzZWxmLmRlZmF1bHRzLCBjb25maWcgKVxuXG4gICAgaWYgKCBzZWxmLmlzTW9iaWxlKCkgJiYgIXNlbGYuY29uZmlnLm1vYmlsZSB8fCAhc2VsZi5pc1N1cHBvcnRlZCgpICkge1xuICAgICAgc2VsZi5kZXN0cm95KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICggc2VsZi5jb25maWcudmlld3BvcnQgPT0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdzY3JvbGwnLCBoYW5kbGVyLCBmYWxzZSApXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3Jlc2l6ZScsIGhhbmRsZXIsIGZhbHNlIClcblxuICAgIH0gZWxzZSBzZWxmLmNvbmZpZy52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCAnc2Nyb2xsJywgaGFuZGxlciwgZmFsc2UgKVxuXG4gICAgc2VsZi5pbml0KCB0cnVlIClcbiAgfVxuXG4gIHNjcm9sbFJldmVhbC5wcm90b3R5cGUgPSB7XG5cbiAgICBkZWZhdWx0czoge1xuXG4gICAgICBlbnRlcjogICAgJ2JvdHRvbScsXG4gICAgICBtb3ZlOiAgICAgJzhweCcsXG4gICAgICBvdmVyOiAgICAgJzAuNnMnLFxuICAgICAgd2FpdDogICAgICcwcycsXG4gICAgICBlYXNpbmc6ICAgJ2Vhc2UnLFxuXG4gICAgICBzY2FsZTogICAgeyBkaXJlY3Rpb246ICd1cCcsIHBvd2VyOiAnNSUnIH0sXG5cbiAgICAgIG9wYWNpdHk6ICAwLFxuICAgICAgbW9iaWxlOiAgIGZhbHNlLFxuICAgICAgcmVzZXQ6ICAgIGZhbHNlLFxuICAgICAgdmlld3BvcnQ6IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIC8vIDxIVE1MPiBlbGVtZW50IGJ5IGRlZmF1bHQuXG5cbiAgICAgIC8qKlxuICAgICAgICogICAgICAgICdhbHdheXMnIOKAlCBkZWxheSBldmVyeSB0aW1lIGFuIGFuaW1hdGlvbiByZXNldHNcbiAgICAgICAqICAgICAgICAnb25jZScgICDigJQgZGVsYXkgb25seSB0aGUgZmlyc3QgdGltZSBhbiBhbmltYXRpb24gcmV2ZWFsc1xuICAgICAgICogICAgICAgICdvbmxvYWQnIC0gZGVsYXkgb25seSBmb3IgYW5pbWF0aW9ucyB0cmlnZ2VyZWQgYnkgc2VsZi5pbml0KClcbiAgICAgICAqL1xuICAgICAgZGVsYXk6ICAgICdvbmNlJyxcblxuICAgICAgLyoqXG4gICAgICAgKiAgICAgICAgdkZhY3RvciBjaGFuZ2VzIHdoZW4gYW4gZWxlbWVudCBpcyBjb25zaWRlcmVkIGluIHRoZSB2aWV3cG9ydDtcbiAgICAgICAqICAgICAgICB0aGUgZGVmYXVsdCByZXF1aXJlcyA2MCUgb2YgYW4gZWxlbWVudCBiZSB2aXNpYmxlLlxuICAgICAgICovXG4gICAgICB2RmFjdG9yOiAgMC42MCxcblxuICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCBlbCApIHt9IC8vIE5vdGU6IHJlc2V0IGFuaW1hdGlvbnMgZG8gbm90IGNvbXBsZXRlLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIHRoZSBET00sIGJ1aWxkcyBzY3JvbGxSZXZlYWwgZWxlbWVudHMgYW5kIHRyaWdnZXJzIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcg4oCUIGEgaG9vayBmb3IgY29udHJvbGxpbmcgZGVsYXkgb24gZmlyc3QgbG9hZC5cbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiggZmxhZyApIHtcblxuICAgICAgdmFyIHNlcmlhbFxuICAgICAgICAsIGVsZW1cbiAgICAgICAgLCBxdWVyeVxuXG4gICAgICBxdWVyeSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBzZWxmLmNvbmZpZy52aWV3cG9ydC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtc3JdJyApIClcbiAgICAgIHF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKCBlbCApIHtcblxuICAgICAgICBzZXJpYWwgICAgICA9IHNlbGYuc2VyaWFsKytcbiAgICAgICAgZWxlbSAgICAgICAgPSBzZWxmLmVsZW1zWyBzZXJpYWwgXSA9IHsgZG9tRWw6IGVsIH1cbiAgICAgICAgZWxlbS5jb25maWcgPSBzZWxmLmNvbmZpZ0ZhY3RvcnkoIGVsZW0gKVxuICAgICAgICBlbGVtLnN0eWxlcyA9IHNlbGYuc3R5bGVGYWN0b3J5KCBlbGVtIClcbiAgICAgICAgZWxlbS5zZWVuICAgPSBmYWxzZVxuXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSggJ2RhdGEtc3InIClcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLFxuXG4gICAgICAgICAgICBlbGVtLnN0eWxlcy5pbmxpbmVcbiAgICAgICAgICArIGVsZW0uc3R5bGVzLmluaXRpYWxcbiAgICAgICAgKVxuICAgICAgfSlcblxuICAgICAgc2VsZi5zY3JvbGxlZCA9IHNlbGYuc2Nyb2xsWSgpXG4gICAgICBzZWxmLmFuaW1hdGUoIGZsYWcgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGFuZCByZW1vdmVzIGFwcHJvcHJpYXRlIHN0eWxlcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZsYWcg4oCUIGEgaG9vayBmb3IgY29udHJvbGxpbmcgZGVsYXkgb24gZmlyc3QgbG9hZC5cbiAgICAgKi9cbiAgICBhbmltYXRlOiBmdW5jdGlvbiggZmxhZyApIHtcblxuICAgICAgdmFyIGtleVxuICAgICAgICAsIGVsZW1cbiAgICAgICAgLCB2aXNpYmxlXG4gICAgICAgICwgY29tcGxldGVcblxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhbnMgdGhlIERPTSBhbmQgcmVtb3ZlcyBjb21wbGV0ZWQgZWxlbWVudHMgZnJvbSBzZWxmLmVsZW1zLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBrZXkg4oCUIHNlbGYuZWxlbXMgcHJvcGVydHkga2V5LlxuICAgICAgICovXG4gICAgICBjb21wbGV0ZSA9IGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICAgICAgdmFyIGVsZW0gPSBzZWxmLmVsZW1zWyBrZXkgXVxuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgZWxlbS5zdHlsZXMuaW5saW5lIClcbiAgICAgICAgICBlbGVtLmNvbmZpZy5jb21wbGV0ZSggZWxlbS5kb21FbCApXG4gICAgICAgICAgZGVsZXRlIHNlbGYuZWxlbXNbIGtleSBdXG5cbiAgICAgICAgfSwgZWxlbS5zdHlsZXMuZHVyYXRpb24gKVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIEJlZ2luIGxvb3AuXG4gICAgICAgKi9cbiAgICAgIGZvciAoIGtleSBpbiBzZWxmLmVsZW1zICkge1xuICAgICAgICBpZiAoIHNlbGYuZWxlbXMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXG4gICAgICAgICAgZWxlbSAgICA9IHNlbGYuZWxlbXNbIGtleSBdXG4gICAgICAgICAgdmlzaWJsZSA9IHNlbGYuaXNFbGVtSW5WaWV3cG9ydCggZWxlbSApXG5cbiAgICAgICAgICBpZiAoIHZpc2libGUgKSB7XG5cbiAgICAgICAgICAgIGlmICggc2VsZi5jb25maWcuZGVsYXkgPT09ICdhbHdheXMnXG4gICAgICAgICAgICB8fCAoIHNlbGYuY29uZmlnLmRlbGF5ID09PSAnb25sb2FkJyAmJiBmbGFnIClcbiAgICAgICAgICAgIHx8ICggc2VsZi5jb25maWcuZGVsYXkgPT09ICdvbmNlJyAgICYmICFlbGVtLnNlZW4gKSApIHtcblxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogVXNlIGRlbGF5LlxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgZWxlbS5kb21FbC5zZXRBdHRyaWJ1dGUoICdzdHlsZScsXG5cbiAgICAgICAgICAgICAgICAgIGVsZW0uc3R5bGVzLmlubGluZVxuICAgICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMudGFyZ2V0XG4gICAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy50cmFuc2l0aW9uXG4gICAgICAgICAgICAgIClcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogRG9u4oCZdCB1c2UgZGVsYXkuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBlbGVtLmRvbUVsLnNldEF0dHJpYnV0ZSggJ3N0eWxlJyxcblxuICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lXG4gICAgICAgICAgICAgICAgKyBlbGVtLnN0eWxlcy50YXJnZXRcbiAgICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnJlc2V0XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbS5zZWVuID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoICFlbGVtLmNvbmZpZy5yZXNldCAmJiAhZWxlbS5hbmltYXRpbmcgKSB7XG5cbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIFJlc2V0IGlzIERJU0FCTEVEIGZvciB0aGlzIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAqIHNvIGxldOKAmXMgY291bnQgZG93biB0byBhbmltYXRpb24gY29tcGxldGUuXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICBlbGVtLmFuaW1hdGluZyA9IHRydWVcbiAgICAgICAgICAgICAgY29tcGxldGUoIGtleSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCAhdmlzaWJsZSAmJiBlbGVtLmNvbmZpZy5yZXNldCApIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCBpcyBFTkFCTEVEIGZvciB0aGlzIGVsZW1lbnQsXG4gICAgICAgICAgICAgKiBzbyBsZXTigJlzIGFwcGx5IGl0cyByZXNldCBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW0uZG9tRWwuc2V0QXR0cmlidXRlKCAnc3R5bGUnLFxuXG4gICAgICAgICAgICAgICAgZWxlbS5zdHlsZXMuaW5saW5lXG4gICAgICAgICAgICAgICsgZWxlbS5zdHlsZXMuaW5pdGlhbFxuICAgICAgICAgICAgICArIGVsZW0uc3R5bGVzLnJlc2V0XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBlbGVtZW50cyBkYXRhLXNyIGF0dHJpYnV0ZSwgYW5kIHJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbSDigJQgQW4gb2JqZWN0IGZyb20gc2VsZi5lbGVtcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgY29uZmlnRmFjdG9yeTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgIHZhciBwYXJzZWQgPSB7fVxuICAgICAgICAsIGNvbmZpZyA9IHt9XG4gICAgICAgICwgd29yZHMgID0gZWxlbS5kb21FbC5nZXRBdHRyaWJ1dGUoICdkYXRhLXNyJyApLnNwbGl0KCAvWywgXSsvIClcblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGFuZCByZW1vdmUgYW55IHN5bnRheCBzdWdhci5cbiAgICAgICAqL1xuICAgICAgd29yZHMgPSBzZWxmLmZpbHRlciggd29yZHMgKVxuICAgICAgd29yZHMuZm9yRWFjaChmdW5jdGlvbigga2V5d29yZCwgaSApIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBrZXl3b3Jkcy5cbiAgICAgICAgICovXG4gICAgICAgIHN3aXRjaCAoIGtleXdvcmQgKSB7XG5cbiAgICAgICAgICBjYXNlICdlbnRlcic6XG5cbiAgICAgICAgICAgIHBhcnNlZC5lbnRlciA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ3dhaXQnOlxuXG4gICAgICAgICAgICBwYXJzZWQud2FpdCA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ21vdmUnOlxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ2Vhc2UnOlxuXG4gICAgICAgICAgICBwYXJzZWQubW92ZSA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzZSA9ICdlYXNlJ1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLWluJzpcblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHBhcnNlZC5lYXNpbmcgICAgICAgICAgPSAnZWFzZS1pbidcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlICAgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcGFyc2VkLmVhc2luZyA9ICdlYXNlLWluJ1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLWluLW91dCc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgKyAxIF0gPT0gJ3VwJyB8fCB3b3Jkc1sgaSArIDEgXSA9PSAnZG93bicgKSB7XG5cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLmRpcmVjdGlvbiA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciAgICAgPSB3b3Jkc1sgaSArIDIgXVxuICAgICAgICAgICAgICBwYXJzZWQuZWFzaW5nICAgICAgICAgID0gJ2Vhc2UtaW4tb3V0J1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2Vhc2UtaW4tb3V0J1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdlYXNlLW91dCc6XG5cbiAgICAgICAgICAgIGlmICggd29yZHNbIGkgKyAxIF0gPT0gJ3VwJyB8fCB3b3Jkc1sgaSArIDEgXSA9PSAnZG93bicgKSB7XG5cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLmRpcmVjdGlvbiA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5wb3dlciAgICAgPSB3b3Jkc1sgaSArIDIgXVxuICAgICAgICAgICAgICBwYXJzZWQuZWFzaW5nICAgICAgICAgID0gJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyc2VkLm1vdmUgICA9IHdvcmRzWyBpICsgMSBdXG4gICAgICAgICAgICBwYXJzZWQuZWFzaW5nID0gJ2Vhc2Utb3V0J1xuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBjYXNlICdodXN0bGUnOlxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpICsgMSBdID09ICd1cCcgfHwgd29yZHNbIGkgKyAxIF0gPT0gJ2Rvd24nICkge1xuXG4gICAgICAgICAgICAgIHBhcnNlZC5zY2FsZS5kaXJlY3Rpb24gPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgICAgID0gd29yZHNbIGkgKyAyIF1cbiAgICAgICAgICAgICAgcGFyc2VkLmVhc2luZyAgICAgICAgICA9ICdjdWJpYy1iZXppZXIoIDAuNiwgMC4yLCAwLjEsIDEgKSdcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZC5tb3ZlICAgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcGFyc2VkLmVhc2luZyA9ICdjdWJpYy1iZXppZXIoIDAuNiwgMC4yLCAwLjEsIDEgKSdcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAnb3Zlcic6XG5cbiAgICAgICAgICAgIHBhcnNlZC5vdmVyID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgY2FzZSAncmVzZXQnOlxuXG4gICAgICAgICAgICBpZiAoIHdvcmRzWyBpIC0gMSBdID09ICdubycgKSBwYXJzZWQucmVzZXQgPSBmYWxzZVxuICAgICAgICAgICAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnJlc2V0ID0gdHJ1ZVxuXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcblxuICAgICAgICAgICAgcGFyc2VkLnNjYWxlID0ge31cblxuICAgICAgICAgICAgaWYgKCB3b3Jkc1sgaSArIDEgXSA9PSAndXAnIHx8IHdvcmRzWyBpICsgMSBdID09ICdkb3duJyApIHtcblxuICAgICAgICAgICAgICBwYXJzZWQuc2NhbGUuZGlyZWN0aW9uID0gd29yZHNbIGkgKyAxIF1cbiAgICAgICAgICAgICAgcGFyc2VkLnNjYWxlLnBvd2VyICAgICA9IHdvcmRzWyBpICsgMiBdXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJzZWQuc2NhbGUucG93ZXIgPSB3b3Jkc1sgaSArIDEgXVxuICAgICAgICAgICAgcmV0dXJuXG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIC8qKlxuICAgICAgICogQnVpbGQgZGVmYXVsdCBjb25maWcgb2JqZWN0LCB0aGVuIGFwcGx5IGFueVxuICAgICAgICogb3ZlcnJpZGVzIHBhcnNlZCBmcm9tIHRoZSBkYXRhLXNyIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgY29uZmlnID0gZXh0ZW5kKCBjb25maWcsIHNlbGYuY29uZmlnIClcbiAgICAgIGNvbmZpZyA9IGV4dGVuZCggY29uZmlnLCBwYXJzZWQgKVxuXG4gICAgICBpZiAoIGNvbmZpZy5lbnRlciAgPT0gJ3RvcCcgIHx8IGNvbmZpZy5lbnRlciA9PSAnYm90dG9tJyApIGNvbmZpZy5heGlzID0gJ1knXG4gICAgICBpZiAoIGNvbmZpZy5lbnRlciAgPT0gJ2xlZnQnIHx8IGNvbmZpZy5lbnRlciA9PSAncmlnaHQnICApIGNvbmZpZy5heGlzID0gJ1gnXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2hlY2sgZm9yIGh1c3RsZSBlYXNpbmcuXG4gICAgICAgKi9cbiAgICAgIGlmICggY29uZmlnLmVhc2luZyA9PSAnaHVzdGxlJyApIGNvbmZpZy5lYXNpbmcgPSAnY3ViaWMtYmV6aWVyKCAwLjYsIDAuMiwgMC4xLCAxICknXG5cbiAgICAgIC8qKlxuICAgICAgICogTGV04oCZcyBtYWtlIHN1cmUgb3VyIG91ciBwaXhlbCBkaXN0YW5jZXMgYXJlIG5lZ2F0aXZlIGZvciB0b3AgYW5kIGxlZnQuXG4gICAgICAgKiBlLmcuIFwiZW50ZXIgdG9wIGFuZCBtb3ZlIDI1cHhcIiBzdGFydHMgYXQgJ3RvcDogLTI1cHgnIGluIENTUy5cbiAgICAgICAqL1xuICAgICAgaWYgKCBjb25maWcuZW50ZXIgPT0gJ3RvcCcgfHwgY29uZmlnLmVudGVyID09ICdsZWZ0JyApIGNvbmZpZy5tb3ZlID0gJy0nICsgY29uZmlnLm1vdmVcblxuICAgICAgcmV0dXJuIGNvbmZpZ1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBzdHlsZXMgYmFzZWQgb24gYW4gZWxlbWVudHMgY29uZmlndXJhdGlvbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZWxlbSDigJQgQW4gb2JqZWN0IGZyb20gc2VsZi5lbGVtcy5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gICAgc3R5bGVGYWN0b3J5OiBmdW5jdGlvbiggZWxlbSApIHtcblxuICAgICAgdmFyIHRyYW5zaXRpb25cbiAgICAgICAgLCBpbml0aWFsXG4gICAgICAgICwgdGFyZ2V0XG4gICAgICAgICwgcmVzZXRcbiAgICAgICAgLCBpbmxpbmVcbiAgICAgICAgLCBidWlsZFxuXG4gICAgICBpbmxpbmUgPSAoIGVsZW0uZG9tRWwuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICkgKSA/IGVsZW0uZG9tRWwuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICkgKyAnOyB2aXNpYmlsaXR5OiB2aXNpYmxlOyAnIDogJ3Zpc2liaWxpdHk6IHZpc2libGU7ICdcblxuICAgICAgLyoqXG4gICAgICAgKiBXYW50IHRvIGRpc2FibGUgZGVsYXkgb24gbW9iaWxlIGRldmljZXM/IFVuY29tbWVudCB0aGUgbGluZSBiZWxvdy5cbiAgICAgICAqL1xuICAgICAgLy9pZiAoIHNlbGYuaXNNb2JpbGUoKSAmJiBzZWxmLmNvbmZpZy5tb2JpbGUgKSBlbGVtLmNvbmZpZy53YWl0ID0gMFxuXG4gICAgICB0cmFuc2l0aW9uID0gJy13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gJyArIGVsZW0uY29uZmlnLm92ZXIgKyAnICcgKyBlbGVtLmNvbmZpZy5lYXNpbmcgKyAnICcgKyBlbGVtLmNvbmZpZy53YWl0ICsgJywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgJyArIGVsZW0uY29uZmlnLndhaXQgKyAnOyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gJyAgICAgICAgICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgJyArIGVsZW0uY29uZmlnLndhaXQgKyAnLCBvcGFjaXR5ICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAnICsgZWxlbS5jb25maWcud2FpdCArICc7ICcgK1xuICAgICAgICAgICAgICAgICAgJy13ZWJraXQtcGVyc3BlY3RpdmU6IDEwMDA7JyArXG4gICAgICAgICAgJy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuOydcblxuICAgICAgcmVzZXQgICAgICA9ICctd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtICcgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwcywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgMHM7ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zaXRpb246IHRyYW5zZm9ybSAnICAgICAgICAgKyBlbGVtLmNvbmZpZy5vdmVyICsgJyAnICsgZWxlbS5jb25maWcuZWFzaW5nICsgJyAwcywgb3BhY2l0eSAnICsgZWxlbS5jb25maWcub3ZlciArICcgJyArIGVsZW0uY29uZmlnLmVhc2luZyArICcgMHM7ICcgK1xuICAgICAgICAgICAgICAgICAgJy13ZWJraXQtcGVyc3BlY3RpdmU6IDEwMDA7ICcgK1xuICAgICAgICAgICctd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjsgJ1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnN0cnVjdHMgaW5pdGlhbCBhbmQgdGFyZ2V0IHN0eWxlcy5cbiAgICAgICAqL1xuICAgICAgYnVpbGQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIHBhcnNlSW50KCBlbGVtLmNvbmZpZy5tb3ZlICkgIT0gMCApIHtcblxuICAgICAgICAgIGluaXRpYWwgKz0gJyB0cmFuc2xhdGUnICsgZWxlbS5jb25maWcuYXhpcyArICcoJyArIGVsZW0uY29uZmlnLm1vdmUgKyAnKSdcbiAgICAgICAgICB0YXJnZXQgICs9ICcgdHJhbnNsYXRlJyArIGVsZW0uY29uZmlnLmF4aXMgKyAnKDApJ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBwYXJzZUludCggZWxlbS5jb25maWcuc2NhbGUucG93ZXIgKSAhPSAwICkge1xuXG4gICAgICAgICAgaWYgKCBlbGVtLmNvbmZpZy5zY2FsZS5kaXJlY3Rpb24gPT0gJ3VwJyAgICkgZWxlbS5jb25maWcuc2NhbGUudmFsdWUgPSAxIC0gKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5zY2FsZS5wb3dlciApICogMC4wMSApXG4gICAgICAgICAgaWYgKCBlbGVtLmNvbmZpZy5zY2FsZS5kaXJlY3Rpb24gPT0gJ2Rvd24nICkgZWxlbS5jb25maWcuc2NhbGUudmFsdWUgPSAxICsgKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5zY2FsZS5wb3dlciApICogMC4wMSApXG5cbiAgICAgICAgICBpbml0aWFsICs9ICcgc2NhbGUoJyArIGVsZW0uY29uZmlnLnNjYWxlLnZhbHVlICsgJyknXG4gICAgICAgICAgdGFyZ2V0ICArPSAnIHNjYWxlKDEpJ1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbCArPSAnOyBvcGFjaXR5OiAnICsgZWxlbS5jb25maWcub3BhY2l0eSArICc7ICdcbiAgICAgICAgdGFyZ2V0ICArPSAnOyBvcGFjaXR5OiAxOyAnO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsID0gJ3RyYW5zZm9ybTonXG4gICAgICB0YXJnZXQgID0gJ3RyYW5zZm9ybTonXG5cbiAgICAgIGJ1aWxkKClcblxuICAgICAgLyoqXG4gICAgICAgKiBCdWlsZCBhZ2FpbiBmb3Igd2Via2l0LlxuICAgICAgICovXG4gICAgICBpbml0aWFsICs9ICctd2Via2l0LXRyYW5zZm9ybTonXG4gICAgICB0YXJnZXQgICs9ICctd2Via2l0LXRyYW5zZm9ybTonXG5cbiAgICAgIGJ1aWxkKClcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICAgICAgICBpbml0aWFsOiAgICBpbml0aWFsLFxuICAgICAgICB0YXJnZXQ6ICAgICB0YXJnZXQsXG4gICAgICAgIHJlc2V0OiAgICAgIHJlc2V0LFxuICAgICAgICBpbmxpbmU6ICAgICBpbmxpbmUsXG4gICAgICAgIGR1cmF0aW9uOiAgICggKCBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy5vdmVyICkgKyBwYXJzZUZsb2F0KCBlbGVtLmNvbmZpZy53YWl0ICkgKSAqIDEwMDAgKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCB3b3JkcyApIHtcblxuICAgICAgdmFyIGZpbHRlcmVkICA9IFtdXG5cbiAgICAgIHZhciBzdWdhciA9IFtcblxuICAgICAgICAnZnJvbScsXG4gICAgICAgICd0aGUnLFxuICAgICAgICAnYW5kJyxcbiAgICAgICAgJ3RoZW4nLFxuICAgICAgICAnYnV0JyxcbiAgICAgICAgJ3dpdGgnLFxuICAgICAgICAncGxlYXNlJyxcbiAgICAgIF1cblxuICAgICAgd29yZHMuZm9yRWFjaChmdW5jdGlvbiggd29yZCApIHtcblxuICAgICAgICBpZiAoIHN1Z2FyLmluZGV4T2YoIHdvcmQgKSA+IC0xICkgcmV0dXJuXG5cbiAgICAgICAgZmlsdGVyZWQucHVzaCggd29yZCApXG4gICAgICAgIHJldHVyblxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGZpbHRlcmVkXG4gICAgfSxcblxuICAgIGdldFZpZXdwb3J0SDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBjbGllbnQgPSBzZWxmLmNvbmZpZy52aWV3cG9ydFsgJ2NsaWVudEhlaWdodCcgXVxuICAgICAgICAsIGlubmVyICA9IHdpbmRvd1sgJ2lubmVySGVpZ2h0JyBdXG5cbiAgICAgIGlmICggc2VsZi5jb25maWcudmlld3BvcnQgPT0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCApIHtcblxuICAgICAgICByZXR1cm4gKCBjbGllbnQgPCBpbm5lciApID8gaW5uZXIgOiBjbGllbnRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsaWVudFxuICAgIH0sXG5cbiAgICBzY3JvbGxZOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCBzZWxmLmNvbmZpZy52aWV3cG9ydCA9PSB3aW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICkgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldFxuXG4gICAgICByZXR1cm4gc2VsZi5jb25maWcudmlld3BvcnQuc2Nyb2xsVG9wICsgc2VsZi5jb25maWcudmlld3BvcnQub2Zmc2V0VG9wXG4gICAgfSxcblxuICAgIGdldE9mZnNldDogZnVuY3Rpb24oIGVsICkge1xuXG4gICAgICB2YXIgb2Zmc2V0VG9wICA9IDBcbiAgICAgICAgLCBvZmZzZXRMZWZ0ID0gMFxuXG4gICAgICBkbyB7XG5cbiAgICAgICAgaWYgKCAhaXNOYU4oIGVsLm9mZnNldFRvcCAgKSkgb2Zmc2V0VG9wICArPSBlbC5vZmZzZXRUb3BcbiAgICAgICAgaWYgKCAhaXNOYU4oIGVsLm9mZnNldExlZnQgKSkgb2Zmc2V0TGVmdCArPSBlbC5vZmZzZXRMZWZ0XG5cbiAgICAgIH0gd2hpbGUgKCBlbCA9IGVsLm9mZnNldFBhcmVudCApXG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnRcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNFbGVtSW5WaWV3cG9ydDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cbiAgICAgIHZhciBlbEhlaWdodCA9IGVsZW0uZG9tRWwub2Zmc2V0SGVpZ2h0XG4gICAgICAgICwgZWxUb3AgICAgPSBzZWxmLmdldE9mZnNldCggZWxlbS5kb21FbCApLnRvcFxuICAgICAgICAsIGVsQm90dG9tID0gZWxUb3AgKyBlbEhlaWdodFxuICAgICAgICAsIHZGYWN0b3IgID0gZWxlbS5jb25maWcudkZhY3RvciB8fCAwXG5cbiAgICAgIHJldHVybiAoIGVsVG9wICsgZWxIZWlnaHQgKiB2RmFjdG9yIDwgc2VsZi5zY3JvbGxlZCArIHNlbGYuZ2V0Vmlld3BvcnRIKCkgKVxuICAgICAgICAgICYmICggZWxCb3R0b20gLSBlbEhlaWdodCAqIHZGYWN0b3IgPiBzZWxmLnNjcm9sbGVkIClcbiAgICAgICAgICB8fCAoIGVsZW0uZG9tRWwuY3VycmVudFN0eWxlID8gZWxlbS5kb21FbC5jdXJyZW50U3R5bGUgOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbS5kb21FbCwgbnVsbCApICkucG9zaXRpb24gPT0gJ2ZpeGVkJ1xuICAgIH0sXG5cbiAgICBpc01vYmlsZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmFcblxuICAgICAgcmV0dXJuICgvKGlwYWR8cGxheWJvb2t8c2lsa3xhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIChjZXxwaG9uZSl8eGRhfHhpaW5vL2kudGVzdCggYWdlbnQgKXx8LzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdCggYWdlbnQuc3Vic3RyKCAwLCA0ICkpKSA/IHRydWUgOiBmYWxzZVxuICAgIH0sXG5cbiAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBzZW5zb3IgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc2Vuc29yJyApXG4gICAgICAgICwgY3NzUHJlZml4ID0gJ1dlYmtpdCxNb3osTywnLnNwbGl0KCAnLCcgKVxuICAgICAgICAsIHRlc3RzICAgICA9ICggJ3RyYW5zaXRpb24gJyArIGNzc1ByZWZpeC5qb2luKCAndHJhbnNpdGlvbiwnICkgKS5zcGxpdCggJywnIClcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgaWYgKCAhc2Vuc29yLnN0eWxlW3Rlc3RzW2ldXSA9PT0gJycgKSByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBxdWVyeVxuXG4gICAgICBxdWVyeSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBzZWxmLmNvbmZpZy52aWV3cG9ydC5xdWVyeVNlbGVjdG9yQWxsKCAnW2RhdGEtc3JdJyApIClcbiAgICAgIHF1ZXJ5LmZvckVhY2goZnVuY3Rpb24gKCBlbCApIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCAnZGF0YS1zcicgKVxuICAgICAgfSlcbiAgICB9XG5cbiAgfVxuXG4gIGhhbmRsZXIgPSBmdW5jdGlvbiggZSApIHtcblxuICAgIGlmICggIXNlbGYuYmxvY2tlZCApIHtcblxuICAgICAgc2VsZi5ibG9ja2VkICA9IHRydWVcbiAgICAgIHNlbGYuc2Nyb2xsZWQgPSBzZWxmLnNjcm9sbFkoKVxuXG4gICAgICBfcmVxdWVzdEFuaW1GcmFtZSggZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgc2VsZi5hbmltYXRlKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCwgc3JjICkge1xuXG4gICAgZm9yICggdmFyIHByb3AgaW4gc3JjICkge1xuXG4gICAgICBpZiAoIHNyYy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXG4gICAgICAgIHRhcmdldFsgcHJvcCBdID0gc3JjWyBwcm9wIF1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHBvbHlmaWxsLlxuICAgKi9cbiAgX3JlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgICAgfHxcbiAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSAgfHxcbiAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICAgfHxcblxuICAgICAgICAgIGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoIGNhbGxiYWNrLCAxMDAwIC8gNjAgKVxuICAgICAgICAgIH1cbiAgfSgpKVxuXG4gIHJldHVybiBzY3JvbGxSZXZlYWxcblxufSkoIHdpbmRvdyApXG5cbnJldHVybiBzY3JvbGxSZXZlYWw7XG5cbn0pKTtcbiJdfQ==
