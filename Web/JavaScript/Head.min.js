(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Head.min.js
 */

var WebFontJSONLoader = require('webfontjsonloader'),
    supportsWoff2 = require('./Utilities/Feature-Detects/Woff2.js'),
    webFontUrl = (supportsWoff2) ? 'WebFonts/DevButze.woff2.json': 'WebFonts/DevButze.woff.json';

// Load the WebFont.
new WebFontJSONLoader({
	url: webFontUrl,
	timeStamp: '?t=01152015',
    JSONPCallbackName:  'devButzeAttachFonts',
	namespace: 'devButze',
    callback: function() {
        console.log('Whee')
    }
});

// Require some polyfills
require('./Vendor/Polyfills/Html5shiv.js');
require('./Vendor/Polyfills/Picturefill.js');

},{"./Utilities/Feature-Detects/Woff2.js":2,"./Vendor/Polyfills/Html5shiv.js":3,"./Vendor/Polyfills/Picturefill.js":4,"webfontjsonloader":5}],2:[function(require,module,exports){
/**
 * supportsWoff2
 * @description A simple feature test for the WOFF2 font format.
 * @see https://github.com/filamentgroup/woff2-feature-test/blob/master/woff2.js
 */
var supportsWoff2 = (function(win){
    'use strict';

	if(!("FontFace" in win)) {
		return false;
	}

    var f = new win.FontFace("t", 'url( "data:application/font-woff2,4e" ) format( "woff2" )', {});
    f.load();

	return f.status === 'loading';
})(window);


module.exports = supportsWoff2;
},{}],3:[function(require,module,exports){
/**
 * @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
 */
;(function(window, document) {
    /*jshint evil:true */
    /** version */
    var version = '3.7.2';

    /** Preset options */
    var options = window.html5 || {};

    /** Used to skip problem elements */
    var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

    /** Not all elements can be cloned in IE **/
    var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

    /** Detect whether the browser supports default html5 styles */
    var supportsHtml5Styles;

    /** Name of the expando, to work with multiple documents or to re-shiv one document */
    var expando = '_html5shiv';

    /** The id for the the documents expando */
    var expanID = 0;

    /** Cached data for each document */
    var expandoData = {};

    /** Detect whether the browser supports unknown elements */
    var supportsUnknownElements;

    (function() {
        try {
            var a = document.createElement('a');
            a.innerHTML = '<xyz></xyz>';
            //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
            supportsHtml5Styles = ('hidden' in a);

            supportsUnknownElements = a.childNodes.length == 1 || (function() {
                // assign a false positive if unable to shiv
                (document.createElement)('a');
                var frag = document.createDocumentFragment();
                return (
                    typeof frag.cloneNode == 'undefined' ||
                        typeof frag.createDocumentFragment == 'undefined' ||
                        typeof frag.createElement == 'undefined'
                    );
            }());
        } catch(e) {
            // assign a false positive if detection fails => unable to shiv
            supportsHtml5Styles = true;
            supportsUnknownElements = true;
        }

    }());

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a style sheet with the given CSS text and adds it to the document.
     * @private
     * @param {Document} ownerDocument The document.
     * @param {String} cssText The CSS text.
     * @returns {StyleSheet} The style element.
     */
    function addStyleSheet(ownerDocument, cssText) {
        var p = ownerDocument.createElement('p'),
            parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

        p.innerHTML = 'x<style>' + cssText + '</style>';
        return parent.insertBefore(p.lastChild, parent.firstChild);
    }

    /**
     * Returns the value of `html5.elements` as an array.
     * @private
     * @returns {Array} An array of shived element node names.
     */
    function getElements() {
        var elements = html5.elements;
        return typeof elements == 'string' ? elements.split(' ') : elements;
    }

    /**
     * Extends the built-in list of html5 elements
     * @memberOf html5
     * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
     * @param {Document} ownerDocument The context document.
     */
    function addElements(newElements, ownerDocument) {
        var elements = html5.elements;
        if(typeof elements != 'string'){
            elements = elements.join(' ');
        }
        if(typeof newElements != 'string'){
            newElements = newElements.join(' ');
        }
        html5.elements = elements +' '+ newElements;
        shivDocument(ownerDocument);
    }

    /**
     * Returns the data associated to the given document
     * @private
     * @param {Document} ownerDocument The document.
     * @returns {Object} An object of data.
     */
    function getExpandoData(ownerDocument) {
        var data = expandoData[ownerDocument[expando]];
        if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
        }
        return data;
    }

    /**
     * returns a shived element for the given nodeName and document
     * @memberOf html5
     * @param {String} nodeName name of the element
     * @param {Document} ownerDocument The context document.
     * @returns {Object} The shived element.
     */
    function createElement(nodeName, ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createElement(nodeName);
        }
        if (!data) {
            data = getExpandoData(ownerDocument);
        }
        var node;

        if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
        } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
        } else {
            node = data.createElem(nodeName);
        }

        // Avoid adding some elements to fragments in IE < 9 because
        // * Attributes like `name` or `type` cannot be set/changed once an element
        //   is inserted into a document/fragment
        // * Link elements with `src` attributes that are inaccessible, as with
        //   a 403 response, will cause the tab/window to crash
        // * Script elements appended to fragments will execute when their `src`
        //   or `text` property is set
        return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
    }

    /**
     * returns a shived DocumentFragment for the given document
     * @memberOf html5
     * @param {Document} ownerDocument The context document.
     * @returns {Object} The shived DocumentFragment.
     */
    function createDocumentFragment(ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createDocumentFragment();
        }
        data = data || getExpandoData(ownerDocument);
        var clone = data.frag.cloneNode(),
            i = 0,
            elems = getElements(),
            l = elems.length;
        for(;i<l;i++){
            clone.createElement(elems[i]);
        }
        return clone;
    }

    /**
     * Shivs the `createElement` and `createDocumentFragment` methods of the document.
     * @private
     * @param {Document|DocumentFragment} ownerDocument The document.
     * @param {Object} data of the document.
     */
    function shivMethods(ownerDocument, data) {
        if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
        }


        ownerDocument.createElement = function(nodeName) {
            //abort shiv
            if (!html5.shivMethods) {
                return data.createElem(nodeName);
            }
            return createElement(nodeName, ownerDocument, data);
        };

        ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
            'var n=f.cloneNode(),c=n.createElement;' +
            'h.shivMethods&&(' +
            // unroll the `createElement` calls
            getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
                data.createElem(nodeName);
                data.frag.createElement(nodeName);
                return 'c("' + nodeName + '")';
            }) +
            ');return n}'
        )(html5, data.frag);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Shivs the given document.
     * @memberOf html5
     * @param {Document} ownerDocument The document to shiv.
     * @returns {Document} The shived document.
     */
    function shivDocument(ownerDocument) {
        if (!ownerDocument) {
            ownerDocument = document;
        }
        var data = getExpandoData(ownerDocument);

        if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
            data.hasCSS = !!addStyleSheet(ownerDocument,
                // corrects block display not defined in IE6/7/8/9
                'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
                    // adds styling not present in IE6/7/8/9
                    'mark{background:#FF0;color:#000}' +
                    // hides non-rendered elements
                    'template{display:none}'
            );
        }
        if (!supportsUnknownElements) {
            shivMethods(ownerDocument, data);
        }
        return ownerDocument;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * The `html5` object is exposed so that more elements can be shived and
     * existing shiving can be detected on iframes.
     * @type Object
     * @example
     *
     * // options can be changed before the script is included
     * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
     */
    var html5 = {

        /**
         * An array or space separated string of node names of the elements to shiv.
         * @memberOf html5
         * @type Array|String
         */
        'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

        /**
         * current version of html5shiv
         */
        'version': version,

        /**
         * A flag to indicate that the HTML5 style sheet should be inserted.
         * @memberOf html5
         * @type Boolean
         */
        'shivCSS': (options.shivCSS !== false),

        /**
         * Is equal to true if a browser supports creating unknown/HTML5 elements
         * @memberOf html5
         * @type boolean
         */
        'supportsUnknownElements': supportsUnknownElements,

        /**
         * A flag to indicate that the document's `createElement` and `createDocumentFragment`
         * methods should be overwritten.
         * @memberOf html5
         * @type Boolean
         */
        'shivMethods': (options.shivMethods !== false),

        /**
         * A string to describe the type of `html5` object ("default" or "default print").
         * @memberOf html5
         * @type String
         */
        'type': 'default',

        // shivs the document according to the specified `html5` object options
        'shivDocument': shivDocument,

        //creates a shived element
        createElement: createElement,

        //creates a shived documentFragment
        createDocumentFragment: createDocumentFragment,

        //extends list of elements
        addElements: addElements
    };

    /*--------------------------------------------------------------------------*/

    // expose html5
    window.html5 = html5;

    // shiv the document
    shivDocument(document);

}(this, document));
},{}],4:[function(require,module,exports){
/*! Picturefill - v2.2.0 - 2014-12-19
 * http://scottjehl.github.io/picturefill
 * Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
    "use strict";

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        script.parentNode.insertBefore(style, script);

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());
/*! Picturefill - Responsive Images that work today.
 *  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
 *  License: MIT/GPLv2
 *  Spec: http://picture.responsiveimages.org/
 */
(function( w, doc, image ) {
    // Enable strict mode
    "use strict";

    // If picture is supported, well, that's awesome. Let's get outta here...
    if ( w.HTMLPictureElement ) {
        w.picturefill = function() { };
        return;
    }

    // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
    doc.createElement( "picture" );

    // local object for method references and testing exposure
    var pf = w.picturefill || {};

    // namespace
    pf.ns = "picturefill";

    // srcset support test
    (function() {
        pf.srcsetSupported = "srcset" in image;
        pf.sizesSupported = "sizes" in image;
    })();

    // just a string trim workaround
    pf.trim = function( str ) {
        return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
    };

    // just a string endsWith workaround
    pf.endsWith = function( str, suffix ) {
        return str.endsWith ? str.endsWith( suffix ) : str.indexOf( suffix, str.length - suffix.length ) !== -1;
    };

    /**
     * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
     */
    pf.restrictsMixedContent = function() {
        return w.location.protocol === "https:";
    };
    /**
     * Shortcut method for matchMedia ( for easy overriding in tests )
     */

    pf.matchesMedia = function( media ) {
        return w.matchMedia && w.matchMedia( media ).matches;
    };

    // Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
    pf.getDpr = function() {
        return ( w.devicePixelRatio || 1 );
    };

    /**
     * Get width in css pixel value from a "length" value
     * http://dev.w3.org/csswg/css-values-3/#length-value
     */
    pf.getWidthFromLength = function( length ) {
        // If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, use the `100vw` default.
        length = length && length.indexOf( "%" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 ) ? length : "100vw";

        /**
         * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
         * is injected at the top of the document.
         *
         * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
         */
        length = length.replace( "vw", "%" );

        // Create a cached element for getting length value widths
        if ( !pf.lengthEl ) {
            pf.lengthEl = doc.createElement( "div" );

            // Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.
            pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden";
        }

        pf.lengthEl.style.width = length;

        doc.body.appendChild(pf.lengthEl);

        // Add a class, so that everyone knows where this element comes from
        pf.lengthEl.className = "helper-from-picturefill-js";

        if ( pf.lengthEl.offsetWidth <= 0 ) {
            // Something has gone wrong. `calc()` is in use and unsupported, most likely. Default to `100vw` (`100%`, for broader support.):
            pf.lengthEl.style.width = doc.documentElement.offsetWidth + "px";
        }

        var offsetWidth = pf.lengthEl.offsetWidth;

        doc.body.removeChild( pf.lengthEl );

        return offsetWidth;
    };

    pf.detectTypeSupport = function( type, typeUri ) {
        // based on Modernizr's lossless img-webp test
        // note: asynchronous
        var image = new w.Image();
        image.onerror = function() {
            pf.types[ type ] = false;
            picturefill();
        };
        image.onload = function() {
            pf.types[ type ] = image.width === 1;
            picturefill();
        };
        image.src = typeUri;

        return "pending";
    };
    // container of supported mime types that one might need to qualify before using
    pf.types = pf.types || {};

    // Add support for standard mime types
    pf.types[ "image/jpeg" ] = true;
    pf.types[ "image/gif" ] = true;
    pf.types[ "image/png" ] = true;
    pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
    pf.types[ "image/webp" ] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");

    pf.verifyTypeSupport = function( source ) {
        var type = source.getAttribute( "type" );
        // if type attribute exists, return test result, otherwise return true
        if ( type === null || type === "" ) {
            return true;
        } else {
            var pfType = pf.types[ type ];
            // if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
            if ( typeof pfType === "string" && pfType !== "pending") {
                pf.types[ type ] = pf.detectTypeSupport( type, pfType );
                return "pending";
            } else if ( typeof pfType === "function" ) {
                pfType();
                return "pending";
            } else {
                return pfType;
            }
        }
    };

    // Parses an individual `size` and returns the length, and optional media query
    pf.parseSize = function( sourceSizeStr ) {
        var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
        return {
            media: match && match[1],
            length: match && match[2]
        };
    };

    // Takes a string of sizes and returns the width in pixels as a number
    pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
        // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
        //                            or (min-width:30em) calc(30% - 15px)
        var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
            winningLength;

        for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
            // Match <media-condition>? length, ie ( min-width: 50em ) 100%
            var sourceSize = sourceSizeList[ i ],
            // Split "( min-width: 50em ) 100%" into separate strings
                parsedSize = pf.parseSize( sourceSize ),
                length = parsedSize.length,
                media = parsedSize.media;

            if ( !length ) {
                continue;
            }
            if ( !media || pf.matchesMedia( media ) ) {
                // if there is no media query or it matches, choose this as our winning length
                // and end algorithm
                winningLength = length;
                break;
            }
        }

        // pass the length to a method that can properly determine length
        // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
        return pf.getWidthFromLength( winningLength );
    };

    pf.parseSrcset = function( srcset ) {
        /**
         * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
         * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
         *
         * 1. Let input (`srcset`) be the value passed to this algorithm.
         * 2. Let position be a pointer into input, initially pointing at the start of the string.
         * 3. Let raw candidates be an initially empty ordered list of URLs with associated
         *    unparsed descriptors. The order of entries in the list is the order in which entries
         *    are added to the list.
         */
        var candidates = [];

        while ( srcset !== "" ) {
            srcset = srcset.replace( /^\s+/g, "" );

            // 5. Collect a sequence of characters that are not space characters, and let that be url.
            var pos = srcset.search(/\s/g),
                url, descriptor = null;

            if ( pos !== -1 ) {
                url = srcset.slice( 0, pos );

                var last = url.slice(-1);

                // 6. If url ends with a U+002C COMMA character (,), remove that character from url
                // and let descriptors be the empty string. Otherwise, follow these substeps
                // 6.1. If url is empty, then jump to the step labeled descriptor parser.

                if ( last === "," || url === "" ) {
                    url = url.replace( /,+$/, "" );
                    descriptor = "";
                }
                srcset = srcset.slice( pos + 1 );

                // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
                // let that be descriptors.
                if ( descriptor === null ) {
                    var descpos = srcset.indexOf( "," );
                    if ( descpos !== -1 ) {
                        descriptor = srcset.slice( 0, descpos );
                        srcset = srcset.slice( descpos + 1 );
                    } else {
                        descriptor = srcset;
                        srcset = "";
                    }
                }
            } else {
                url = srcset;
                srcset = "";
            }

            // 7. Add url to raw candidates, associated with descriptors.
            if ( url || descriptor ) {
                candidates.push({
                    url: url,
                    descriptor: descriptor
                });
            }
        }
        return candidates;
    };

    pf.parseDescriptor = function( descriptor, sizesattr ) {
        // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
        // is the order in which entries are added to the list.
        var sizes = sizesattr || "100vw",
            sizeDescriptor = descriptor && descriptor.replace( /(^\s+|\s+$)/g, "" ),
            widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
            resCandidate;

        if ( sizeDescriptor ) {
            var splitDescriptor = sizeDescriptor.split(" ");

            for (var i = splitDescriptor.length - 1; i >= 0; i--) {
                var curr = splitDescriptor[ i ],
                    lastchar = curr && curr.slice( curr.length - 1 );

                if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
                    resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
                } else if ( lastchar === "x" ) {
                    var res = curr && parseFloat( curr, 10 );
                    resCandidate = res && !isNaN( res ) ? res : 1;
                }
            }
        }
        return resCandidate || 1;
    };

    /**
     * Takes a srcset in the form of url/
     * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
     *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
     *     "images/pic-small.png"
     * Get an array of image candidates in the form of
     *      {url: "/foo/bar.png", resolution: 1}
     * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
     * If sizes is specified, resolution is calculated
     */
    pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
        var candidates = pf.parseSrcset( srcset ),
            formattedCandidates = [];

        for ( var i = 0, len = candidates.length; i < len; i++ ) {
            var candidate = candidates[ i ];

            formattedCandidates.push({
                url: candidate.url,
                resolution: pf.parseDescriptor( candidate.descriptor, sizes )
            });
        }
        return formattedCandidates;
    };

    /**
     * if it's an img element and it has a srcset property,
     * we need to remove the attribute so we can manipulate src
     * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
     * this moves srcset's value to memory for later use and removes the attr
     */
    pf.dodgeSrcset = function( img ) {
        if ( img.srcset ) {
            img[ pf.ns ].srcset = img.srcset;
            img.srcset = "";
            img.setAttribute( "data-pfsrcset", img[ pf.ns ].srcset );
        }
    };

    // Accept a source or img element and process its srcset and sizes attrs
    pf.processSourceSet = function( el ) {
        var srcset = el.getAttribute( "srcset" ),
            sizes = el.getAttribute( "sizes" ),
            candidates = [];

        // if it's an img element, use the cached srcset property (defined or not)
        if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
            srcset = el[ pf.ns ].srcset;
        }

        if ( srcset ) {
            candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
        }
        return candidates;
    };

    pf.backfaceVisibilityFix = function( picImg ) {
        // See: https://github.com/scottjehl/picturefill/issues/332
        var style = picImg.style || {},
            WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
            currentZoom = style.zoom;

        if (WebkitBackfaceVisibility) {
            style.zoom = ".999";

            WebkitBackfaceVisibility = picImg.offsetWidth;

            style.zoom = currentZoom;
        }
    };

    pf.setInherentSize = function( res, picImg, readyState ) {
        var ready = readyState !== undefined ? readyState : picImg.complete,
            widthPreset = !ready && picImg.getAttribute && picImg.getAttribute( "width" ) !== null,
            setWidth = function( res, picImg ) {
                if ( picImg.setAttribute ) {
                    picImg.setAttribute( "width", picImg.naturalWidth / res );
                }
            },
            widthInterval;

        if ( ready && res && !widthPreset ) {
            setWidth( res, picImg );
        }
        if ( !ready ) {
            widthInterval = setTimeout(function() {
                pf.setInherentSize( res, picImg, picImg.complete );
            }, 250);
        }
    };

    pf.applyBestCandidate = function( candidates, picImg ) {
        var candidate,
            length,
            bestCandidate;

        candidates.sort( pf.ascendingSort );

        length = candidates.length;
        bestCandidate = candidates[ length - 1 ];

        for ( var i = 0; i < length; i++ ) {
            candidate = candidates[ i ];
            if ( candidate.resolution >= pf.getDpr() ) {
                bestCandidate = candidate;
                break;
            }
        }

        if ( bestCandidate && !pf.endsWith( picImg.src, bestCandidate.url ) ) {
            if ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:" ) {
                if ( window.console !== undefined ) {
                    console.warn( "Blocked mixed content image " + bestCandidate.url );
                }
            } else {
                picImg.src = bestCandidate.url;
                // currentSrc attribute and property to match
                // http://picture.responsiveimages.org/#the-img-element
                picImg.currentSrc = picImg.src;

                pf.backfaceVisibilityFix( picImg );
                pf.setInherentSize( bestCandidate.resolution, picImg );
            }
        }
    };

    pf.ascendingSort = function( a, b ) {
        return a.resolution - b.resolution;
    };

    /**
     * In IE9, <source> elements get removed if they aren't children of
     * video elements. Thus, we conditionally wrap source elements
     * using <!--[if IE 9]><video style="display: none;"><![endif]-->
     * and must account for that here by moving those source elements
     * back into the picture element.
     */
    pf.removeVideoShim = function( picture ) {
        var videos = picture.getElementsByTagName( "video" );
        if ( videos.length ) {
            var video = videos[ 0 ],
                vsources = video.getElementsByTagName( "source" );
            while ( vsources.length ) {
                picture.insertBefore( vsources[ 0 ], video );
            }
            // Remove the video element once we're finished removing its children
            video.parentNode.removeChild( video );
        }
    };

    /**
     * Find all `img` elements, and add them to the candidate list if they have
     * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
     * a `srcset` attribute at all, and they haven’t been evaluated already.
     */
    pf.getAllElements = function() {
        var elems = [],
            imgs = doc.getElementsByTagName( "img" );

        for ( var h = 0, len = imgs.length; h < len; h++ ) {
            var currImg = imgs[ h ];

            if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
                ( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
                elems.push( currImg );
            }
        }
        return elems;
    };

    pf.getMatch = function( img, picture ) {
        var sources = picture.childNodes,
            match;

        // Go through each child, and if they have media queries, evaluate them
        for ( var j = 0, slen = sources.length; j < slen; j++ ) {
            var source = sources[ j ];

            // ignore non-element nodes
            if ( source.nodeType !== 1 ) {
                continue;
            }

            // Hitting the `img` element that started everything stops the search for `sources`.
            // If no previous `source` matches, the `img` itself is evaluated later.
            if ( source === img ) {
                return match;
            }

            // ignore non-`source` nodes
            if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
                continue;
            }
            // if it's a source element that has the `src` property set, throw a warning in the console
            if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ) {
                console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
            }

            var media = source.getAttribute( "media" );

            // if source does not have a srcset attribute, skip
            if ( !source.getAttribute( "srcset" ) ) {
                continue;
            }

            // if there's no media specified, OR w.matchMedia is supported
            if ( ( !media || pf.matchesMedia( media ) ) ) {
                var typeSupported = pf.verifyTypeSupport( source );

                if ( typeSupported === true ) {
                    match = source;
                    break;
                } else if ( typeSupported === "pending" ) {
                    return false;
                }
            }
        }

        return match;
    };

    function picturefill( opt ) {
        var elements,
            element,
            parent,
            firstMatch,
            candidates,
            options = opt || {};

        elements = options.elements || pf.getAllElements();

        // Loop through all elements
        for ( var i = 0, plen = elements.length; i < plen; i++ ) {
            element = elements[ i ];
            parent = element.parentNode;
            firstMatch = undefined;
            candidates = undefined;

            // immediately skip non-`img` nodes
            if ( element.nodeName.toUpperCase() !== "IMG" ) {
                continue;
            }

            // expando for caching data on the img
            if ( !element[ pf.ns ] ) {
                element[ pf.ns ] = {};
            }

            // if the element has already been evaluated, skip it unless
            // `options.reevaluate` is set to true ( this, for example,
            // is set to true when running `picturefill` on `resize` ).
            if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
                continue;
            }

            // if `img` is in a `picture` element
            if ( parent.nodeName.toUpperCase() === "PICTURE" ) {

                // IE9 video workaround
                pf.removeVideoShim( parent );

                // return the first match which might undefined
                // returns false if there is a pending source
                // TODO the return type here is brutal, cleanup
                firstMatch = pf.getMatch( element, parent );

                // if any sources are pending in this picture due to async type test(s)
                // remove the evaluated attr and skip for now ( the pending test will
                // rerun picturefill on this element when complete)
                if ( firstMatch === false ) {
                    continue;
                }
            } else {
                firstMatch = undefined;
            }

            // Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
            if ( parent.nodeName.toUpperCase() === "PICTURE" ||
                ( element.srcset && !pf.srcsetSupported ) ||
                ( !pf.sizesSupported && ( element.srcset && element.srcset.indexOf("w") > -1 ) ) ) {
                pf.dodgeSrcset( element );
            }

            if ( firstMatch ) {
                candidates = pf.processSourceSet( firstMatch );
                pf.applyBestCandidate( candidates, element );
            } else {
                // No sources matched, so we’re down to processing the inner `img` as a source.
                candidates = pf.processSourceSet( element );

                if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
                    // Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
                    pf.applyBestCandidate( candidates, element );
                } // Else, resolution-only `srcset` is supported natively.
            }

            // set evaluated to true to avoid unnecessary reparsing
            element[ pf.ns ].evaluated = true;
        }
    }

    /**
     * Sets up picture polyfill by polling the document and running
     * the polyfill every 250ms until the document is ready.
     * Also attaches picturefill on resize
     */
    function runPicturefill() {
        picturefill();
        var intervalId = setInterval( function() {
            // When the document has finished loading, stop checking for new images
            // https://github.com/ded/domready/blob/master/ready.js#L15
            picturefill();

            if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
                clearInterval( intervalId );
                return;
            }
        }, 250 );

        function checkResize() {
            var resizeThrottle;

            if ( !w._picturefillWorking ) {
                w._picturefillWorking = true;
                w.clearTimeout( resizeThrottle );
                resizeThrottle = w.setTimeout( function() {
                    picturefill({ reevaluate: true });
                    w._picturefillWorking = false;
                }, 60 );
            }
        }

        if ( w.addEventListener ) {
            w.addEventListener( "resize", checkResize, false );
        } else if ( w.attachEvent ) {
            w.attachEvent( "onresize", checkResize );
        }
    }

    runPicturefill();

    /* expose methods for testing */
    picturefill._ = pf;

    /* expose picturefill */
    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // CommonJS, just export
        module.exports = picturefill;
    } else if ( typeof define === "function" && define.amd ) {
        // AMD support
        define( function() { return picturefill; } );
    }

    if ( typeof w === "object" ) {
        // If no AMD and we are in the browser, attach to window
        w.picturefill = picturefill;
    }

} )( window, window.document, new window.Image() );
},{}],5:[function(require,module,exports){
"use strict";

/* WebFontJSONLoader 0.0.2 | @license ISC */

(function (global, factory) {
    // If the env is browserify, export the factory using the module object.
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global);

        // If the env is AMD, register the Module as 'webfontjsonloader'.
    } else if (typeof define === "function" && define.amd) {
        define("webfontjsonloader", [], function () {
            return factory(global);
        });

        // If the env is a browser(without CJS or AMD support), export the factory into the global window object.
    } else {
        global.WebFontLoader = factory(global);
    }
})(window, function (global) {
    var doc = global.document;
    var headElement = doc.getElementsByTagName("head")[0];
    var storage = global.localStorage;
    var srcKey = "_font_src";
    var timeStampKey = "_font_timestamp";

    /*
     * WebFontLoader
     * @param options {Object} The options Object which initializes the loader.
     * @example
     * new WebFontLoader({
     *      url: 'fonts/webfont.json', // Path to the JSONP file.
     *      timeStamp: '?t=01072015', // Timestamp for the cache.
     *      JSONPCallbackName:  'callback', //JSONP callback name.
     * });
     * @constructor
     */
    var WebFontLoader = function () {
        var options = arguments[0] === undefined ? {} : arguments[0];
        this.url = options.url;
        this.timeStamp = options.timeStamp || new Date();
        this.namespace = options.namespace || "WebFontJSONLoader";
        this.callback = options.callback;
        this.callbackName = options.JSONPCallbackName || "WebFontJsonCallBack";

        if (!this._hasRequiredConstantsAndAPIs()) {
            return;
        }

        this.getWebFontStyles();
    };

    WebFontLoader.prototype._hasRequiredConstantsAndAPIs = function () {
        var bool = true;

        if (!_supportsLocalStorageAPI()) {
            console.info("WebFontJSONLoader: This browser does not support the localStorage API, aborting.");

            bool = false;
        }
        if (!this.url) {
            console.info("WebFontJSONLoader: No URL was found in the options object, aborting.");

            bool = false;
        }

        return bool;
    };
    var _supportsLocalStorageAPI = function () {
        var key = "test";

        try {
            storage.setItem(key, 1);
            storage.removeItem(key);

            return true;
        } catch (e) {
            return false;
        }
    };

    WebFontLoader.prototype.getWebFontStyles = function () {
        if (this._isLocalStorageSrcValid()) {
            this._createInlineStyles()._executeCallBack();
        } else {
            this._getStylesFromJSONP();
        }
    };

    WebFontLoader.prototype._isLocalStorageSrcValid = function () {
        var namespace = this.namespace;

        return storage.getItem(namespace + srcKey) && storage.getItem(namespace + timeStampKey) === this.timeStamp;
    };

    WebFontLoader.prototype._executeCallBack = function () {
        var callback = this.callback;

        if (!callback) {
            return;
        }

        callback();
    };

    WebFontLoader.prototype._getStylesFromJSONP = function () {
        // Renew the timestamp.
        storage.setItem(this.namespace + timeStampKey, this.timeStamp);

        // Make the JSONP callback accessible.
        global[this.callbackName] = this._JSONPCallback.bind(this);

        // Load the JSONP and run the callback.
        this._loadJSONP();
    };

    WebFontLoader.prototype._JSONPCallback = function (res) {
        var css = res.css;

        // Create the localStorage cache.
        storage.setItem(this.namespace + srcKey, css);

        this._createInlineStyles();

        // Remove this function from the global namespace.
        global[this.callbackName] = undefined;

        return this;
    };

    WebFontLoader.prototype._loadJSONP = function () {
        // Create the script element.
        var script = doc.createElement("script");
        script.type = "text/javascript";
        script.src = this.url;
        headElement.appendChild(script);
        headElement.removeChild(script);

        // Execute the callback as the JSONP file was loaded.
        script.onload = this._executeCallBack.bind(this);

        return this;
    };

    WebFontLoader.prototype._createInlineStyles = function () {
        var namespace = this.namespace;
        var css = storage.getItem(namespace + srcKey);

        // Create the style element.
        var style = doc.createElement("style");
        style.type = "text/css";
        style.appendChild(doc.createTextNode(css));
        headElement.appendChild(style);

        return this;
    };

    return WebFontLoader;
});

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvSGVhZC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRmVhdHVyZS1EZXRlY3RzL1dvZmYyLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1ZlbmRvci9Qb2x5ZmlsbHMvSHRtbDVzaGl2LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1ZlbmRvci9Qb2x5ZmlsbHMvUGljdHVyZWZpbGwuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9ub2RlX21vZHVsZXMvd2ViZm9udGpzb25sb2FkZXIvRGlzdC9XZWJGb250SlNPTkxvYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBIZWFkLm1pbi5qc1xuICovXG5cbnZhciBXZWJGb250SlNPTkxvYWRlciA9IHJlcXVpcmUoJ3dlYmZvbnRqc29ubG9hZGVyJyksXG4gICAgc3VwcG9ydHNXb2ZmMiA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0ZlYXR1cmUtRGV0ZWN0cy9Xb2ZmMi5qcycpLFxuICAgIHdlYkZvbnRVcmwgPSAoc3VwcG9ydHNXb2ZmMikgPyAnV2ViRm9udHMvRGV2QnV0emUud29mZjIuanNvbic6ICdXZWJGb250cy9EZXZCdXR6ZS53b2ZmLmpzb24nO1xuXG4vLyBMb2FkIHRoZSBXZWJGb250LlxubmV3IFdlYkZvbnRKU09OTG9hZGVyKHtcblx0dXJsOiB3ZWJGb250VXJsLFxuXHR0aW1lU3RhbXA6ICc/dD0wMTE1MjAxNScsXG4gICAgSlNPTlBDYWxsYmFja05hbWU6ICAnZGV2QnV0emVBdHRhY2hGb250cycsXG5cdG5hbWVzcGFjZTogJ2RldkJ1dHplJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXaGVlJylcbiAgICB9XG59KTtcblxuLy8gUmVxdWlyZSBzb21lIHBvbHlmaWxsc1xucmVxdWlyZSgnLi9WZW5kb3IvUG9seWZpbGxzL0h0bWw1c2hpdi5qcycpO1xucmVxdWlyZSgnLi9WZW5kb3IvUG9seWZpbGxzL1BpY3R1cmVmaWxsLmpzJyk7XG4iLCIvKipcbiAqIHN1cHBvcnRzV29mZjJcbiAqIEBkZXNjcmlwdGlvbiBBIHNpbXBsZSBmZWF0dXJlIHRlc3QgZm9yIHRoZSBXT0ZGMiBmb250IGZvcm1hdC5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZpbGFtZW50Z3JvdXAvd29mZjItZmVhdHVyZS10ZXN0L2Jsb2IvbWFzdGVyL3dvZmYyLmpzXG4gKi9cbnZhciBzdXBwb3J0c1dvZmYyID0gKGZ1bmN0aW9uKHdpbil7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG5cdGlmKCEoXCJGb250RmFjZVwiIGluIHdpbikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuICAgIHZhciBmID0gbmV3IHdpbi5Gb250RmFjZShcInRcIiwgJ3VybCggXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjIsNGVcIiApIGZvcm1hdCggXCJ3b2ZmMlwiICknLCB7fSk7XG4gICAgZi5sb2FkKCk7XG5cblx0cmV0dXJuIGYuc3RhdHVzID09PSAnbG9hZGluZyc7XG59KSh3aW5kb3cpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNXb2ZmMjsiLCIvKipcbiAqIEBwcmVzZXJ2ZSBIVE1MNSBTaGl2IDMuNy4yIHwgQGFmYXJrYXMgQGpkYWx0b24gQGpvbl9uZWFsIEByZW0gfCBNSVQvR1BMMiBMaWNlbnNlZFxuICovXG47KGZ1bmN0aW9uKHdpbmRvdywgZG9jdW1lbnQpIHtcbiAgICAvKmpzaGludCBldmlsOnRydWUgKi9cbiAgICAvKiogdmVyc2lvbiAqL1xuICAgIHZhciB2ZXJzaW9uID0gJzMuNy4yJztcblxuICAgIC8qKiBQcmVzZXQgb3B0aW9ucyAqL1xuICAgIHZhciBvcHRpb25zID0gd2luZG93Lmh0bWw1IHx8IHt9O1xuXG4gICAgLyoqIFVzZWQgdG8gc2tpcCBwcm9ibGVtIGVsZW1lbnRzICovXG4gICAgdmFyIHJlU2tpcCA9IC9ePHxeKD86YnV0dG9ufG1hcHxzZWxlY3R8dGV4dGFyZWF8b2JqZWN0fGlmcmFtZXxvcHRpb258b3B0Z3JvdXApJC9pO1xuXG4gICAgLyoqIE5vdCBhbGwgZWxlbWVudHMgY2FuIGJlIGNsb25lZCBpbiBJRSAqKi9cbiAgICB2YXIgc2F2ZUNsb25lcyA9IC9eKD86YXxifGNvZGV8ZGl2fGZpZWxkc2V0fGgxfGgyfGgzfGg0fGg1fGg2fGl8bGFiZWx8bGl8b2x8cHxxfHNwYW58c3Ryb25nfHN0eWxlfHRhYmxlfHRib2R5fHRkfHRofHRyfHVsKSQvaTtcblxuICAgIC8qKiBEZXRlY3Qgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyBkZWZhdWx0IGh0bWw1IHN0eWxlcyAqL1xuICAgIHZhciBzdXBwb3J0c0h0bWw1U3R5bGVzO1xuXG4gICAgLyoqIE5hbWUgb2YgdGhlIGV4cGFuZG8sIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBkb2N1bWVudHMgb3IgdG8gcmUtc2hpdiBvbmUgZG9jdW1lbnQgKi9cbiAgICB2YXIgZXhwYW5kbyA9ICdfaHRtbDVzaGl2JztcblxuICAgIC8qKiBUaGUgaWQgZm9yIHRoZSB0aGUgZG9jdW1lbnRzIGV4cGFuZG8gKi9cbiAgICB2YXIgZXhwYW5JRCA9IDA7XG5cbiAgICAvKiogQ2FjaGVkIGRhdGEgZm9yIGVhY2ggZG9jdW1lbnQgKi9cbiAgICB2YXIgZXhwYW5kb0RhdGEgPSB7fTtcblxuICAgIC8qKiBEZXRlY3Qgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB1bmtub3duIGVsZW1lbnRzICovXG4gICAgdmFyIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzO1xuXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBhLmlubmVySFRNTCA9ICc8eHl6PjwveHl6Pic7XG4gICAgICAgICAgICAvL2lmIHRoZSBoaWRkZW4gcHJvcGVydHkgaXMgaW1wbGVtZW50ZWQgd2UgY2FuIGFzc3VtZSwgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyBiYXNpYyBIVE1MNSBTdHlsZXNcbiAgICAgICAgICAgIHN1cHBvcnRzSHRtbDVTdHlsZXMgPSAoJ2hpZGRlbicgaW4gYSk7XG5cbiAgICAgICAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gYS5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxIHx8IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiB1bmFibGUgdG8gc2hpdlxuICAgICAgICAgICAgICAgIChkb2N1bWVudC5jcmVhdGVFbGVtZW50KSgnYScpO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNsb25lTm9kZSA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZyYWcuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCA9PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZyYWcuY3JlYXRlRWxlbWVudCA9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBhc3NpZ24gYSBmYWxzZSBwb3NpdGl2ZSBpZiBkZXRlY3Rpb24gZmFpbHMgPT4gdW5hYmxlIHRvIHNoaXZcbiAgICAgICAgICAgIHN1cHBvcnRzSHRtbDVTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgc3VwcG9ydHNVbmtub3duRWxlbWVudHMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9KCkpO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3R5bGUgc2hlZXQgd2l0aCB0aGUgZ2l2ZW4gQ1NTIHRleHQgYW5kIGFkZHMgaXQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNzc1RleHQgVGhlIENTUyB0ZXh0LlxuICAgICAqIEByZXR1cm5zIHtTdHlsZVNoZWV0fSBUaGUgc3R5bGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRTdHlsZVNoZWV0KG93bmVyRG9jdW1lbnQsIGNzc1RleHQpIHtcbiAgICAgICAgdmFyIHAgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKSxcbiAgICAgICAgICAgIHBhcmVudCA9IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXSB8fCBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICBwLmlubmVySFRNTCA9ICd4PHN0eWxlPicgKyBjc3NUZXh0ICsgJzwvc3R5bGU+JztcbiAgICAgICAgcmV0dXJuIHBhcmVudC5pbnNlcnRCZWZvcmUocC5sYXN0Q2hpbGQsIHBhcmVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBgaHRtbDUuZWxlbWVudHNgIGFzIGFuIGFycmF5LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBzaGl2ZWQgZWxlbWVudCBub2RlIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRzKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBodG1sNS5lbGVtZW50cztcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50cyA9PSAnc3RyaW5nJyA/IGVsZW1lbnRzLnNwbGl0KCcgJykgOiBlbGVtZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmRzIHRoZSBidWlsdC1pbiBsaXN0IG9mIGh0bWw1IGVsZW1lbnRzXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG5ld0VsZW1lbnRzIHdoaXRlc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb3IgYXJyYXkgb2YgbmV3IGVsZW1lbnQgbmFtZXMgdG8gc2hpdlxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkRWxlbWVudHMobmV3RWxlbWVudHMsIG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgICAgIGlmKHR5cGVvZiBlbGVtZW50cyAhPSAnc3RyaW5nJyl7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0eXBlb2YgbmV3RWxlbWVudHMgIT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgbmV3RWxlbWVudHMgPSBuZXdFbGVtZW50cy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbDUuZWxlbWVudHMgPSBlbGVtZW50cyArJyAnKyBuZXdFbGVtZW50cztcbiAgICAgICAgc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBvZiBkYXRhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBleHBhbmRvRGF0YVtvd25lckRvY3VtZW50W2V4cGFuZG9dXTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICBleHBhbklEKys7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50W2V4cGFuZG9dID0gZXhwYW5JRDtcbiAgICAgICAgICAgIGV4cGFuZG9EYXRhW2V4cGFuSURdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEgc2hpdmVkIGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBub2RlTmFtZSBhbmQgZG9jdW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWUgbmFtZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGNvbnRleHQgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIHNoaXZlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobm9kZU5hbWUsIG93bmVyRG9jdW1lbnQsIGRhdGEpe1xuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZTtcblxuICAgICAgICBpZiAoZGF0YS5jYWNoZVtub2RlTmFtZV0pIHtcbiAgICAgICAgICAgIG5vZGUgPSBkYXRhLmNhY2hlW25vZGVOYW1lXS5jbG9uZU5vZGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzYXZlQ2xvbmVzLnRlc3Qobm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBub2RlID0gKGRhdGEuY2FjaGVbbm9kZU5hbWVdID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKSkuY2xvbmVOb2RlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF2b2lkIGFkZGluZyBzb21lIGVsZW1lbnRzIHRvIGZyYWdtZW50cyBpbiBJRSA8IDkgYmVjYXVzZVxuICAgICAgICAvLyAqIEF0dHJpYnV0ZXMgbGlrZSBgbmFtZWAgb3IgYHR5cGVgIGNhbm5vdCBiZSBzZXQvY2hhbmdlZCBvbmNlIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gICBpcyBpbnNlcnRlZCBpbnRvIGEgZG9jdW1lbnQvZnJhZ21lbnRcbiAgICAgICAgLy8gKiBMaW5rIGVsZW1lbnRzIHdpdGggYHNyY2AgYXR0cmlidXRlcyB0aGF0IGFyZSBpbmFjY2Vzc2libGUsIGFzIHdpdGhcbiAgICAgICAgLy8gICBhIDQwMyByZXNwb25zZSwgd2lsbCBjYXVzZSB0aGUgdGFiL3dpbmRvdyB0byBjcmFzaFxuICAgICAgICAvLyAqIFNjcmlwdCBlbGVtZW50cyBhcHBlbmRlZCB0byBmcmFnbWVudHMgd2lsbCBleGVjdXRlIHdoZW4gdGhlaXIgYHNyY2BcbiAgICAgICAgLy8gICBvciBgdGV4dGAgcHJvcGVydHkgaXMgc2V0XG4gICAgICAgIHJldHVybiBub2RlLmNhbkhhdmVDaGlsZHJlbiAmJiAhcmVTa2lwLnRlc3Qobm9kZU5hbWUpICYmICFub2RlLnRhZ1VybiA/IGRhdGEuZnJhZy5hcHBlbmRDaGlsZChub2RlKSA6IG5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHNoaXZlZCBEb2N1bWVudEZyYWdtZW50IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEb2N1bWVudEZyYWdtZW50KG93bmVyRG9jdW1lbnQsIGRhdGEpe1xuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZihzdXBwb3J0c1Vua25vd25FbGVtZW50cyl7XG4gICAgICAgICAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IGRhdGEgfHwgZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG4gICAgICAgIHZhciBjbG9uZSA9IGRhdGEuZnJhZy5jbG9uZU5vZGUoKSxcbiAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgZWxlbXMgPSBnZXRFbGVtZW50cygpLFxuICAgICAgICAgICAgbCA9IGVsZW1zLmxlbmd0aDtcbiAgICAgICAgZm9yKDtpPGw7aSsrKXtcbiAgICAgICAgICAgIGNsb25lLmNyZWF0ZUVsZW1lbnQoZWxlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGl2cyB0aGUgYGNyZWF0ZUVsZW1lbnRgIGFuZCBgY3JlYXRlRG9jdW1lbnRGcmFnbWVudGAgbWV0aG9kcyBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fERvY3VtZW50RnJhZ21lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGl2TWV0aG9kcyhvd25lckRvY3VtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YS5jYWNoZSkge1xuICAgICAgICAgICAgZGF0YS5jYWNoZSA9IHt9O1xuICAgICAgICAgICAgZGF0YS5jcmVhdGVFbGVtID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5jcmVhdGVGcmFnID0gb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50O1xuICAgICAgICAgICAgZGF0YS5mcmFnID0gZGF0YS5jcmVhdGVGcmFnKCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgICAgICAgICAvL2Fib3J0IHNoaXZcbiAgICAgICAgICAgIGlmICghaHRtbDUuc2hpdk1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBGdW5jdGlvbignaCxmJywgJ3JldHVybiBmdW5jdGlvbigpeycgK1xuICAgICAgICAgICAgJ3ZhciBuPWYuY2xvbmVOb2RlKCksYz1uLmNyZWF0ZUVsZW1lbnQ7JyArXG4gICAgICAgICAgICAnaC5zaGl2TWV0aG9kcyYmKCcgK1xuICAgICAgICAgICAgLy8gdW5yb2xsIHRoZSBgY3JlYXRlRWxlbWVudGAgY2FsbHNcbiAgICAgICAgICAgIGdldEVsZW1lbnRzKCkuam9pbigpLnJlcGxhY2UoL1tcXHdcXC06XSsvZywgZnVuY3Rpb24obm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmNyZWF0ZUVsZW0obm9kZU5hbWUpO1xuICAgICAgICAgICAgICAgIGRhdGEuZnJhZy5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2MoXCInICsgbm9kZU5hbWUgKyAnXCIpJztcbiAgICAgICAgICAgIH0pICtcbiAgICAgICAgICAgICcpO3JldHVybiBufSdcbiAgICAgICAgKShodG1sNSwgZGF0YS5mcmFnKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFNoaXZzIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudCB0byBzaGl2LlxuICAgICAqIEByZXR1cm5zIHtEb2N1bWVudH0gVGhlIHNoaXZlZCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaGl2RG9jdW1lbnQob3duZXJEb2N1bWVudCkge1xuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgIGlmIChodG1sNS5zaGl2Q1NTICYmICFzdXBwb3J0c0h0bWw1U3R5bGVzICYmICFkYXRhLmhhc0NTUykge1xuICAgICAgICAgICAgZGF0YS5oYXNDU1MgPSAhIWFkZFN0eWxlU2hlZXQob3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0cyBibG9jayBkaXNwbGF5IG5vdCBkZWZpbmVkIGluIElFNi83LzgvOVxuICAgICAgICAgICAgICAgICdhcnRpY2xlLGFzaWRlLGRpYWxvZyxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsaGVhZGVyLGhncm91cCxtYWluLG5hdixzZWN0aW9ue2Rpc3BsYXk6YmxvY2t9JyArXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZHMgc3R5bGluZyBub3QgcHJlc2VudCBpbiBJRTYvNy84LzlcbiAgICAgICAgICAgICAgICAgICAgJ21hcmt7YmFja2dyb3VuZDojRkYwO2NvbG9yOiMwMDB9JyArXG4gICAgICAgICAgICAgICAgICAgIC8vIGhpZGVzIG5vbi1yZW5kZXJlZCBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICAndGVtcGxhdGV7ZGlzcGxheTpub25lfSdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwb3J0c1Vua25vd25FbGVtZW50cykge1xuICAgICAgICAgICAgc2hpdk1ldGhvZHMob3duZXJEb2N1bWVudCwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYGh0bWw1YCBvYmplY3QgaXMgZXhwb3NlZCBzbyB0aGF0IG1vcmUgZWxlbWVudHMgY2FuIGJlIHNoaXZlZCBhbmRcbiAgICAgKiBleGlzdGluZyBzaGl2aW5nIGNhbiBiZSBkZXRlY3RlZCBvbiBpZnJhbWVzLlxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBvcHRpb25zIGNhbiBiZSBjaGFuZ2VkIGJlZm9yZSB0aGUgc2NyaXB0IGlzIGluY2x1ZGVkXG4gICAgICogaHRtbDUgPSB7ICdlbGVtZW50cyc6ICdtYXJrIHNlY3Rpb24nLCAnc2hpdkNTUyc6IGZhbHNlLCAnc2hpdk1ldGhvZHMnOiBmYWxzZSB9O1xuICAgICAqL1xuICAgIHZhciBodG1sNSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBub2RlIG5hbWVzIG9mIHRoZSBlbGVtZW50cyB0byBzaGl2LlxuICAgICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAgICogQHR5cGUgQXJyYXl8U3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICAnZWxlbWVudHMnOiBvcHRpb25zLmVsZW1lbnRzIHx8ICdhYmJyIGFydGljbGUgYXNpZGUgYXVkaW8gYmRpIGNhbnZhcyBkYXRhIGRhdGFsaXN0IGRldGFpbHMgZGlhbG9nIGZpZ2NhcHRpb24gZmlndXJlIGZvb3RlciBoZWFkZXIgaGdyb3VwIG1haW4gbWFyayBtZXRlciBuYXYgb3V0cHV0IHBpY3R1cmUgcHJvZ3Jlc3Mgc2VjdGlvbiBzdW1tYXJ5IHRlbXBsYXRlIHRpbWUgdmlkZW8nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjdXJyZW50IHZlcnNpb24gb2YgaHRtbDVzaGl2XG4gICAgICAgICAqL1xuICAgICAgICAndmVyc2lvbic6IHZlcnNpb24sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBIVE1MNSBzdHlsZSBzaGVldCBzaG91bGQgYmUgaW5zZXJ0ZWQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICAnc2hpdkNTUyc6IChvcHRpb25zLnNoaXZDU1MgIT09IGZhbHNlKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSXMgZXF1YWwgdG8gdHJ1ZSBpZiBhIGJyb3dzZXIgc3VwcG9ydHMgY3JlYXRpbmcgdW5rbm93bi9IVE1MNSBlbGVtZW50c1xuICAgICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAgICogQHR5cGUgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgJ3N1cHBvcnRzVW5rbm93bkVsZW1lbnRzJzogc3VwcG9ydHNVbmtub3duRWxlbWVudHMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBkb2N1bWVudCdzIGBjcmVhdGVFbGVtZW50YCBhbmQgYGNyZWF0ZURvY3VtZW50RnJhZ21lbnRgXG4gICAgICAgICAqIG1ldGhvZHMgc2hvdWxkIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgJ3NoaXZNZXRob2RzJzogKG9wdGlvbnMuc2hpdk1ldGhvZHMgIT09IGZhbHNlKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQSBzdHJpbmcgdG8gZGVzY3JpYmUgdGhlIHR5cGUgb2YgYGh0bWw1YCBvYmplY3QgKFwiZGVmYXVsdFwiIG9yIFwiZGVmYXVsdCBwcmludFwiKS5cbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgJ3R5cGUnOiAnZGVmYXVsdCcsXG5cbiAgICAgICAgLy8gc2hpdnMgdGhlIGRvY3VtZW50IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGBodG1sNWAgb2JqZWN0IG9wdGlvbnNcbiAgICAgICAgJ3NoaXZEb2N1bWVudCc6IHNoaXZEb2N1bWVudCxcblxuICAgICAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZWxlbWVudFxuICAgICAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuXG4gICAgICAgIC8vY3JlYXRlcyBhIHNoaXZlZCBkb2N1bWVudEZyYWdtZW50XG4gICAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQ6IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQsXG5cbiAgICAgICAgLy9leHRlbmRzIGxpc3Qgb2YgZWxlbWVudHNcbiAgICAgICAgYWRkRWxlbWVudHM6IGFkZEVsZW1lbnRzXG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gZXhwb3NlIGh0bWw1XG4gICAgd2luZG93Lmh0bWw1ID0gaHRtbDU7XG5cbiAgICAvLyBzaGl2IHRoZSBkb2N1bWVudFxuICAgIHNoaXZEb2N1bWVudChkb2N1bWVudCk7XG5cbn0odGhpcywgZG9jdW1lbnQpKTsiLCIvKiEgUGljdHVyZWZpbGwgLSB2Mi4yLjAgLSAyMDE0LTEyLTE5XG4gKiBodHRwOi8vc2NvdHRqZWhsLmdpdGh1Yi5pby9waWN0dXJlZmlsbFxuICogQ29weXJpZ2h0IChjKSAyMDE0IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7IExpY2Vuc2VkIE1JVCAqL1xuLyohIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy4gQXV0aG9ycyAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gRHVhbCBNSVQvQlNEIGxpY2Vuc2UgKi9cblxud2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxuICAgIHZhciBzdHlsZU1lZGlhID0gKHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYSk7XG5cbiAgICAvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXG4gICAgaWYgKCFzdHlsZU1lZGlhKSB7XG4gICAgICAgIHZhciBzdHlsZSAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgICAgICAgICBzY3JpcHQgICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICAgICAgICAgIGluZm8gICAgICAgID0gbnVsbDtcblxuICAgICAgICBzdHlsZS50eXBlICA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIHN0eWxlLmlkICAgID0gJ21hdGNobWVkaWFqcy10ZXN0JztcblxuICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG5cbiAgICAgICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgaW5mbyA9ICgnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gd2luZG93KSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuXG4gICAgICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICAgICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICdAbWVkaWEgJyArIG1lZGlhICsgJ3sgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9JztcblxuICAgICAgICAgICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgICAgIH07XG4gICAgfTtcbn0oKSk7XG4vKiEgUGljdHVyZWZpbGwgLSBSZXNwb25zaXZlIEltYWdlcyB0aGF0IHdvcmsgdG9kYXkuXG4gKiAgQXV0aG9yOiBTY290dCBKZWhsLCBGaWxhbWVudCBHcm91cCwgMjAxMiAoIG5ldyBwcm9wb3NhbCBpbXBsZW1lbnRlZCBieSBTaGF3biBKYW5zZXBhciApXG4gKiAgTGljZW5zZTogTUlUL0dQTHYyXG4gKiAgU3BlYzogaHR0cDovL3BpY3R1cmUucmVzcG9uc2l2ZWltYWdlcy5vcmcvXG4gKi9cbihmdW5jdGlvbiggdywgZG9jLCBpbWFnZSApIHtcbiAgICAvLyBFbmFibGUgc3RyaWN0IG1vZGVcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIElmIHBpY3R1cmUgaXMgc3VwcG9ydGVkLCB3ZWxsLCB0aGF0J3MgYXdlc29tZS4gTGV0J3MgZ2V0IG91dHRhIGhlcmUuLi5cbiAgICBpZiAoIHcuSFRNTFBpY3R1cmVFbGVtZW50ICkge1xuICAgICAgICB3LnBpY3R1cmVmaWxsID0gZnVuY3Rpb24oKSB7IH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIVE1MIHNoaW18diBpdCBmb3Igb2xkIElFIChJRTkgd2lsbCBzdGlsbCBuZWVkIHRoZSBIVE1MIHZpZGVvIHRhZyB3b3JrYXJvdW5kKVxuICAgIGRvYy5jcmVhdGVFbGVtZW50KCBcInBpY3R1cmVcIiApO1xuXG4gICAgLy8gbG9jYWwgb2JqZWN0IGZvciBtZXRob2QgcmVmZXJlbmNlcyBhbmQgdGVzdGluZyBleHBvc3VyZVxuICAgIHZhciBwZiA9IHcucGljdHVyZWZpbGwgfHwge307XG5cbiAgICAvLyBuYW1lc3BhY2VcbiAgICBwZi5ucyA9IFwicGljdHVyZWZpbGxcIjtcblxuICAgIC8vIHNyY3NldCBzdXBwb3J0IHRlc3RcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHBmLnNyY3NldFN1cHBvcnRlZCA9IFwic3Jjc2V0XCIgaW4gaW1hZ2U7XG4gICAgICAgIHBmLnNpemVzU3VwcG9ydGVkID0gXCJzaXplc1wiIGluIGltYWdlO1xuICAgIH0pKCk7XG5cbiAgICAvLyBqdXN0IGEgc3RyaW5nIHRyaW0gd29ya2Fyb3VuZFxuICAgIHBmLnRyaW0gPSBmdW5jdGlvbiggc3RyICkge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCBcIlwiICk7XG4gICAgfTtcblxuICAgIC8vIGp1c3QgYSBzdHJpbmcgZW5kc1dpdGggd29ya2Fyb3VuZFxuICAgIHBmLmVuZHNXaXRoID0gZnVuY3Rpb24oIHN0ciwgc3VmZml4ICkge1xuICAgICAgICByZXR1cm4gc3RyLmVuZHNXaXRoID8gc3RyLmVuZHNXaXRoKCBzdWZmaXggKSA6IHN0ci5pbmRleE9mKCBzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoICkgIT09IC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgZm9yIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMvc3BlY3MvbWl4ZWRjb250ZW50LyNyZXN0cmljdHMtbWl4ZWQtY29udGVudCAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgICAqL1xuICAgIHBmLnJlc3RyaWN0c01peGVkQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCBmb3IgbWF0Y2hNZWRpYSAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgICAqL1xuXG4gICAgcGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oIG1lZGlhICkge1xuICAgICAgICByZXR1cm4gdy5tYXRjaE1lZGlhICYmIHcubWF0Y2hNZWRpYSggbWVkaWEgKS5tYXRjaGVzO1xuICAgIH07XG5cbiAgICAvLyBTaG9ydGN1dCBtZXRob2QgZm9yIGBkZXZpY2VQaXhlbFJhdGlvYCAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgIHBmLmdldERwciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKCB3LmRldmljZVBpeGVsUmF0aW8gfHwgMSApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2lkdGggaW4gY3NzIHBpeGVsIHZhbHVlIGZyb20gYSBcImxlbmd0aFwiIHZhbHVlXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXZhbHVlcy0zLyNsZW5ndGgtdmFsdWVcbiAgICAgKi9cbiAgICBwZi5nZXRXaWR0aEZyb21MZW5ndGggPSBmdW5jdGlvbiggbGVuZ3RoICkge1xuICAgICAgICAvLyBJZiBhIGxlbmd0aCBpcyBzcGVjaWZpZWQgYW5kIGRvZXNu4oCZdCBjb250YWluIGEgcGVyY2VudGFnZSwgYW5kIGl0IGlzIGdyZWF0ZXIgdGhhbiAwIG9yIHVzaW5nIGBjYWxjYCwgdXNlIGl0LiBFbHNlLCB1c2UgdGhlIGAxMDB2d2AgZGVmYXVsdC5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoICYmIGxlbmd0aC5pbmRleE9mKCBcIiVcIiApID4gLTEgPT09IGZhbHNlICYmICggcGFyc2VGbG9hdCggbGVuZ3RoICkgPiAwIHx8IGxlbmd0aC5pbmRleE9mKCBcImNhbGMoXCIgKSA+IC0xICkgPyBsZW5ndGggOiBcIjEwMHZ3XCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxlbmd0aCBpcyBzcGVjaWZpZWQgaW4gIGB2d2AgdW5pdHMsIHVzZSBgJWAgaW5zdGVhZCBzaW5jZSB0aGUgZGl2IHdl4oCZcmUgbWVhc3VyaW5nXG4gICAgICAgICAqIGlzIGluamVjdGVkIGF0IHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBtYXliZSB3ZSBzaG91bGQgcHV0IHRoaXMgYmVoaW5kIGEgZmVhdHVyZSB0ZXN0IGZvciBgdndgPyBUaGUgcmlzayBvZiBkb2luZyB0aGlzIGlzIHBvc3NpYmxlIGJyb3dzZXIgaW5jb25zaXN0YW5jaWVzIHdpdGggdncgdnMgJVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoLnJlcGxhY2UoIFwidndcIiwgXCIlXCIgKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBjYWNoZWQgZWxlbWVudCBmb3IgZ2V0dGluZyBsZW5ndGggdmFsdWUgd2lkdGhzXG4gICAgICAgIGlmICggIXBmLmxlbmd0aEVsICkge1xuICAgICAgICAgICAgcGYubGVuZ3RoRWwgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbmluZyBzdHlsZXMgaGVscCBwcmV2ZW50IHBhZGRpbmcvbWFyZ2luL3dpZHRoIG9uIGBodG1sYCBvciBgYm9keWAgZnJvbSB0aHJvd2luZyBjYWxjdWxhdGlvbnMgb2ZmLlxuICAgICAgICAgICAgcGYubGVuZ3RoRWwuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7ZGlzcGxheTpibG9jaztmb250LXNpemU6MWVtO2xlZnQ6MDttYXJnaW46MDtwYWRkaW5nOjA7cG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBmLmxlbmd0aEVsLnN0eWxlLndpZHRoID0gbGVuZ3RoO1xuXG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHBmLmxlbmd0aEVsKTtcblxuICAgICAgICAvLyBBZGQgYSBjbGFzcywgc28gdGhhdCBldmVyeW9uZSBrbm93cyB3aGVyZSB0aGlzIGVsZW1lbnQgY29tZXMgZnJvbVxuICAgICAgICBwZi5sZW5ndGhFbC5jbGFzc05hbWUgPSBcImhlbHBlci1mcm9tLXBpY3R1cmVmaWxsLWpzXCI7XG5cbiAgICAgICAgaWYgKCBwZi5sZW5ndGhFbC5vZmZzZXRXaWR0aCA8PSAwICkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGhhcyBnb25lIHdyb25nLiBgY2FsYygpYCBpcyBpbiB1c2UgYW5kIHVuc3VwcG9ydGVkLCBtb3N0IGxpa2VseS4gRGVmYXVsdCB0byBgMTAwdndgIChgMTAwJWAsIGZvciBicm9hZGVyIHN1cHBvcnQuKTpcbiAgICAgICAgICAgIHBmLmxlbmd0aEVsLnN0eWxlLndpZHRoID0gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHBmLmxlbmd0aEVsLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKCBwZi5sZW5ndGhFbCApO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXRXaWR0aDtcbiAgICB9O1xuXG4gICAgcGYuZGV0ZWN0VHlwZVN1cHBvcnQgPSBmdW5jdGlvbiggdHlwZSwgdHlwZVVyaSApIHtcbiAgICAgICAgLy8gYmFzZWQgb24gTW9kZXJuaXpyJ3MgbG9zc2xlc3MgaW1nLXdlYnAgdGVzdFxuICAgICAgICAvLyBub3RlOiBhc3luY2hyb25vdXNcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IHcuSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGYudHlwZXNbIHR5cGUgXSA9IGZhbHNlO1xuICAgICAgICAgICAgcGljdHVyZWZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwZi50eXBlc1sgdHlwZSBdID0gaW1hZ2Uud2lkdGggPT09IDE7XG4gICAgICAgICAgICBwaWN0dXJlZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSB0eXBlVXJpO1xuXG4gICAgICAgIHJldHVybiBcInBlbmRpbmdcIjtcbiAgICB9O1xuICAgIC8vIGNvbnRhaW5lciBvZiBzdXBwb3J0ZWQgbWltZSB0eXBlcyB0aGF0IG9uZSBtaWdodCBuZWVkIHRvIHF1YWxpZnkgYmVmb3JlIHVzaW5nXG4gICAgcGYudHlwZXMgPSBwZi50eXBlcyB8fCB7fTtcblxuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBzdGFuZGFyZCBtaW1lIHR5cGVzXG4gICAgcGYudHlwZXNbIFwiaW1hZ2UvanBlZ1wiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL2dpZlwiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3BuZ1wiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3N2Zyt4bWxcIiBdID0gZG9jLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0ltYWdlXCIsIFwiMS4xXCIpO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3dlYnBcIiBdID0gcGYuZGV0ZWN0VHlwZVN1cHBvcnQoXCJpbWFnZS93ZWJwXCIsIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QUFBQUFBZlEvLzczdi8rQmlPaC9BQUE9XCIpO1xuXG4gICAgcGYudmVyaWZ5VHlwZVN1cHBvcnQgPSBmdW5jdGlvbiggc291cmNlICkge1xuICAgICAgICB2YXIgdHlwZSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG4gICAgICAgIC8vIGlmIHR5cGUgYXR0cmlidXRlIGV4aXN0cywgcmV0dXJuIHRlc3QgcmVzdWx0LCBvdGhlcndpc2UgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKCB0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwZlR5cGUgPSBwZi50eXBlc1sgdHlwZSBdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHR5cGUgdGVzdCBpcyBhIGZ1bmN0aW9uLCBydW4gaXQgYW5kIHJldHVybiBcInBlbmRpbmdcIiBzdGF0dXMuIFRoZSBmdW5jdGlvbiB3aWxsIHJlcnVuIHBpY3R1cmVmaWxsIG9uIHBlbmRpbmcgZWxlbWVudHMgb25jZSBmaW5pc2hlZC5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHBmVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBwZlR5cGUgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGYudHlwZXNbIHR5cGUgXSA9IHBmLmRldGVjdFR5cGVTdXBwb3J0KCB0eXBlLCBwZlR5cGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgcGZUeXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgcGZUeXBlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGZUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhbiBpbmRpdmlkdWFsIGBzaXplYCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoLCBhbmQgb3B0aW9uYWwgbWVkaWEgcXVlcnlcbiAgICBwZi5wYXJzZVNpemUgPSBmdW5jdGlvbiggc291cmNlU2l6ZVN0ciApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gLyhcXChbXildK1xcKSk/XFxzKiguKykvZy5leGVjKCBzb3VyY2VTaXplU3RyICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYTogbWF0Y2ggJiYgbWF0Y2hbMV0sXG4gICAgICAgICAgICBsZW5ndGg6IG1hdGNoICYmIG1hdGNoWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFRha2VzIGEgc3RyaW5nIG9mIHNpemVzIGFuZCByZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgYXMgYSBudW1iZXJcbiAgICBwZi5maW5kV2lkdGhGcm9tU291cmNlU2l6ZSA9IGZ1bmN0aW9uKCBzb3VyY2VTaXplTGlzdFN0ciApIHtcbiAgICAgICAgLy8gU3BsaXQgdXAgc291cmNlIHNpemUgbGlzdCwgaWUgKCBtYXgtd2lkdGg6IDMwZW0gKSAxMDAlLCAoIG1heC13aWR0aDogNTBlbSApIDUwJSwgMzMlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIChtaW4td2lkdGg6MzBlbSkgY2FsYygzMCUgLSAxNXB4KVxuICAgICAgICB2YXIgc291cmNlU2l6ZUxpc3QgPSBwZi50cmltKCBzb3VyY2VTaXplTGlzdFN0ciApLnNwbGl0KCAvXFxzKixcXHMqLyApLFxuICAgICAgICAgICAgd2lubmluZ0xlbmd0aDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZVNpemVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgLy8gTWF0Y2ggPG1lZGlhLWNvbmRpdGlvbj4/IGxlbmd0aCwgaWUgKCBtaW4td2lkdGg6IDUwZW0gKSAxMDAlXG4gICAgICAgICAgICB2YXIgc291cmNlU2l6ZSA9IHNvdXJjZVNpemVMaXN0WyBpIF0sXG4gICAgICAgICAgICAvLyBTcGxpdCBcIiggbWluLXdpZHRoOiA1MGVtICkgMTAwJVwiIGludG8gc2VwYXJhdGUgc3RyaW5nc1xuICAgICAgICAgICAgICAgIHBhcnNlZFNpemUgPSBwZi5wYXJzZVNpemUoIHNvdXJjZVNpemUgKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBwYXJzZWRTaXplLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtZWRpYSA9IHBhcnNlZFNpemUubWVkaWE7XG5cbiAgICAgICAgICAgIGlmICggIWxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIW1lZGlhIHx8IHBmLm1hdGNoZXNNZWRpYSggbWVkaWEgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBtZWRpYSBxdWVyeSBvciBpdCBtYXRjaGVzLCBjaG9vc2UgdGhpcyBhcyBvdXIgd2lubmluZyBsZW5ndGhcbiAgICAgICAgICAgICAgICAvLyBhbmQgZW5kIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgIHdpbm5pbmdMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXNzIHRoZSBsZW5ndGggdG8gYSBtZXRob2QgdGhhdCBjYW4gcHJvcGVybHkgZGV0ZXJtaW5lIGxlbmd0aFxuICAgICAgICAvLyBpbiBwaXhlbHMgYmFzZWQgb24gdGhlc2UgZm9ybWF0czogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXZhbHVlcy0zLyNsZW5ndGgtdmFsdWVcbiAgICAgICAgcmV0dXJuIHBmLmdldFdpZHRoRnJvbUxlbmd0aCggd2lubmluZ0xlbmd0aCApO1xuICAgIH07XG5cbiAgICBwZi5wYXJzZVNyY3NldCA9IGZ1bmN0aW9uKCBzcmNzZXQgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxvdCBvZiB0aGlzIHdhcyBwdWxsZWQgZnJvbSBCb3JpcyBTbXVz4oCZIHBhcnNlciBmb3IgdGhlIG5vdy1kZWZ1bmN0IFdIQVRXRyBgc3Jjc2V0YFxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYm9yaXNtdXMvc3Jjc2V0LXBvbHlmaWxsL2Jsb2IvbWFzdGVyL2pzL3NyY3NldC1pbmZvLmpzXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuIExldCBpbnB1dCAoYHNyY3NldGApIGJlIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhpcyBhbGdvcml0aG0uXG4gICAgICAgICAqIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvaW50ZXIgaW50byBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICAgKiAzLiBMZXQgcmF3IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IG9yZGVyZWQgbGlzdCBvZiBVUkxzIHdpdGggYXNzb2NpYXRlZFxuICAgICAgICAgKiAgICB1bnBhcnNlZCBkZXNjcmlwdG9ycy4gVGhlIG9yZGVyIG9mIGVudHJpZXMgaW4gdGhlIGxpc3QgaXMgdGhlIG9yZGVyIGluIHdoaWNoIGVudHJpZXNcbiAgICAgICAgICogICAgYXJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoIHNyY3NldCAhPT0gXCJcIiApIHtcbiAgICAgICAgICAgIHNyY3NldCA9IHNyY3NldC5yZXBsYWNlKCAvXlxccysvZywgXCJcIiApO1xuXG4gICAgICAgICAgICAvLyA1LiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3Qgc3BhY2UgY2hhcmFjdGVycywgYW5kIGxldCB0aGF0IGJlIHVybC5cbiAgICAgICAgICAgIHZhciBwb3MgPSBzcmNzZXQuc2VhcmNoKC9cXHMvZyksXG4gICAgICAgICAgICAgICAgdXJsLCBkZXNjcmlwdG9yID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCBwb3MgIT09IC0xICkge1xuICAgICAgICAgICAgICAgIHVybCA9IHNyY3NldC5zbGljZSggMCwgcG9zICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHVybC5zbGljZSgtMSk7XG5cbiAgICAgICAgICAgICAgICAvLyA2LiBJZiB1cmwgZW5kcyB3aXRoIGEgVSswMDJDIENPTU1BIGNoYXJhY3RlciAoLCksIHJlbW92ZSB0aGF0IGNoYXJhY3RlciBmcm9tIHVybFxuICAgICAgICAgICAgICAgIC8vIGFuZCBsZXQgZGVzY3JpcHRvcnMgYmUgdGhlIGVtcHR5IHN0cmluZy4gT3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHNcbiAgICAgICAgICAgICAgICAvLyA2LjEuIElmIHVybCBpcyBlbXB0eSwgdGhlbiBqdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cbiAgICAgICAgICAgICAgICBpZiAoIGxhc3QgPT09IFwiLFwiIHx8IHVybCA9PT0gXCJcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoIC8sKyQvLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcmNzZXQgPSBzcmNzZXQuc2xpY2UoIHBvcyArIDEgKTtcblxuICAgICAgICAgICAgICAgIC8vIDYuMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzICgsKSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRoYXQgYmUgZGVzY3JpcHRvcnMuXG4gICAgICAgICAgICAgICAgaWYgKCBkZXNjcmlwdG9yID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3BvcyA9IHNyY3NldC5pbmRleE9mKCBcIixcIiApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlc2Nwb3MgIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IHNyY3NldC5zbGljZSggMCwgZGVzY3BvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Jjc2V0ID0gc3Jjc2V0LnNsaWNlKCBkZXNjcG9zICsgMSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IHNyY3NldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY3NldCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IHNyY3NldDtcbiAgICAgICAgICAgICAgICBzcmNzZXQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA3LiBBZGQgdXJsIHRvIHJhdyBjYW5kaWRhdGVzLCBhc3NvY2lhdGVkIHdpdGggZGVzY3JpcHRvcnMuXG4gICAgICAgICAgICBpZiAoIHVybCB8fCBkZXNjcmlwdG9yICkge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIHBmLnBhcnNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uKCBkZXNjcmlwdG9yLCBzaXplc2F0dHIgKSB7XG4gICAgICAgIC8vIDExLiBEZXNjcmlwdG9yIHBhcnNlcjogTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuIFRoZSBvcmRlciBvZiBlbnRyaWVzIGluIHRoZSBsaXN0XG4gICAgICAgIC8vIGlzIHRoZSBvcmRlciBpbiB3aGljaCBlbnRyaWVzIGFyZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgICAgdmFyIHNpemVzID0gc2l6ZXNhdHRyIHx8IFwiMTAwdndcIixcbiAgICAgICAgICAgIHNpemVEZXNjcmlwdG9yID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnJlcGxhY2UoIC8oXlxccyt8XFxzKyQpL2csIFwiXCIgKSxcbiAgICAgICAgICAgIHdpZHRoSW5Dc3NQaXhlbHMgPSBwZi5maW5kV2lkdGhGcm9tU291cmNlU2l6ZSggc2l6ZXMgKSxcbiAgICAgICAgICAgIHJlc0NhbmRpZGF0ZTtcblxuICAgICAgICBpZiAoIHNpemVEZXNjcmlwdG9yICkge1xuICAgICAgICAgICAgdmFyIHNwbGl0RGVzY3JpcHRvciA9IHNpemVEZXNjcmlwdG9yLnNwbGl0KFwiIFwiKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNwbGl0RGVzY3JpcHRvci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyID0gc3BsaXREZXNjcmlwdG9yWyBpIF0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RjaGFyID0gY3VyciAmJiBjdXJyLnNsaWNlKCBjdXJyLmxlbmd0aCAtIDEgKTtcblxuICAgICAgICAgICAgICAgIGlmICggKCBsYXN0Y2hhciA9PT0gXCJoXCIgfHwgbGFzdGNoYXIgPT09IFwid1wiICkgJiYgIXBmLnNpemVzU3VwcG9ydGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXNDYW5kaWRhdGUgPSBwYXJzZUZsb2F0KCAoIHBhcnNlSW50KCBjdXJyLCAxMCApIC8gd2lkdGhJbkNzc1BpeGVscyApICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbGFzdGNoYXIgPT09IFwieFwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gY3VyciAmJiBwYXJzZUZsb2F0KCBjdXJyLCAxMCApO1xuICAgICAgICAgICAgICAgICAgICByZXNDYW5kaWRhdGUgPSByZXMgJiYgIWlzTmFOKCByZXMgKSA/IHJlcyA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNDYW5kaWRhdGUgfHwgMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBzcmNzZXQgaW4gdGhlIGZvcm0gb2YgdXJsL1xuICAgICAqIGV4LiBcImltYWdlcy9waWMtbWVkaXVtLnBuZyAxeCwgaW1hZ2VzL3BpYy1tZWRpdW0tMngucG5nIDJ4XCIgb3JcbiAgICAgKiAgICAgXCJpbWFnZXMvcGljLW1lZGl1bS5wbmcgNDAwdywgaW1hZ2VzL3BpYy1tZWRpdW0tMngucG5nIDgwMHdcIiBvclxuICAgICAqICAgICBcImltYWdlcy9waWMtc21hbGwucG5nXCJcbiAgICAgKiBHZXQgYW4gYXJyYXkgb2YgaW1hZ2UgY2FuZGlkYXRlcyBpbiB0aGUgZm9ybSBvZlxuICAgICAqICAgICAge3VybDogXCIvZm9vL2Jhci5wbmdcIiwgcmVzb2x1dGlvbjogMX1cbiAgICAgKiB3aGVyZSByZXNvbHV0aW9uIGlzIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jcmVzb2x1dGlvbi12YWx1ZVxuICAgICAqIElmIHNpemVzIGlzIHNwZWNpZmllZCwgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkXG4gICAgICovXG4gICAgcGYuZ2V0Q2FuZGlkYXRlc0Zyb21Tb3VyY2VTZXQgPSBmdW5jdGlvbiggc3Jjc2V0LCBzaXplcyApIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBwZi5wYXJzZVNyY3NldCggc3Jjc2V0ICksXG4gICAgICAgICAgICBmb3JtYXR0ZWRDYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBjYW5kaWRhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcblxuICAgICAgICAgICAgZm9ybWF0dGVkQ2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmw6IGNhbmRpZGF0ZS51cmwsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogcGYucGFyc2VEZXNjcmlwdG9yKCBjYW5kaWRhdGUuZGVzY3JpcHRvciwgc2l6ZXMgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZENhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGlmIGl0J3MgYW4gaW1nIGVsZW1lbnQgYW5kIGl0IGhhcyBhIHNyY3NldCBwcm9wZXJ0eSxcbiAgICAgKiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHNyY1xuICAgICAqICh0aGUgcHJvcGVydHkncyBleGlzdGVuY2UgaW5mZXJzIG5hdGl2ZSBzcmNzZXQgc3VwcG9ydCwgYW5kIGEgc3Jjc2V0LXN1cHBvcnRpbmcgYnJvd3NlciB3aWxsIHByaW9yaXRpemUgc3Jjc2V0J3MgdmFsdWUgb3ZlciBvdXIgd2lubmluZyBwaWN0dXJlIGNhbmRpZGF0ZSlcbiAgICAgKiB0aGlzIG1vdmVzIHNyY3NldCdzIHZhbHVlIHRvIG1lbW9yeSBmb3IgbGF0ZXIgdXNlIGFuZCByZW1vdmVzIHRoZSBhdHRyXG4gICAgICovXG4gICAgcGYuZG9kZ2VTcmNzZXQgPSBmdW5jdGlvbiggaW1nICkge1xuICAgICAgICBpZiAoIGltZy5zcmNzZXQgKSB7XG4gICAgICAgICAgICBpbWdbIHBmLm5zIF0uc3Jjc2V0ID0gaW1nLnNyY3NldDtcbiAgICAgICAgICAgIGltZy5zcmNzZXQgPSBcIlwiO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSggXCJkYXRhLXBmc3Jjc2V0XCIsIGltZ1sgcGYubnMgXS5zcmNzZXQgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBY2NlcHQgYSBzb3VyY2Ugb3IgaW1nIGVsZW1lbnQgYW5kIHByb2Nlc3MgaXRzIHNyY3NldCBhbmQgc2l6ZXMgYXR0cnNcbiAgICBwZi5wcm9jZXNzU291cmNlU2V0ID0gZnVuY3Rpb24oIGVsICkge1xuICAgICAgICB2YXIgc3Jjc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCBcInNyY3NldFwiICksXG4gICAgICAgICAgICBzaXplcyA9IGVsLmdldEF0dHJpYnV0ZSggXCJzaXplc1wiICksXG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgLy8gaWYgaXQncyBhbiBpbWcgZWxlbWVudCwgdXNlIHRoZSBjYWNoZWQgc3Jjc2V0IHByb3BlcnR5IChkZWZpbmVkIG9yIG5vdClcbiAgICAgICAgaWYgKCBlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIklNR1wiICYmIGVsWyBwZi5ucyBdICYmIGVsWyBwZi5ucyBdLnNyY3NldCApIHtcbiAgICAgICAgICAgIHNyY3NldCA9IGVsWyBwZi5ucyBdLnNyY3NldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc3Jjc2V0ICkge1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHBmLmdldENhbmRpZGF0ZXNGcm9tU291cmNlU2V0KCBzcmNzZXQsIHNpemVzICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIHBmLmJhY2tmYWNlVmlzaWJpbGl0eUZpeCA9IGZ1bmN0aW9uKCBwaWNJbWcgKSB7XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0amVobC9waWN0dXJlZmlsbC9pc3N1ZXMvMzMyXG4gICAgICAgIHZhciBzdHlsZSA9IHBpY0ltZy5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9IFwid2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIgaW4gc3R5bGUsXG4gICAgICAgICAgICBjdXJyZW50Wm9vbSA9IHN0eWxlLnpvb207XG5cbiAgICAgICAgaWYgKFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgc3R5bGUuem9vbSA9IFwiLjk5OVwiO1xuXG4gICAgICAgICAgICBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSBwaWNJbWcub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgIHN0eWxlLnpvb20gPSBjdXJyZW50Wm9vbTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwZi5zZXRJbmhlcmVudFNpemUgPSBmdW5jdGlvbiggcmVzLCBwaWNJbWcsIHJlYWR5U3RhdGUgKSB7XG4gICAgICAgIHZhciByZWFkeSA9IHJlYWR5U3RhdGUgIT09IHVuZGVmaW5lZCA/IHJlYWR5U3RhdGUgOiBwaWNJbWcuY29tcGxldGUsXG4gICAgICAgICAgICB3aWR0aFByZXNldCA9ICFyZWFkeSAmJiBwaWNJbWcuZ2V0QXR0cmlidXRlICYmIHBpY0ltZy5nZXRBdHRyaWJ1dGUoIFwid2lkdGhcIiApICE9PSBudWxsLFxuICAgICAgICAgICAgc2V0V2lkdGggPSBmdW5jdGlvbiggcmVzLCBwaWNJbWcgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBwaWNJbWcuc2V0QXR0cmlidXRlICkge1xuICAgICAgICAgICAgICAgICAgICBwaWNJbWcuc2V0QXR0cmlidXRlKCBcIndpZHRoXCIsIHBpY0ltZy5uYXR1cmFsV2lkdGggLyByZXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2lkdGhJbnRlcnZhbDtcblxuICAgICAgICBpZiAoIHJlYWR5ICYmIHJlcyAmJiAhd2lkdGhQcmVzZXQgKSB7XG4gICAgICAgICAgICBzZXRXaWR0aCggcmVzLCBwaWNJbWcgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICFyZWFkeSApIHtcbiAgICAgICAgICAgIHdpZHRoSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBmLnNldEluaGVyZW50U2l6ZSggcmVzLCBwaWNJbWcsIHBpY0ltZy5jb21wbGV0ZSApO1xuICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwZi5hcHBseUJlc3RDYW5kaWRhdGUgPSBmdW5jdGlvbiggY2FuZGlkYXRlcywgcGljSW1nICkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgYmVzdENhbmRpZGF0ZTtcblxuICAgICAgICBjYW5kaWRhdGVzLnNvcnQoIHBmLmFzY2VuZGluZ1NvcnQgKTtcblxuICAgICAgICBsZW5ndGggPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgYmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGxlbmd0aCAtIDEgXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2FuZGlkYXRlLnJlc29sdXRpb24gPj0gcGYuZ2V0RHByKCkgKSB7XG4gICAgICAgICAgICAgICAgYmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYmVzdENhbmRpZGF0ZSAmJiAhcGYuZW5kc1dpdGgoIHBpY0ltZy5zcmMsIGJlc3RDYW5kaWRhdGUudXJsICkgKSB7XG4gICAgICAgICAgICBpZiAoIHBmLnJlc3RyaWN0c01peGVkQ29udGVudCgpICYmIGJlc3RDYW5kaWRhdGUudXJsLnN1YnN0cigwLCBcImh0dHA6XCIubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHA6XCIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cuY29uc29sZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiQmxvY2tlZCBtaXhlZCBjb250ZW50IGltYWdlIFwiICsgYmVzdENhbmRpZGF0ZS51cmwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY0ltZy5zcmMgPSBiZXN0Q2FuZGlkYXRlLnVybDtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50U3JjIGF0dHJpYnV0ZSBhbmQgcHJvcGVydHkgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vcGljdHVyZS5yZXNwb25zaXZlaW1hZ2VzLm9yZy8jdGhlLWltZy1lbGVtZW50XG4gICAgICAgICAgICAgICAgcGljSW1nLmN1cnJlbnRTcmMgPSBwaWNJbWcuc3JjO1xuXG4gICAgICAgICAgICAgICAgcGYuYmFja2ZhY2VWaXNpYmlsaXR5Rml4KCBwaWNJbWcgKTtcbiAgICAgICAgICAgICAgICBwZi5zZXRJbmhlcmVudFNpemUoIGJlc3RDYW5kaWRhdGUucmVzb2x1dGlvbiwgcGljSW1nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcGYuYXNjZW5kaW5nU29ydCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICByZXR1cm4gYS5yZXNvbHV0aW9uIC0gYi5yZXNvbHV0aW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbiBJRTksIDxzb3VyY2U+IGVsZW1lbnRzIGdldCByZW1vdmVkIGlmIHRoZXkgYXJlbid0IGNoaWxkcmVuIG9mXG4gICAgICogdmlkZW8gZWxlbWVudHMuIFRodXMsIHdlIGNvbmRpdGlvbmFsbHkgd3JhcCBzb3VyY2UgZWxlbWVudHNcbiAgICAgKiB1c2luZyA8IS0tW2lmIElFIDldPjx2aWRlbyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+PCFbZW5kaWZdLS0+XG4gICAgICogYW5kIG11c3QgYWNjb3VudCBmb3IgdGhhdCBoZXJlIGJ5IG1vdmluZyB0aG9zZSBzb3VyY2UgZWxlbWVudHNcbiAgICAgKiBiYWNrIGludG8gdGhlIHBpY3R1cmUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBwZi5yZW1vdmVWaWRlb1NoaW0gPSBmdW5jdGlvbiggcGljdHVyZSApIHtcbiAgICAgICAgdmFyIHZpZGVvcyA9IHBpY3R1cmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidmlkZW9cIiApO1xuICAgICAgICBpZiAoIHZpZGVvcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW8gPSB2aWRlb3NbIDAgXSxcbiAgICAgICAgICAgICAgICB2c291cmNlcyA9IHZpZGVvLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInNvdXJjZVwiICk7XG4gICAgICAgICAgICB3aGlsZSAoIHZzb3VyY2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBwaWN0dXJlLmluc2VydEJlZm9yZSggdnNvdXJjZXNbIDAgXSwgdmlkZW8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBvbmNlIHdlJ3JlIGZpbmlzaGVkIHJlbW92aW5nIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgdmlkZW8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdmlkZW8gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCBgaW1nYCBlbGVtZW50cywgYW5kIGFkZCB0aGVtIHRvIHRoZSBjYW5kaWRhdGUgbGlzdCBpZiB0aGV5IGhhdmVcbiAgICAgKiBhIGBwaWN0dXJlYCBwYXJlbnQsIGEgYHNpemVzYCBhdHRyaWJ1dGUgaW4gYmFzaWMgYHNyY3NldGAgc3VwcG9ydGluZyBicm93c2VycyxcbiAgICAgKiBhIGBzcmNzZXRgIGF0dHJpYnV0ZSBhdCBhbGwsIGFuZCB0aGV5IGhhdmVu4oCZdCBiZWVuIGV2YWx1YXRlZCBhbHJlYWR5LlxuICAgICAqL1xuICAgIHBmLmdldEFsbEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtcyA9IFtdLFxuICAgICAgICAgICAgaW1ncyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJpbWdcIiApO1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgbGVuID0gaW1ncy5sZW5ndGg7IGggPCBsZW47IGgrKyApIHtcbiAgICAgICAgICAgIHZhciBjdXJySW1nID0gaW1nc1sgaCBdO1xuXG4gICAgICAgICAgICBpZiAoIGN1cnJJbWcucGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIiB8fFxuICAgICAgICAgICAgICAgICggY3VyckltZy5nZXRBdHRyaWJ1dGUoIFwic3Jjc2V0XCIgKSAhPT0gbnVsbCApIHx8IGN1cnJJbWdbIHBmLm5zIF0gJiYgY3VyckltZ1sgcGYubnMgXS5zcmNzZXQgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMucHVzaCggY3VyckltZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtcztcbiAgICB9O1xuXG4gICAgcGYuZ2V0TWF0Y2ggPSBmdW5jdGlvbiggaW1nLCBwaWN0dXJlICkge1xuICAgICAgICB2YXIgc291cmNlcyA9IHBpY3R1cmUuY2hpbGROb2RlcyxcbiAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjaGlsZCwgYW5kIGlmIHRoZXkgaGF2ZSBtZWRpYSBxdWVyaWVzLCBldmFsdWF0ZSB0aGVtXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgc2xlbiA9IHNvdXJjZXMubGVuZ3RoOyBqIDwgc2xlbjsgaisrICkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbIGogXTtcblxuICAgICAgICAgICAgLy8gaWdub3JlIG5vbi1lbGVtZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIHNvdXJjZS5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGl0dGluZyB0aGUgYGltZ2AgZWxlbWVudCB0aGF0IHN0YXJ0ZWQgZXZlcnl0aGluZyBzdG9wcyB0aGUgc2VhcmNoIGZvciBgc291cmNlc2AuXG4gICAgICAgICAgICAvLyBJZiBubyBwcmV2aW91cyBgc291cmNlYCBtYXRjaGVzLCB0aGUgYGltZ2AgaXRzZWxmIGlzIGV2YWx1YXRlZCBsYXRlci5cbiAgICAgICAgICAgIGlmICggc291cmNlID09PSBpbWcgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgbm9uLWBzb3VyY2VgIG5vZGVzXG4gICAgICAgICAgICBpZiAoIHNvdXJjZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNPVVJDRVwiICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgaGFzIHRoZSBgc3JjYCBwcm9wZXJ0eSBzZXQsIHRocm93IGEgd2FybmluZyBpbiB0aGUgY29uc29sZVxuICAgICAgICAgICAgaWYgKCBzb3VyY2UuZ2V0QXR0cmlidXRlKCBcInNyY1wiICkgIT09IG51bGwgJiYgdHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgYHNyY2AgYXR0cmlidXRlIGlzIGludmFsaWQgb24gYHBpY3R1cmVgIGBzb3VyY2VgIGVsZW1lbnQ7IGluc3RlYWQsIHVzZSBgc3Jjc2V0YC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwibWVkaWFcIiApO1xuXG4gICAgICAgICAgICAvLyBpZiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIHNyY3NldCBhdHRyaWJ1dGUsIHNraXBcbiAgICAgICAgICAgIGlmICggIXNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwic3Jjc2V0XCIgKSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtZWRpYSBzcGVjaWZpZWQsIE9SIHcubWF0Y2hNZWRpYSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICggKCAhbWVkaWEgfHwgcGYubWF0Y2hlc01lZGlhKCBtZWRpYSApICkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSBwZi52ZXJpZnlUeXBlU3VwcG9ydCggc291cmNlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVTdXBwb3J0ZWQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlU3VwcG9ydGVkID09PSBcInBlbmRpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGljdHVyZWZpbGwoIG9wdCApIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGZpcnN0TWF0Y2gsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdCB8fCB7fTtcblxuICAgICAgICBlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMgfHwgcGYuZ2V0QWxsRWxlbWVudHMoKTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIGVsZW1lbnRzXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgcGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IHBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1sgaSBdO1xuICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgZmlyc3RNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNraXAgbm9uLWBpbWdgIG5vZGVzXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJJTUdcIiApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXhwYW5kbyBmb3IgY2FjaGluZyBkYXRhIG9uIHRoZSBpbWdcbiAgICAgICAgICAgIGlmICggIWVsZW1lbnRbIHBmLm5zIF0gKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFsgcGYubnMgXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZCwgc2tpcCBpdCB1bmxlc3NcbiAgICAgICAgICAgIC8vIGBvcHRpb25zLnJlZXZhbHVhdGVgIGlzIHNldCB0byB0cnVlICggdGhpcywgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHJ1bm5pbmcgYHBpY3R1cmVmaWxsYCBvbiBgcmVzaXplYCApLlxuICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5yZWV2YWx1YXRlICYmIGVsZW1lbnRbIHBmLm5zIF0uZXZhbHVhdGVkICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBgaW1nYCBpcyBpbiBhIGBwaWN0dXJlYCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIHBhcmVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vIElFOSB2aWRlbyB3b3JrYXJvdW5kXG4gICAgICAgICAgICAgICAgcGYucmVtb3ZlVmlkZW9TaGltKCBwYXJlbnQgKTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgbWF0Y2ggd2hpY2ggbWlnaHQgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZSBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgc291cmNlXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGUgcmV0dXJuIHR5cGUgaGVyZSBpcyBicnV0YWwsIGNsZWFudXBcbiAgICAgICAgICAgICAgICBmaXJzdE1hdGNoID0gcGYuZ2V0TWF0Y2goIGVsZW1lbnQsIHBhcmVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IHNvdXJjZXMgYXJlIHBlbmRpbmcgaW4gdGhpcyBwaWN0dXJlIGR1ZSB0byBhc3luYyB0eXBlIHRlc3QocylcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGV2YWx1YXRlZCBhdHRyIGFuZCBza2lwIGZvciBub3cgKCB0aGUgcGVuZGluZyB0ZXN0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyByZXJ1biBwaWN0dXJlZmlsbCBvbiB0aGlzIGVsZW1lbnQgd2hlbiBjb21wbGV0ZSlcbiAgICAgICAgICAgICAgICBpZiAoIGZpcnN0TWF0Y2ggPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhY2hlIGFuZCByZW1vdmUgYHNyY3NldGAgaWYgcHJlc2VudCBhbmQgd2XigJlyZSBnb2luZyB0byBiZSBkb2luZyBgcGljdHVyZWAvYHNyY3NldGAvYHNpemVzYCBwb2x5ZmlsbGluZyB0byBpdC5cbiAgICAgICAgICAgIGlmICggcGFyZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUElDVFVSRVwiIHx8XG4gICAgICAgICAgICAgICAgKCBlbGVtZW50LnNyY3NldCAmJiAhcGYuc3Jjc2V0U3VwcG9ydGVkICkgfHxcbiAgICAgICAgICAgICAgICAoICFwZi5zaXplc1N1cHBvcnRlZCAmJiAoIGVsZW1lbnQuc3Jjc2V0ICYmIGVsZW1lbnQuc3Jjc2V0LmluZGV4T2YoXCJ3XCIpID4gLTEgKSApICkge1xuICAgICAgICAgICAgICAgIHBmLmRvZGdlU3Jjc2V0KCBlbGVtZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZmlyc3RNYXRjaCApIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gcGYucHJvY2Vzc1NvdXJjZVNldCggZmlyc3RNYXRjaCApO1xuICAgICAgICAgICAgICAgIHBmLmFwcGx5QmVzdENhbmRpZGF0ZSggY2FuZGlkYXRlcywgZWxlbWVudCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzb3VyY2VzIG1hdGNoZWQsIHNvIHdl4oCZcmUgZG93biB0byBwcm9jZXNzaW5nIHRoZSBpbm5lciBgaW1nYCBhcyBhIHNvdXJjZS5cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gcGYucHJvY2Vzc1NvdXJjZVNldCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50LnNyY3NldCA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnRbIHBmLm5zIF0uc3Jjc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgYHNyY3NldGAgaXMgY29tcGxldGVseSB1bnN1cHBvcnRlZCwgb3Igd2UgbmVlZCB0byBwb2x5ZmlsbCBgc2l6ZXNgIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIHBmLmFwcGx5QmVzdENhbmRpZGF0ZSggY2FuZGlkYXRlcywgZWxlbWVudCApO1xuICAgICAgICAgICAgICAgIH0gLy8gRWxzZSwgcmVzb2x1dGlvbi1vbmx5IGBzcmNzZXRgIGlzIHN1cHBvcnRlZCBuYXRpdmVseS5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGV2YWx1YXRlZCB0byB0cnVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcGFyc2luZ1xuICAgICAgICAgICAgZWxlbWVudFsgcGYubnMgXS5ldmFsdWF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBwaWN0dXJlIHBvbHlmaWxsIGJ5IHBvbGxpbmcgdGhlIGRvY3VtZW50IGFuZCBydW5uaW5nXG4gICAgICogdGhlIHBvbHlmaWxsIGV2ZXJ5IDI1MG1zIHVudGlsIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cbiAgICAgKiBBbHNvIGF0dGFjaGVzIHBpY3R1cmVmaWxsIG9uIHJlc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1blBpY3R1cmVmaWxsKCkge1xuICAgICAgICBwaWN0dXJlZmlsbCgpO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLCBzdG9wIGNoZWNraW5nIGZvciBuZXcgaW1hZ2VzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVkL2RvbXJlYWR5L2Jsb2IvbWFzdGVyL3JlYWR5LmpzI0wxNVxuICAgICAgICAgICAgcGljdHVyZWZpbGwoKTtcblxuICAgICAgICAgICAgaWYgKCAvXmxvYWRlZHxeaXxeYy8udGVzdCggZG9jLnJlYWR5U3RhdGUgKSApIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCBpbnRlcnZhbElkICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyNTAgKTtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciByZXNpemVUaHJvdHRsZTtcblxuICAgICAgICAgICAgaWYgKCAhdy5fcGljdHVyZWZpbGxXb3JraW5nICkge1xuICAgICAgICAgICAgICAgIHcuX3BpY3R1cmVmaWxsV29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdy5jbGVhclRpbWVvdXQoIHJlc2l6ZVRocm90dGxlICk7XG4gICAgICAgICAgICAgICAgcmVzaXplVGhyb3R0bGUgPSB3LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwaWN0dXJlZmlsbCh7IHJlZXZhbHVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHcuX3BpY3R1cmVmaWxsV29ya2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIDYwICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHcuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIHcuYWRkRXZlbnRMaXN0ZW5lciggXCJyZXNpemVcIiwgY2hlY2tSZXNpemUsIGZhbHNlICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHcuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgICAgICB3LmF0dGFjaEV2ZW50KCBcIm9ucmVzaXplXCIsIGNoZWNrUmVzaXplICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBydW5QaWN0dXJlZmlsbCgpO1xuXG4gICAgLyogZXhwb3NlIG1ldGhvZHMgZm9yIHRlc3RpbmcgKi9cbiAgICBwaWN0dXJlZmlsbC5fID0gcGY7XG5cbiAgICAvKiBleHBvc2UgcGljdHVyZWZpbGwgKi9cbiAgICBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAvLyBDb21tb25KUywganVzdCBleHBvcnRcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwaWN0dXJlZmlsbDtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgLy8gQU1EIHN1cHBvcnRcbiAgICAgICAgZGVmaW5lKCBmdW5jdGlvbigpIHsgcmV0dXJuIHBpY3R1cmVmaWxsOyB9ICk7XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgdyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgLy8gSWYgbm8gQU1EIGFuZCB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIsIGF0dGFjaCB0byB3aW5kb3dcbiAgICAgICAgdy5waWN0dXJlZmlsbCA9IHBpY3R1cmVmaWxsO1xuICAgIH1cblxufSApKCB3aW5kb3csIHdpbmRvdy5kb2N1bWVudCwgbmV3IHdpbmRvdy5JbWFnZSgpICk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIFdlYkZvbnRKU09OTG9hZGVyIDAuMC4yIHwgQGxpY2Vuc2UgSVNDICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgLy8gSWYgdGhlIGVudiBpcyBicm93c2VyaWZ5LCBleHBvcnQgdGhlIGZhY3RvcnkgdXNpbmcgdGhlIG1vZHVsZSBvYmplY3QuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpO1xuXG4gICAgICAgIC8vIElmIHRoZSBlbnYgaXMgQU1ELCByZWdpc3RlciB0aGUgTW9kdWxlIGFzICd3ZWJmb250anNvbmxvYWRlcicuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJ3ZWJmb250anNvbmxvYWRlclwiLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkoZ2xvYmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVudiBpcyBhIGJyb3dzZXIod2l0aG91dCBDSlMgb3IgQU1EIHN1cHBvcnQpLCBleHBvcnQgdGhlIGZhY3RvcnkgaW50byB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLldlYkZvbnRMb2FkZXIgPSBmYWN0b3J5KGdsb2JhbCk7XG4gICAgfVxufSkod2luZG93LCBmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgaGVhZEVsZW1lbnQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgIHZhciBzdG9yYWdlID0gZ2xvYmFsLmxvY2FsU3RvcmFnZTtcbiAgICB2YXIgc3JjS2V5ID0gXCJfZm9udF9zcmNcIjtcbiAgICB2YXIgdGltZVN0YW1wS2V5ID0gXCJfZm9udF90aW1lc3RhbXBcIjtcblxuICAgIC8qXG4gICAgICogV2ViRm9udExvYWRlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IFRoZSBvcHRpb25zIE9iamVjdCB3aGljaCBpbml0aWFsaXplcyB0aGUgbG9hZGVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbmV3IFdlYkZvbnRMb2FkZXIoe1xuICAgICAqICAgICAgdXJsOiAnZm9udHMvd2ViZm9udC5qc29uJywgLy8gUGF0aCB0byB0aGUgSlNPTlAgZmlsZS5cbiAgICAgKiAgICAgIHRpbWVTdGFtcDogJz90PTAxMDcyMDE1JywgLy8gVGltZXN0YW1wIGZvciB0aGUgY2FjaGUuXG4gICAgICogICAgICBKU09OUENhbGxiYWNrTmFtZTogICdjYWxsYmFjaycsIC8vSlNPTlAgY2FsbGJhY2sgbmFtZS5cbiAgICAgKiB9KTtcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgV2ViRm9udExvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuICAgICAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB0aGlzLnRpbWVTdGFtcCA9IG9wdGlvbnMudGltZVN0YW1wIHx8IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gb3B0aW9ucy5uYW1lc3BhY2UgfHwgXCJXZWJGb250SlNPTkxvYWRlclwiO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICAgICAgdGhpcy5jYWxsYmFja05hbWUgPSBvcHRpb25zLkpTT05QQ2FsbGJhY2tOYW1lIHx8IFwiV2ViRm9udEpzb25DYWxsQmFja1wiO1xuXG4gICAgICAgIGlmICghdGhpcy5faGFzUmVxdWlyZWRDb25zdGFudHNBbmRBUElzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2V0V2ViRm9udFN0eWxlcygpO1xuICAgIH07XG5cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5faGFzUmVxdWlyZWRDb25zdGFudHNBbmRBUElzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYm9vbCA9IHRydWU7XG5cbiAgICAgICAgaWYgKCFfc3VwcG9ydHNMb2NhbFN0b3JhZ2VBUEkoKSkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiV2ViRm9udEpTT05Mb2FkZXI6IFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBsb2NhbFN0b3JhZ2UgQVBJLCBhYm9ydGluZy5cIik7XG5cbiAgICAgICAgICAgIGJvb2wgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJXZWJGb250SlNPTkxvYWRlcjogTm8gVVJMIHdhcyBmb3VuZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIGFib3J0aW5nLlwiKTtcblxuICAgICAgICAgICAgYm9vbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgfTtcbiAgICB2YXIgX3N1cHBvcnRzTG9jYWxTdG9yYWdlQVBJID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5ID0gXCJ0ZXN0XCI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIDEpO1xuICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuZ2V0V2ViRm9udFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzTG9jYWxTdG9yYWdlU3JjVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlSW5saW5lU3R5bGVzKCkuX2V4ZWN1dGVDYWxsQmFjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2V0U3R5bGVzRnJvbUpTT05QKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX2lzTG9jYWxTdG9yYWdlU3JjVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZTtcblxuICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKG5hbWVzcGFjZSArIHNyY0tleSkgJiYgc3RvcmFnZS5nZXRJdGVtKG5hbWVzcGFjZSArIHRpbWVTdGFtcEtleSkgPT09IHRoaXMudGltZVN0YW1wO1xuICAgIH07XG5cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5fZXhlY3V0ZUNhbGxCYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrO1xuXG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcblxuICAgIFdlYkZvbnRMb2FkZXIucHJvdG90eXBlLl9nZXRTdHlsZXNGcm9tSlNPTlAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlbmV3IHRoZSB0aW1lc3RhbXAuXG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZSArIHRpbWVTdGFtcEtleSwgdGhpcy50aW1lU3RhbXApO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIEpTT05QIGNhbGxiYWNrIGFjY2Vzc2libGUuXG4gICAgICAgIGdsb2JhbFt0aGlzLmNhbGxiYWNrTmFtZV0gPSB0aGlzLl9KU09OUENhbGxiYWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgSlNPTlAgYW5kIHJ1biB0aGUgY2FsbGJhY2suXG4gICAgICAgIHRoaXMuX2xvYWRKU09OUCgpO1xuICAgIH07XG5cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5fSlNPTlBDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgdmFyIGNzcyA9IHJlcy5jc3M7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBsb2NhbFN0b3JhZ2UgY2FjaGUuXG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm5hbWVzcGFjZSArIHNyY0tleSwgY3NzKTtcblxuICAgICAgICB0aGlzLl9jcmVhdGVJbmxpbmVTdHlsZXMoKTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnbG9iYWwgbmFtZXNwYWNlLlxuICAgICAgICBnbG9iYWxbdGhpcy5jYWxsYmFja05hbWVdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5fbG9hZEpTT05QID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCBlbGVtZW50LlxuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgIHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHRoaXMudXJsO1xuICAgICAgICBoZWFkRWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICBoZWFkRWxlbWVudC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzIHRoZSBKU09OUCBmaWxlIHdhcyBsb2FkZWQuXG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSB0aGlzLl9leGVjdXRlQ2FsbEJhY2suYmluZCh0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX2NyZWF0ZUlubGluZVN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlO1xuICAgICAgICB2YXIgY3NzID0gc3RvcmFnZS5nZXRJdGVtKG5hbWVzcGFjZSArIHNyY0tleSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzdHlsZSBlbGVtZW50LlxuICAgICAgICB2YXIgc3R5bGUgPSBkb2MuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBzdHlsZS50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgICAgIGhlYWRFbGVtZW50LmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdlYkZvbnRMb2FkZXI7XG59KTtcbiJdfQ==
