(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Head.min.js
 */

var WebFontJSONLoader = require('./Utilities/WebFontJSONLoader/Util.js'),
    supportsWoff2 = require('./Utilities/Feature-Detects/Woff2.js'),
    webFontUrl = (supportsWoff2) ? 'WebFonts/DevButze.woff2.json': 'WebFonts/DevButze.woff.json';

// Load the WebFont.
new WebFontJSONLoader({
	url: webFontUrl, // Path to the JSONP.
	timeStamp: '?t=01152015', // Timestamp for the cache.
	callbackName:  'devButzeAttachFonts', //JSONP callback name.
	namespace: 'devButze' // localStorage namespace for the fonts.
});

// Require some polyfills
require('./Vendor/Polyfills/Picturefill.js');
},{"./Utilities/Feature-Detects/Woff2.js":2,"./Utilities/WebFontJSONLoader/Util.js":3,"./Vendor/Polyfills/Picturefill.js":4}],2:[function(require,module,exports){
/**
 * supportsWoff2
 * @description A simple feature test for the WOFF2 font format.
 * @see https://github.com/filamentgroup/woff2-feature-test/blob/master/woff2.js
 */
var supportsWoff2 = (function(win){
    'use strict';

	if(!("FontFace" in win)) {
		return false;
	}

    var f = new win.FontFace("t", 'url( "data:application/font-woff2,4e" ) format( "woff2" )', {});
    f.load();

	return f.status === 'loading';
})(window);


module.exports = supportsWoff2;
},{}],3:[function(require,module,exports){
/**
 * Fetches a webfont based of JSONP.
 *
 * @example
 * new WebFontLoader({
 *      url: 'fonts/webfont.json', // Path to the JSONP.
 *      timeStamp: '?t=01072015', // Timestamp for the cache.
 *      callbackName:  'callback', //JSONP callback name.
 *      namespace: 'webfont' // localStorage namespace for the fonts.
 * });
 */

(function(global, factory) {
    'use strict';

    // If the env is browserify, export the factory using the module object.
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global);

    // If the env is AMD, register the Module as 'webfontjsonloader'.
    } else if (typeof define === "function" && define.amd) {
        define("webfontjsonloader", [], function() {
            return factory(global);
        });

    // If the env is a browser, export the factory in the global window object.
    } else {
        global.WebFontLoader = factory(global);
    }
// Pass this if window is not defined yet
}(window, function(global) {
    'use strict';

    // Shorthand for window.document
    var doc = global.document;

    // Shorthand for the <head> element.
    var headElement = doc.getElementsByTagName('head')[0];

    // Future proof way of testing the aviability of the localStorage API.
    var hasLocalStorage = function() {
        try {
            global.localStorage.setItem('test', 1);
            global.localStorage.removeItem('test');
            return true;
        } catch(e) {
            return false;
        }
    };

    // The default jsonp callback.
    var jsonpCallback = function(res) {
        var css = res.css;

        // Create the localStorage cache.
        global.localStorage[this.namespace + '_font_src'] = css;

        // Attach the css to the document.
        this.attachStyles(css);

        // Make sure the global namespace isn't polluted with unused functions.
        global[this.callbackName] = undefined;

        return this;
    };


    /**
     * WebFontLoader
     * @param options {Object} The options Object which initializes the loader.
     * @constructor
     */
    var WebFontLoader = function(options) {
        // Fallbacks for the options.
        var url = options.url;
        var timeStamp = options.timeStamp;
        var callback = options.callback;
        var callbackName = options.callbackName || 'WebFontJsonCallback';
        var namespace = options.namespace || 'webfontjsonloader';

        // Check for localStorage support, as well as the primary options.
        if(!hasLocalStorage() || !url || !timeStamp) {
            return;
        }

        // Setup the constants.
        this.url = url;
        this.namespace = namespace;
        this.callbackName = callbackName;

        // If the passed timestamp matches the localStorage timestamp, attach the css from the users localStorage.
        if(global.localStorage[namespace + '_font_src'] && global.localStorage[namespace + '_font_timestamp'] === timeStamp) {
            this.attachStyles(global.localStorage[namespace + '_font_src']);

        // If the timestamp does NOT match, load and run the JSONP callback.
        } else {
            // Renew the timestamp.
            global.localStorage[namespace + '_font_timestamp'] = timeStamp;

            // Make the callback accessible for the JSONP.
            global[callbackName] = jsonpCallback.bind(this);

            // Load the JSONP and run the callback.
            this.loadJSONP(null, callback);
        }
    };

    /**
     * loadJSONP
     * @param url {String} Optional URL of the jsonp file.
     * @param callback {Function} Optional callback to execute after the script was loaded.
     * @returns {WebFontLoader}
     */
    WebFontLoader.prototype.loadJSONP = function(url, callback) {
        url = url || this.url;

        // Create the script element
        var script = doc.createElement('script');

        // Setup the script element.
        script.type = 'text/javascript';
        script.src = url;

        // Load the JSONP.
        headElement.appendChild(script);

        // Remove the temporary script element.
        headElement.removeChild(script);

        // Execute the callback as the JSONP file was loaded.
        if(callback) {
            script.onload = callback;
        }

        return this;
    };

    /**
     * attachStyles
     * @param css {String} The css which get's attached to the document.
     * @returns {WebFontLoader}
     */
    WebFontLoader.prototype.attachStyles = function(css) {
        // Create the inline style element
        var style = doc.createElement('style');

        // Setup the style element.
        style.type = 'text/css';
        style.id = this.namespace + '_fontStyles';
        style.appendChild(doc.createTextNode(css));

        // Append the element to the UA's <head>.
        headElement.appendChild(style);

        return this;
    };

    // Return the module.
    return WebFontLoader;
}));
},{}],4:[function(require,module,exports){
/*! Picturefill - v2.2.0 - 2014-12-19
 * http://scottjehl.github.io/picturefill
 * Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
    "use strict";

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        script.parentNode.insertBefore(style, script);

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());
/*! Picturefill - Responsive Images that work today.
 *  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
 *  License: MIT/GPLv2
 *  Spec: http://picture.responsiveimages.org/
 */
(function( w, doc, image ) {
    // Enable strict mode
    "use strict";

    // If picture is supported, well, that's awesome. Let's get outta here...
    if ( w.HTMLPictureElement ) {
        w.picturefill = function() { };
        return;
    }

    // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
    doc.createElement( "picture" );

    // local object for method references and testing exposure
    var pf = w.picturefill || {};

    // namespace
    pf.ns = "picturefill";

    // srcset support test
    (function() {
        pf.srcsetSupported = "srcset" in image;
        pf.sizesSupported = "sizes" in image;
    })();

    // just a string trim workaround
    pf.trim = function( str ) {
        return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
    };

    // just a string endsWith workaround
    pf.endsWith = function( str, suffix ) {
        return str.endsWith ? str.endsWith( suffix ) : str.indexOf( suffix, str.length - suffix.length ) !== -1;
    };

    /**
     * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
     */
    pf.restrictsMixedContent = function() {
        return w.location.protocol === "https:";
    };
    /**
     * Shortcut method for matchMedia ( for easy overriding in tests )
     */

    pf.matchesMedia = function( media ) {
        return w.matchMedia && w.matchMedia( media ).matches;
    };

    // Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
    pf.getDpr = function() {
        return ( w.devicePixelRatio || 1 );
    };

    /**
     * Get width in css pixel value from a "length" value
     * http://dev.w3.org/csswg/css-values-3/#length-value
     */
    pf.getWidthFromLength = function( length ) {
        // If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, use the `100vw` default.
        length = length && length.indexOf( "%" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 ) ? length : "100vw";

        /**
         * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
         * is injected at the top of the document.
         *
         * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
         */
        length = length.replace( "vw", "%" );

        // Create a cached element for getting length value widths
        if ( !pf.lengthEl ) {
            pf.lengthEl = doc.createElement( "div" );

            // Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.
            pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden";
        }

        pf.lengthEl.style.width = length;

        doc.body.appendChild(pf.lengthEl);

        // Add a class, so that everyone knows where this element comes from
        pf.lengthEl.className = "helper-from-picturefill-js";

        if ( pf.lengthEl.offsetWidth <= 0 ) {
            // Something has gone wrong. `calc()` is in use and unsupported, most likely. Default to `100vw` (`100%`, for broader support.):
            pf.lengthEl.style.width = doc.documentElement.offsetWidth + "px";
        }

        var offsetWidth = pf.lengthEl.offsetWidth;

        doc.body.removeChild( pf.lengthEl );

        return offsetWidth;
    };

    pf.detectTypeSupport = function( type, typeUri ) {
        // based on Modernizr's lossless img-webp test
        // note: asynchronous
        var image = new w.Image();
        image.onerror = function() {
            pf.types[ type ] = false;
            picturefill();
        };
        image.onload = function() {
            pf.types[ type ] = image.width === 1;
            picturefill();
        };
        image.src = typeUri;

        return "pending";
    };
    // container of supported mime types that one might need to qualify before using
    pf.types = pf.types || {};

    // Add support for standard mime types
    pf.types[ "image/jpeg" ] = true;
    pf.types[ "image/gif" ] = true;
    pf.types[ "image/png" ] = true;
    pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
    pf.types[ "image/webp" ] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");

    pf.verifyTypeSupport = function( source ) {
        var type = source.getAttribute( "type" );
        // if type attribute exists, return test result, otherwise return true
        if ( type === null || type === "" ) {
            return true;
        } else {
            var pfType = pf.types[ type ];
            // if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
            if ( typeof pfType === "string" && pfType !== "pending") {
                pf.types[ type ] = pf.detectTypeSupport( type, pfType );
                return "pending";
            } else if ( typeof pfType === "function" ) {
                pfType();
                return "pending";
            } else {
                return pfType;
            }
        }
    };

    // Parses an individual `size` and returns the length, and optional media query
    pf.parseSize = function( sourceSizeStr ) {
        var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
        return {
            media: match && match[1],
            length: match && match[2]
        };
    };

    // Takes a string of sizes and returns the width in pixels as a number
    pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
        // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
        //                            or (min-width:30em) calc(30% - 15px)
        var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
            winningLength;

        for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
            // Match <media-condition>? length, ie ( min-width: 50em ) 100%
            var sourceSize = sourceSizeList[ i ],
            // Split "( min-width: 50em ) 100%" into separate strings
                parsedSize = pf.parseSize( sourceSize ),
                length = parsedSize.length,
                media = parsedSize.media;

            if ( !length ) {
                continue;
            }
            if ( !media || pf.matchesMedia( media ) ) {
                // if there is no media query or it matches, choose this as our winning length
                // and end algorithm
                winningLength = length;
                break;
            }
        }

        // pass the length to a method that can properly determine length
        // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
        return pf.getWidthFromLength( winningLength );
    };

    pf.parseSrcset = function( srcset ) {
        /**
         * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
         * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
         *
         * 1. Let input (`srcset`) be the value passed to this algorithm.
         * 2. Let position be a pointer into input, initially pointing at the start of the string.
         * 3. Let raw candidates be an initially empty ordered list of URLs with associated
         *    unparsed descriptors. The order of entries in the list is the order in which entries
         *    are added to the list.
         */
        var candidates = [];

        while ( srcset !== "" ) {
            srcset = srcset.replace( /^\s+/g, "" );

            // 5. Collect a sequence of characters that are not space characters, and let that be url.
            var pos = srcset.search(/\s/g),
                url, descriptor = null;

            if ( pos !== -1 ) {
                url = srcset.slice( 0, pos );

                var last = url.slice(-1);

                // 6. If url ends with a U+002C COMMA character (,), remove that character from url
                // and let descriptors be the empty string. Otherwise, follow these substeps
                // 6.1. If url is empty, then jump to the step labeled descriptor parser.

                if ( last === "," || url === "" ) {
                    url = url.replace( /,+$/, "" );
                    descriptor = "";
                }
                srcset = srcset.slice( pos + 1 );

                // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
                // let that be descriptors.
                if ( descriptor === null ) {
                    var descpos = srcset.indexOf( "," );
                    if ( descpos !== -1 ) {
                        descriptor = srcset.slice( 0, descpos );
                        srcset = srcset.slice( descpos + 1 );
                    } else {
                        descriptor = srcset;
                        srcset = "";
                    }
                }
            } else {
                url = srcset;
                srcset = "";
            }

            // 7. Add url to raw candidates, associated with descriptors.
            if ( url || descriptor ) {
                candidates.push({
                    url: url,
                    descriptor: descriptor
                });
            }
        }
        return candidates;
    };

    pf.parseDescriptor = function( descriptor, sizesattr ) {
        // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
        // is the order in which entries are added to the list.
        var sizes = sizesattr || "100vw",
            sizeDescriptor = descriptor && descriptor.replace( /(^\s+|\s+$)/g, "" ),
            widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
            resCandidate;

        if ( sizeDescriptor ) {
            var splitDescriptor = sizeDescriptor.split(" ");

            for (var i = splitDescriptor.length - 1; i >= 0; i--) {
                var curr = splitDescriptor[ i ],
                    lastchar = curr && curr.slice( curr.length - 1 );

                if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
                    resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
                } else if ( lastchar === "x" ) {
                    var res = curr && parseFloat( curr, 10 );
                    resCandidate = res && !isNaN( res ) ? res : 1;
                }
            }
        }
        return resCandidate || 1;
    };

    /**
     * Takes a srcset in the form of url/
     * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
     *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
     *     "images/pic-small.png"
     * Get an array of image candidates in the form of
     *      {url: "/foo/bar.png", resolution: 1}
     * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
     * If sizes is specified, resolution is calculated
     */
    pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
        var candidates = pf.parseSrcset( srcset ),
            formattedCandidates = [];

        for ( var i = 0, len = candidates.length; i < len; i++ ) {
            var candidate = candidates[ i ];

            formattedCandidates.push({
                url: candidate.url,
                resolution: pf.parseDescriptor( candidate.descriptor, sizes )
            });
        }
        return formattedCandidates;
    };

    /**
     * if it's an img element and it has a srcset property,
     * we need to remove the attribute so we can manipulate src
     * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
     * this moves srcset's value to memory for later use and removes the attr
     */
    pf.dodgeSrcset = function( img ) {
        if ( img.srcset ) {
            img[ pf.ns ].srcset = img.srcset;
            img.srcset = "";
            img.setAttribute( "data-pfsrcset", img[ pf.ns ].srcset );
        }
    };

    // Accept a source or img element and process its srcset and sizes attrs
    pf.processSourceSet = function( el ) {
        var srcset = el.getAttribute( "srcset" ),
            sizes = el.getAttribute( "sizes" ),
            candidates = [];

        // if it's an img element, use the cached srcset property (defined or not)
        if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
            srcset = el[ pf.ns ].srcset;
        }

        if ( srcset ) {
            candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
        }
        return candidates;
    };

    pf.backfaceVisibilityFix = function( picImg ) {
        // See: https://github.com/scottjehl/picturefill/issues/332
        var style = picImg.style || {},
            WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
            currentZoom = style.zoom;

        if (WebkitBackfaceVisibility) {
            style.zoom = ".999";

            WebkitBackfaceVisibility = picImg.offsetWidth;

            style.zoom = currentZoom;
        }
    };

    pf.setInherentSize = function( res, picImg, readyState ) {
        var ready = readyState !== undefined ? readyState : picImg.complete,
            widthPreset = !ready && picImg.getAttribute && picImg.getAttribute( "width" ) !== null,
            setWidth = function( res, picImg ) {
                if ( picImg.setAttribute ) {
                    picImg.setAttribute( "width", picImg.naturalWidth / res );
                }
            },
            widthInterval;

        if ( ready && res && !widthPreset ) {
            setWidth( res, picImg );
        }
        if ( !ready ) {
            widthInterval = setTimeout(function() {
                pf.setInherentSize( res, picImg, picImg.complete );
            }, 250);
        }
    };

    pf.applyBestCandidate = function( candidates, picImg ) {
        var candidate,
            length,
            bestCandidate;

        candidates.sort( pf.ascendingSort );

        length = candidates.length;
        bestCandidate = candidates[ length - 1 ];

        for ( var i = 0; i < length; i++ ) {
            candidate = candidates[ i ];
            if ( candidate.resolution >= pf.getDpr() ) {
                bestCandidate = candidate;
                break;
            }
        }

        if ( bestCandidate && !pf.endsWith( picImg.src, bestCandidate.url ) ) {
            if ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:" ) {
                if ( window.console !== undefined ) {
                    console.warn( "Blocked mixed content image " + bestCandidate.url );
                }
            } else {
                picImg.src = bestCandidate.url;
                // currentSrc attribute and property to match
                // http://picture.responsiveimages.org/#the-img-element
                picImg.currentSrc = picImg.src;

                pf.backfaceVisibilityFix( picImg );
                pf.setInherentSize( bestCandidate.resolution, picImg );
            }
        }
    };

    pf.ascendingSort = function( a, b ) {
        return a.resolution - b.resolution;
    };

    /**
     * In IE9, <source> elements get removed if they aren't children of
     * video elements. Thus, we conditionally wrap source elements
     * using <!--[if IE 9]><video style="display: none;"><![endif]-->
     * and must account for that here by moving those source elements
     * back into the picture element.
     */
    pf.removeVideoShim = function( picture ) {
        var videos = picture.getElementsByTagName( "video" );
        if ( videos.length ) {
            var video = videos[ 0 ],
                vsources = video.getElementsByTagName( "source" );
            while ( vsources.length ) {
                picture.insertBefore( vsources[ 0 ], video );
            }
            // Remove the video element once we're finished removing its children
            video.parentNode.removeChild( video );
        }
    };

    /**
     * Find all `img` elements, and add them to the candidate list if they have
     * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
     * a `srcset` attribute at all, and they haven’t been evaluated already.
     */
    pf.getAllElements = function() {
        var elems = [],
            imgs = doc.getElementsByTagName( "img" );

        for ( var h = 0, len = imgs.length; h < len; h++ ) {
            var currImg = imgs[ h ];

            if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
                ( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
                elems.push( currImg );
            }
        }
        return elems;
    };

    pf.getMatch = function( img, picture ) {
        var sources = picture.childNodes,
            match;

        // Go through each child, and if they have media queries, evaluate them
        for ( var j = 0, slen = sources.length; j < slen; j++ ) {
            var source = sources[ j ];

            // ignore non-element nodes
            if ( source.nodeType !== 1 ) {
                continue;
            }

            // Hitting the `img` element that started everything stops the search for `sources`.
            // If no previous `source` matches, the `img` itself is evaluated later.
            if ( source === img ) {
                return match;
            }

            // ignore non-`source` nodes
            if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
                continue;
            }
            // if it's a source element that has the `src` property set, throw a warning in the console
            if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ) {
                console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
            }

            var media = source.getAttribute( "media" );

            // if source does not have a srcset attribute, skip
            if ( !source.getAttribute( "srcset" ) ) {
                continue;
            }

            // if there's no media specified, OR w.matchMedia is supported
            if ( ( !media || pf.matchesMedia( media ) ) ) {
                var typeSupported = pf.verifyTypeSupport( source );

                if ( typeSupported === true ) {
                    match = source;
                    break;
                } else if ( typeSupported === "pending" ) {
                    return false;
                }
            }
        }

        return match;
    };

    function picturefill( opt ) {
        var elements,
            element,
            parent,
            firstMatch,
            candidates,
            options = opt || {};

        elements = options.elements || pf.getAllElements();

        // Loop through all elements
        for ( var i = 0, plen = elements.length; i < plen; i++ ) {
            element = elements[ i ];
            parent = element.parentNode;
            firstMatch = undefined;
            candidates = undefined;

            // immediately skip non-`img` nodes
            if ( element.nodeName.toUpperCase() !== "IMG" ) {
                continue;
            }

            // expando for caching data on the img
            if ( !element[ pf.ns ] ) {
                element[ pf.ns ] = {};
            }

            // if the element has already been evaluated, skip it unless
            // `options.reevaluate` is set to true ( this, for example,
            // is set to true when running `picturefill` on `resize` ).
            if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
                continue;
            }

            // if `img` is in a `picture` element
            if ( parent.nodeName.toUpperCase() === "PICTURE" ) {

                // IE9 video workaround
                pf.removeVideoShim( parent );

                // return the first match which might undefined
                // returns false if there is a pending source
                // TODO the return type here is brutal, cleanup
                firstMatch = pf.getMatch( element, parent );

                // if any sources are pending in this picture due to async type test(s)
                // remove the evaluated attr and skip for now ( the pending test will
                // rerun picturefill on this element when complete)
                if ( firstMatch === false ) {
                    continue;
                }
            } else {
                firstMatch = undefined;
            }

            // Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
            if ( parent.nodeName.toUpperCase() === "PICTURE" ||
                ( element.srcset && !pf.srcsetSupported ) ||
                ( !pf.sizesSupported && ( element.srcset && element.srcset.indexOf("w") > -1 ) ) ) {
                pf.dodgeSrcset( element );
            }

            if ( firstMatch ) {
                candidates = pf.processSourceSet( firstMatch );
                pf.applyBestCandidate( candidates, element );
            } else {
                // No sources matched, so we’re down to processing the inner `img` as a source.
                candidates = pf.processSourceSet( element );

                if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
                    // Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
                    pf.applyBestCandidate( candidates, element );
                } // Else, resolution-only `srcset` is supported natively.
            }

            // set evaluated to true to avoid unnecessary reparsing
            element[ pf.ns ].evaluated = true;
        }
    }

    /**
     * Sets up picture polyfill by polling the document and running
     * the polyfill every 250ms until the document is ready.
     * Also attaches picturefill on resize
     */
    function runPicturefill() {
        picturefill();
        var intervalId = setInterval( function() {
            // When the document has finished loading, stop checking for new images
            // https://github.com/ded/domready/blob/master/ready.js#L15
            picturefill();

            if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
                clearInterval( intervalId );
                return;
            }
        }, 250 );

        function checkResize() {
            var resizeThrottle;

            if ( !w._picturefillWorking ) {
                w._picturefillWorking = true;
                w.clearTimeout( resizeThrottle );
                resizeThrottle = w.setTimeout( function() {
                    picturefill({ reevaluate: true });
                    w._picturefillWorking = false;
                }, 60 );
            }
        }

        if ( w.addEventListener ) {
            w.addEventListener( "resize", checkResize, false );
        } else if ( w.attachEvent ) {
            w.attachEvent( "onresize", checkResize );
        }
    }

    runPicturefill();

    /* expose methods for testing */
    picturefill._ = pf;

    /* expose picturefill */
    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // CommonJS, just export
        module.exports = picturefill;
    } else if ( typeof define === "function" && define.amd ) {
        // AMD support
        define( function() { return picturefill; } );
    }

    if ( typeof w === "object" ) {
        // If no AMD and we are in the browser, attach to window
        w.picturefill = picturefill;
    }

} )( window, window.document, new window.Image() );
},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvSGVhZC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRmVhdHVyZS1EZXRlY3RzL1dvZmYyLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1V0aWxpdGllcy9XZWJGb250SlNPTkxvYWRlci9VdGlsLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1ZlbmRvci9Qb2x5ZmlsbHMvUGljdHVyZWZpbGwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKlxuICogSGVhZC5taW4uanNcbiAqL1xuXG52YXIgV2ViRm9udEpTT05Mb2FkZXIgPSByZXF1aXJlKCcuL1V0aWxpdGllcy9XZWJGb250SlNPTkxvYWRlci9VdGlsLmpzJyksXG4gICAgc3VwcG9ydHNXb2ZmMiA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0ZlYXR1cmUtRGV0ZWN0cy9Xb2ZmMi5qcycpLFxuICAgIHdlYkZvbnRVcmwgPSAoc3VwcG9ydHNXb2ZmMikgPyAnV2ViRm9udHMvRGV2QnV0emUud29mZjIuanNvbic6ICdXZWJGb250cy9EZXZCdXR6ZS53b2ZmLmpzb24nO1xuXG4vLyBMb2FkIHRoZSBXZWJGb250LlxubmV3IFdlYkZvbnRKU09OTG9hZGVyKHtcblx0dXJsOiB3ZWJGb250VXJsLCAvLyBQYXRoIHRvIHRoZSBKU09OUC5cblx0dGltZVN0YW1wOiAnP3Q9MDExNTIwMTUnLCAvLyBUaW1lc3RhbXAgZm9yIHRoZSBjYWNoZS5cblx0Y2FsbGJhY2tOYW1lOiAgJ2RldkJ1dHplQXR0YWNoRm9udHMnLCAvL0pTT05QIGNhbGxiYWNrIG5hbWUuXG5cdG5hbWVzcGFjZTogJ2RldkJ1dHplJyAvLyBsb2NhbFN0b3JhZ2UgbmFtZXNwYWNlIGZvciB0aGUgZm9udHMuXG59KTtcblxuLy8gUmVxdWlyZSBzb21lIHBvbHlmaWxsc1xucmVxdWlyZSgnLi9WZW5kb3IvUG9seWZpbGxzL1BpY3R1cmVmaWxsLmpzJyk7IiwiLyoqXG4gKiBzdXBwb3J0c1dvZmYyXG4gKiBAZGVzY3JpcHRpb24gQSBzaW1wbGUgZmVhdHVyZSB0ZXN0IGZvciB0aGUgV09GRjIgZm9udCBmb3JtYXQuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWxhbWVudGdyb3VwL3dvZmYyLWZlYXR1cmUtdGVzdC9ibG9iL21hc3Rlci93b2ZmMi5qc1xuICovXG52YXIgc3VwcG9ydHNXb2ZmMiA9IChmdW5jdGlvbih3aW4pe1xuICAgICd1c2Ugc3RyaWN0JztcblxuXHRpZighKFwiRm9udEZhY2VcIiBpbiB3aW4pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbiAgICB2YXIgZiA9IG5ldyB3aW4uRm9udEZhY2UoXCJ0XCIsICd1cmwoIFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyLDRlXCIgKSBmb3JtYXQoIFwid29mZjJcIiApJywge30pO1xuICAgIGYubG9hZCgpO1xuXG5cdHJldHVybiBmLnN0YXR1cyA9PT0gJ2xvYWRpbmcnO1xufSkod2luZG93KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzV29mZjI7IiwiLyoqXG4gKiBGZXRjaGVzIGEgd2ViZm9udCBiYXNlZCBvZiBKU09OUC5cbiAqXG4gKiBAZXhhbXBsZVxuICogbmV3IFdlYkZvbnRMb2FkZXIoe1xuICogICAgICB1cmw6ICdmb250cy93ZWJmb250Lmpzb24nLCAvLyBQYXRoIHRvIHRoZSBKU09OUC5cbiAqICAgICAgdGltZVN0YW1wOiAnP3Q9MDEwNzIwMTUnLCAvLyBUaW1lc3RhbXAgZm9yIHRoZSBjYWNoZS5cbiAqICAgICAgY2FsbGJhY2tOYW1lOiAgJ2NhbGxiYWNrJywgLy9KU09OUCBjYWxsYmFjayBuYW1lLlxuICogICAgICBuYW1lc3BhY2U6ICd3ZWJmb250JyAvLyBsb2NhbFN0b3JhZ2UgbmFtZXNwYWNlIGZvciB0aGUgZm9udHMuXG4gKiB9KTtcbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gSWYgdGhlIGVudiBpcyBicm93c2VyaWZ5LCBleHBvcnQgdGhlIGZhY3RvcnkgdXNpbmcgdGhlIG1vZHVsZSBvYmplY3QuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShnbG9iYWwpO1xuXG4gICAgLy8gSWYgdGhlIGVudiBpcyBBTUQsIHJlZ2lzdGVyIHRoZSBNb2R1bGUgYXMgJ3dlYmZvbnRqc29ubG9hZGVyJy5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShcIndlYmZvbnRqc29ubG9hZGVyXCIsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KGdsb2JhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGVudiBpcyBhIGJyb3dzZXIsIGV4cG9ydCB0aGUgZmFjdG9yeSBpbiB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ2xvYmFsLldlYkZvbnRMb2FkZXIgPSBmYWN0b3J5KGdsb2JhbCk7XG4gICAgfVxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0od2luZG93LCBmdW5jdGlvbihnbG9iYWwpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBTaG9ydGhhbmQgZm9yIHdpbmRvdy5kb2N1bWVudFxuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG5cbiAgICAvLyBTaG9ydGhhbmQgZm9yIHRoZSA8aGVhZD4gZWxlbWVudC5cbiAgICB2YXIgaGVhZEVsZW1lbnQgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgIC8vIEZ1dHVyZSBwcm9vZiB3YXkgb2YgdGVzdGluZyB0aGUgYXZpYWJpbGl0eSBvZiB0aGUgbG9jYWxTdG9yYWdlIEFQSS5cbiAgICB2YXIgaGFzTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rlc3QnLCAxKTtcbiAgICAgICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndGVzdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFRoZSBkZWZhdWx0IGpzb25wIGNhbGxiYWNrLlxuICAgIHZhciBqc29ucENhbGxiYWNrID0gZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHZhciBjc3MgPSByZXMuY3NzO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbG9jYWxTdG9yYWdlIGNhY2hlLlxuICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlW3RoaXMubmFtZXNwYWNlICsgJ19mb250X3NyYyddID0gY3NzO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY3NzIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgICAgdGhpcy5hdHRhY2hTdHlsZXMoY3NzKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGdsb2JhbCBuYW1lc3BhY2UgaXNuJ3QgcG9sbHV0ZWQgd2l0aCB1bnVzZWQgZnVuY3Rpb25zLlxuICAgICAgICBnbG9iYWxbdGhpcy5jYWxsYmFja05hbWVdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFdlYkZvbnRMb2FkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBUaGUgb3B0aW9ucyBPYmplY3Qgd2hpY2ggaW5pdGlhbGl6ZXMgdGhlIGxvYWRlci5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgV2ViRm9udExvYWRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gRmFsbGJhY2tzIGZvciB0aGUgb3B0aW9ucy5cbiAgICAgICAgdmFyIHVybCA9IG9wdGlvbnMudXJsO1xuICAgICAgICB2YXIgdGltZVN0YW1wID0gb3B0aW9ucy50aW1lU3RhbXA7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICAgIHZhciBjYWxsYmFja05hbWUgPSBvcHRpb25zLmNhbGxiYWNrTmFtZSB8fCAnV2ViRm9udEpzb25DYWxsYmFjayc7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBvcHRpb25zLm5hbWVzcGFjZSB8fCAnd2ViZm9udGpzb25sb2FkZXInO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciBsb2NhbFN0b3JhZ2Ugc3VwcG9ydCwgYXMgd2VsbCBhcyB0aGUgcHJpbWFyeSBvcHRpb25zLlxuICAgICAgICBpZighaGFzTG9jYWxTdG9yYWdlKCkgfHwgIXVybCB8fCAhdGltZVN0YW1wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXR1cCB0aGUgY29uc3RhbnRzLlxuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tOYW1lID0gY2FsbGJhY2tOYW1lO1xuXG4gICAgICAgIC8vIElmIHRoZSBwYXNzZWQgdGltZXN0YW1wIG1hdGNoZXMgdGhlIGxvY2FsU3RvcmFnZSB0aW1lc3RhbXAsIGF0dGFjaCB0aGUgY3NzIGZyb20gdGhlIHVzZXJzIGxvY2FsU3RvcmFnZS5cbiAgICAgICAgaWYoZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lc3BhY2UgKyAnX2ZvbnRfc3JjJ10gJiYgZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lc3BhY2UgKyAnX2ZvbnRfdGltZXN0YW1wJ10gPT09IHRpbWVTdGFtcCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTdHlsZXMoZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lc3BhY2UgKyAnX2ZvbnRfc3JjJ10pO1xuXG4gICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgZG9lcyBOT1QgbWF0Y2gsIGxvYWQgYW5kIHJ1biB0aGUgSlNPTlAgY2FsbGJhY2suXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW5ldyB0aGUgdGltZXN0YW1wLlxuICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lc3BhY2UgKyAnX2ZvbnRfdGltZXN0YW1wJ10gPSB0aW1lU3RhbXA7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNhbGxiYWNrIGFjY2Vzc2libGUgZm9yIHRoZSBKU09OUC5cbiAgICAgICAgICAgIGdsb2JhbFtjYWxsYmFja05hbWVdID0ganNvbnBDYWxsYmFjay5iaW5kKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBMb2FkIHRoZSBKU09OUCBhbmQgcnVuIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIHRoaXMubG9hZEpTT05QKG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBsb2FkSlNPTlBcbiAgICAgKiBAcGFyYW0gdXJsIHtTdHJpbmd9IE9wdGlvbmFsIFVSTCBvZiB0aGUganNvbnAgZmlsZS5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufSBPcHRpb25hbCBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBzY3JpcHQgd2FzIGxvYWRlZC5cbiAgICAgKiBAcmV0dXJucyB7V2ViRm9udExvYWRlcn1cbiAgICAgKi9cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5sb2FkSlNPTlAgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHVybCA9IHVybCB8fCB0aGlzLnVybDtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCBlbGVtZW50XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgICAgICAgLy8gU2V0dXAgdGhlIHNjcmlwdCBlbGVtZW50LlxuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIEpTT05QLlxuICAgICAgICBoZWFkRWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgdGVtcG9yYXJ5IHNjcmlwdCBlbGVtZW50LlxuICAgICAgICBoZWFkRWxlbWVudC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGFzIHRoZSBKU09OUCBmaWxlIHdhcyBsb2FkZWQuXG4gICAgICAgIGlmKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzY3JpcHQub25sb2FkID0gY2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogYXR0YWNoU3R5bGVzXG4gICAgICogQHBhcmFtIGNzcyB7U3RyaW5nfSBUaGUgY3NzIHdoaWNoIGdldCdzIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7V2ViRm9udExvYWRlcn1cbiAgICAgKi9cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5hdHRhY2hTdHlsZXMgPSBmdW5jdGlvbihjc3MpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBpbmxpbmUgc3R5bGUgZWxlbWVudFxuICAgICAgICB2YXIgc3R5bGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblxuICAgICAgICAvLyBTZXR1cCB0aGUgc3R5bGUgZWxlbWVudC5cbiAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIHN0eWxlLmlkID0gdGhpcy5uYW1lc3BhY2UgKyAnX2ZvbnRTdHlsZXMnO1xuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cbiAgICAgICAgLy8gQXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSBVQSdzIDxoZWFkPi5cbiAgICAgICAgaGVhZEVsZW1lbnQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIG1vZHVsZS5cbiAgICByZXR1cm4gV2ViRm9udExvYWRlcjtcbn0pKTsiLCIvKiEgUGljdHVyZWZpbGwgLSB2Mi4yLjAgLSAyMDE0LTEyLTE5XG4gKiBodHRwOi8vc2NvdHRqZWhsLmdpdGh1Yi5pby9waWN0dXJlZmlsbFxuICogQ29weXJpZ2h0IChjKSAyMDE0IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvYmxvYi9tYXN0ZXIvQXV0aG9ycy50eHQ7IExpY2Vuc2VkIE1JVCAqL1xuLyohIG1hdGNoTWVkaWEoKSBwb2x5ZmlsbCAtIFRlc3QgYSBDU1MgbWVkaWEgdHlwZS9xdWVyeSBpbiBKUy4gQXV0aG9ycyAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gRHVhbCBNSVQvQlNEIGxpY2Vuc2UgKi9cblxud2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24oKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxuICAgIHZhciBzdHlsZU1lZGlhID0gKHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYSk7XG5cbiAgICAvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXG4gICAgaWYgKCFzdHlsZU1lZGlhKSB7XG4gICAgICAgIHZhciBzdHlsZSAgICAgICA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksXG4gICAgICAgICAgICBzY3JpcHQgICAgICA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxcbiAgICAgICAgICAgIGluZm8gICAgICAgID0gbnVsbDtcblxuICAgICAgICBzdHlsZS50eXBlICA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgIHN0eWxlLmlkICAgID0gJ21hdGNobWVkaWFqcy10ZXN0JztcblxuICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XG5cbiAgICAgICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgaW5mbyA9ICgnZ2V0Q29tcHV0ZWRTdHlsZScgaW4gd2luZG93KSAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xuXG4gICAgICAgIHN0eWxlTWVkaWEgPSB7XG4gICAgICAgICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9ICdAbWVkaWEgJyArIG1lZGlhICsgJ3sgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9JztcblxuICAgICAgICAgICAgICAgIC8vICdzdHlsZS5zdHlsZVNoZWV0JyBpcyB1c2VkIGJ5IElFIDw9IDggYW5kICdzdHlsZS50ZXh0Q29udGVudCcgZm9yIGFsbCBvdGhlciBicm93c2Vyc1xuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLndpZHRoID09PSAnMXB4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoZXM6IHN0eWxlTWVkaWEubWF0Y2hNZWRpdW0obWVkaWEgfHwgJ2FsbCcpLFxuICAgICAgICAgICAgbWVkaWE6IG1lZGlhIHx8ICdhbGwnXG4gICAgICAgIH07XG4gICAgfTtcbn0oKSk7XG4vKiEgUGljdHVyZWZpbGwgLSBSZXNwb25zaXZlIEltYWdlcyB0aGF0IHdvcmsgdG9kYXkuXG4gKiAgQXV0aG9yOiBTY290dCBKZWhsLCBGaWxhbWVudCBHcm91cCwgMjAxMiAoIG5ldyBwcm9wb3NhbCBpbXBsZW1lbnRlZCBieSBTaGF3biBKYW5zZXBhciApXG4gKiAgTGljZW5zZTogTUlUL0dQTHYyXG4gKiAgU3BlYzogaHR0cDovL3BpY3R1cmUucmVzcG9uc2l2ZWltYWdlcy5vcmcvXG4gKi9cbihmdW5jdGlvbiggdywgZG9jLCBpbWFnZSApIHtcbiAgICAvLyBFbmFibGUgc3RyaWN0IG1vZGVcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIElmIHBpY3R1cmUgaXMgc3VwcG9ydGVkLCB3ZWxsLCB0aGF0J3MgYXdlc29tZS4gTGV0J3MgZ2V0IG91dHRhIGhlcmUuLi5cbiAgICBpZiAoIHcuSFRNTFBpY3R1cmVFbGVtZW50ICkge1xuICAgICAgICB3LnBpY3R1cmVmaWxsID0gZnVuY3Rpb24oKSB7IH07XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIVE1MIHNoaW18diBpdCBmb3Igb2xkIElFIChJRTkgd2lsbCBzdGlsbCBuZWVkIHRoZSBIVE1MIHZpZGVvIHRhZyB3b3JrYXJvdW5kKVxuICAgIGRvYy5jcmVhdGVFbGVtZW50KCBcInBpY3R1cmVcIiApO1xuXG4gICAgLy8gbG9jYWwgb2JqZWN0IGZvciBtZXRob2QgcmVmZXJlbmNlcyBhbmQgdGVzdGluZyBleHBvc3VyZVxuICAgIHZhciBwZiA9IHcucGljdHVyZWZpbGwgfHwge307XG5cbiAgICAvLyBuYW1lc3BhY2VcbiAgICBwZi5ucyA9IFwicGljdHVyZWZpbGxcIjtcblxuICAgIC8vIHNyY3NldCBzdXBwb3J0IHRlc3RcbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHBmLnNyY3NldFN1cHBvcnRlZCA9IFwic3Jjc2V0XCIgaW4gaW1hZ2U7XG4gICAgICAgIHBmLnNpemVzU3VwcG9ydGVkID0gXCJzaXplc1wiIGluIGltYWdlO1xuICAgIH0pKCk7XG5cbiAgICAvLyBqdXN0IGEgc3RyaW5nIHRyaW0gd29ya2Fyb3VuZFxuICAgIHBmLnRyaW0gPSBmdW5jdGlvbiggc3RyICkge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCBcIlwiICk7XG4gICAgfTtcblxuICAgIC8vIGp1c3QgYSBzdHJpbmcgZW5kc1dpdGggd29ya2Fyb3VuZFxuICAgIHBmLmVuZHNXaXRoID0gZnVuY3Rpb24oIHN0ciwgc3VmZml4ICkge1xuICAgICAgICByZXR1cm4gc3RyLmVuZHNXaXRoID8gc3RyLmVuZHNXaXRoKCBzdWZmaXggKSA6IHN0ci5pbmRleE9mKCBzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoICkgIT09IC0xO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgZm9yIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMvc3BlY3MvbWl4ZWRjb250ZW50LyNyZXN0cmljdHMtbWl4ZWQtY29udGVudCAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgICAqL1xuICAgIHBmLnJlc3RyaWN0c01peGVkQ29udGVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IG1ldGhvZCBmb3IgbWF0Y2hNZWRpYSAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgICAqL1xuXG4gICAgcGYubWF0Y2hlc01lZGlhID0gZnVuY3Rpb24oIG1lZGlhICkge1xuICAgICAgICByZXR1cm4gdy5tYXRjaE1lZGlhICYmIHcubWF0Y2hNZWRpYSggbWVkaWEgKS5tYXRjaGVzO1xuICAgIH07XG5cbiAgICAvLyBTaG9ydGN1dCBtZXRob2QgZm9yIGBkZXZpY2VQaXhlbFJhdGlvYCAoIGZvciBlYXN5IG92ZXJyaWRpbmcgaW4gdGVzdHMgKVxuICAgIHBmLmdldERwciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKCB3LmRldmljZVBpeGVsUmF0aW8gfHwgMSApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgd2lkdGggaW4gY3NzIHBpeGVsIHZhbHVlIGZyb20gYSBcImxlbmd0aFwiIHZhbHVlXG4gICAgICogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXZhbHVlcy0zLyNsZW5ndGgtdmFsdWVcbiAgICAgKi9cbiAgICBwZi5nZXRXaWR0aEZyb21MZW5ndGggPSBmdW5jdGlvbiggbGVuZ3RoICkge1xuICAgICAgICAvLyBJZiBhIGxlbmd0aCBpcyBzcGVjaWZpZWQgYW5kIGRvZXNu4oCZdCBjb250YWluIGEgcGVyY2VudGFnZSwgYW5kIGl0IGlzIGdyZWF0ZXIgdGhhbiAwIG9yIHVzaW5nIGBjYWxjYCwgdXNlIGl0LiBFbHNlLCB1c2UgdGhlIGAxMDB2d2AgZGVmYXVsdC5cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoICYmIGxlbmd0aC5pbmRleE9mKCBcIiVcIiApID4gLTEgPT09IGZhbHNlICYmICggcGFyc2VGbG9hdCggbGVuZ3RoICkgPiAwIHx8IGxlbmd0aC5pbmRleE9mKCBcImNhbGMoXCIgKSA+IC0xICkgPyBsZW5ndGggOiBcIjEwMHZ3XCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxlbmd0aCBpcyBzcGVjaWZpZWQgaW4gIGB2d2AgdW5pdHMsIHVzZSBgJWAgaW5zdGVhZCBzaW5jZSB0aGUgZGl2IHdl4oCZcmUgbWVhc3VyaW5nXG4gICAgICAgICAqIGlzIGluamVjdGVkIGF0IHRoZSB0b3Agb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBtYXliZSB3ZSBzaG91bGQgcHV0IHRoaXMgYmVoaW5kIGEgZmVhdHVyZSB0ZXN0IGZvciBgdndgPyBUaGUgcmlzayBvZiBkb2luZyB0aGlzIGlzIHBvc3NpYmxlIGJyb3dzZXIgaW5jb25zaXN0YW5jaWVzIHdpdGggdncgdnMgJVxuICAgICAgICAgKi9cbiAgICAgICAgbGVuZ3RoID0gbGVuZ3RoLnJlcGxhY2UoIFwidndcIiwgXCIlXCIgKTtcblxuICAgICAgICAvLyBDcmVhdGUgYSBjYWNoZWQgZWxlbWVudCBmb3IgZ2V0dGluZyBsZW5ndGggdmFsdWUgd2lkdGhzXG4gICAgICAgIGlmICggIXBmLmxlbmd0aEVsICkge1xuICAgICAgICAgICAgcGYubGVuZ3RoRWwgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApO1xuXG4gICAgICAgICAgICAvLyBQb3NpdGlvbmluZyBzdHlsZXMgaGVscCBwcmV2ZW50IHBhZGRpbmcvbWFyZ2luL3dpZHRoIG9uIGBodG1sYCBvciBgYm9keWAgZnJvbSB0aHJvd2luZyBjYWxjdWxhdGlvbnMgb2ZmLlxuICAgICAgICAgICAgcGYubGVuZ3RoRWwuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyOjA7ZGlzcGxheTpibG9jaztmb250LXNpemU6MWVtO2xlZnQ6MDttYXJnaW46MDtwYWRkaW5nOjA7cG9zaXRpb246YWJzb2x1dGU7dmlzaWJpbGl0eTpoaWRkZW5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBmLmxlbmd0aEVsLnN0eWxlLndpZHRoID0gbGVuZ3RoO1xuXG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHBmLmxlbmd0aEVsKTtcblxuICAgICAgICAvLyBBZGQgYSBjbGFzcywgc28gdGhhdCBldmVyeW9uZSBrbm93cyB3aGVyZSB0aGlzIGVsZW1lbnQgY29tZXMgZnJvbVxuICAgICAgICBwZi5sZW5ndGhFbC5jbGFzc05hbWUgPSBcImhlbHBlci1mcm9tLXBpY3R1cmVmaWxsLWpzXCI7XG5cbiAgICAgICAgaWYgKCBwZi5sZW5ndGhFbC5vZmZzZXRXaWR0aCA8PSAwICkge1xuICAgICAgICAgICAgLy8gU29tZXRoaW5nIGhhcyBnb25lIHdyb25nLiBgY2FsYygpYCBpcyBpbiB1c2UgYW5kIHVuc3VwcG9ydGVkLCBtb3N0IGxpa2VseS4gRGVmYXVsdCB0byBgMTAwdndgIChgMTAwJWAsIGZvciBicm9hZGVyIHN1cHBvcnQuKTpcbiAgICAgICAgICAgIHBmLmxlbmd0aEVsLnN0eWxlLndpZHRoID0gZG9jLmRvY3VtZW50RWxlbWVudC5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXRXaWR0aCA9IHBmLmxlbmd0aEVsLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKCBwZi5sZW5ndGhFbCApO1xuXG4gICAgICAgIHJldHVybiBvZmZzZXRXaWR0aDtcbiAgICB9O1xuXG4gICAgcGYuZGV0ZWN0VHlwZVN1cHBvcnQgPSBmdW5jdGlvbiggdHlwZSwgdHlwZVVyaSApIHtcbiAgICAgICAgLy8gYmFzZWQgb24gTW9kZXJuaXpyJ3MgbG9zc2xlc3MgaW1nLXdlYnAgdGVzdFxuICAgICAgICAvLyBub3RlOiBhc3luY2hyb25vdXNcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IHcuSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGYudHlwZXNbIHR5cGUgXSA9IGZhbHNlO1xuICAgICAgICAgICAgcGljdHVyZWZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwZi50eXBlc1sgdHlwZSBdID0gaW1hZ2Uud2lkdGggPT09IDE7XG4gICAgICAgICAgICBwaWN0dXJlZmlsbCgpO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZS5zcmMgPSB0eXBlVXJpO1xuXG4gICAgICAgIHJldHVybiBcInBlbmRpbmdcIjtcbiAgICB9O1xuICAgIC8vIGNvbnRhaW5lciBvZiBzdXBwb3J0ZWQgbWltZSB0eXBlcyB0aGF0IG9uZSBtaWdodCBuZWVkIHRvIHF1YWxpZnkgYmVmb3JlIHVzaW5nXG4gICAgcGYudHlwZXMgPSBwZi50eXBlcyB8fCB7fTtcblxuICAgIC8vIEFkZCBzdXBwb3J0IGZvciBzdGFuZGFyZCBtaW1lIHR5cGVzXG4gICAgcGYudHlwZXNbIFwiaW1hZ2UvanBlZ1wiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL2dpZlwiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3BuZ1wiIF0gPSB0cnVlO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3N2Zyt4bWxcIiBdID0gZG9jLmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9mZWF0dXJlI0ltYWdlXCIsIFwiMS4xXCIpO1xuICAgIHBmLnR5cGVzWyBcImltYWdlL3dlYnBcIiBdID0gcGYuZGV0ZWN0VHlwZVN1cHBvcnQoXCJpbWFnZS93ZWJwXCIsIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmg0QUFBQlhSVUpRVmxBNFRCRUFBQUF2QUFBQUFBZlEvLzczdi8rQmlPaC9BQUE9XCIpO1xuXG4gICAgcGYudmVyaWZ5VHlwZVN1cHBvcnQgPSBmdW5jdGlvbiggc291cmNlICkge1xuICAgICAgICB2YXIgdHlwZSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICk7XG4gICAgICAgIC8vIGlmIHR5cGUgYXR0cmlidXRlIGV4aXN0cywgcmV0dXJuIHRlc3QgcmVzdWx0LCBvdGhlcndpc2UgcmV0dXJuIHRydWVcbiAgICAgICAgaWYgKCB0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwZlR5cGUgPSBwZi50eXBlc1sgdHlwZSBdO1xuICAgICAgICAgICAgLy8gaWYgdGhlIHR5cGUgdGVzdCBpcyBhIGZ1bmN0aW9uLCBydW4gaXQgYW5kIHJldHVybiBcInBlbmRpbmdcIiBzdGF0dXMuIFRoZSBmdW5jdGlvbiB3aWxsIHJlcnVuIHBpY3R1cmVmaWxsIG9uIHBlbmRpbmcgZWxlbWVudHMgb25jZSBmaW5pc2hlZC5cbiAgICAgICAgICAgIGlmICggdHlwZW9mIHBmVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBwZlR5cGUgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGYudHlwZXNbIHR5cGUgXSA9IHBmLmRldGVjdFR5cGVTdXBwb3J0KCB0eXBlLCBwZlR5cGUgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgcGZUeXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICAgICAgICAgICAgcGZUeXBlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGZUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhbiBpbmRpdmlkdWFsIGBzaXplYCBhbmQgcmV0dXJucyB0aGUgbGVuZ3RoLCBhbmQgb3B0aW9uYWwgbWVkaWEgcXVlcnlcbiAgICBwZi5wYXJzZVNpemUgPSBmdW5jdGlvbiggc291cmNlU2l6ZVN0ciApIHtcbiAgICAgICAgdmFyIG1hdGNoID0gLyhcXChbXildK1xcKSk/XFxzKiguKykvZy5leGVjKCBzb3VyY2VTaXplU3RyICk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYTogbWF0Y2ggJiYgbWF0Y2hbMV0sXG4gICAgICAgICAgICBsZW5ndGg6IG1hdGNoICYmIG1hdGNoWzJdXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIFRha2VzIGEgc3RyaW5nIG9mIHNpemVzIGFuZCByZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgYXMgYSBudW1iZXJcbiAgICBwZi5maW5kV2lkdGhGcm9tU291cmNlU2l6ZSA9IGZ1bmN0aW9uKCBzb3VyY2VTaXplTGlzdFN0ciApIHtcbiAgICAgICAgLy8gU3BsaXQgdXAgc291cmNlIHNpemUgbGlzdCwgaWUgKCBtYXgtd2lkdGg6IDMwZW0gKSAxMDAlLCAoIG1heC13aWR0aDogNTBlbSApIDUwJSwgMzMlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIChtaW4td2lkdGg6MzBlbSkgY2FsYygzMCUgLSAxNXB4KVxuICAgICAgICB2YXIgc291cmNlU2l6ZUxpc3QgPSBwZi50cmltKCBzb3VyY2VTaXplTGlzdFN0ciApLnNwbGl0KCAvXFxzKixcXHMqLyApLFxuICAgICAgICAgICAgd2lubmluZ0xlbmd0aDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZVNpemVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgLy8gTWF0Y2ggPG1lZGlhLWNvbmRpdGlvbj4/IGxlbmd0aCwgaWUgKCBtaW4td2lkdGg6IDUwZW0gKSAxMDAlXG4gICAgICAgICAgICB2YXIgc291cmNlU2l6ZSA9IHNvdXJjZVNpemVMaXN0WyBpIF0sXG4gICAgICAgICAgICAvLyBTcGxpdCBcIiggbWluLXdpZHRoOiA1MGVtICkgMTAwJVwiIGludG8gc2VwYXJhdGUgc3RyaW5nc1xuICAgICAgICAgICAgICAgIHBhcnNlZFNpemUgPSBwZi5wYXJzZVNpemUoIHNvdXJjZVNpemUgKSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBwYXJzZWRTaXplLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBtZWRpYSA9IHBhcnNlZFNpemUubWVkaWE7XG5cbiAgICAgICAgICAgIGlmICggIWxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggIW1lZGlhIHx8IHBmLm1hdGNoZXNNZWRpYSggbWVkaWEgKSApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBtZWRpYSBxdWVyeSBvciBpdCBtYXRjaGVzLCBjaG9vc2UgdGhpcyBhcyBvdXIgd2lubmluZyBsZW5ndGhcbiAgICAgICAgICAgICAgICAvLyBhbmQgZW5kIGFsZ29yaXRobVxuICAgICAgICAgICAgICAgIHdpbm5pbmdMZW5ndGggPSBsZW5ndGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXNzIHRoZSBsZW5ndGggdG8gYSBtZXRob2QgdGhhdCBjYW4gcHJvcGVybHkgZGV0ZXJtaW5lIGxlbmd0aFxuICAgICAgICAvLyBpbiBwaXhlbHMgYmFzZWQgb24gdGhlc2UgZm9ybWF0czogaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLXZhbHVlcy0zLyNsZW5ndGgtdmFsdWVcbiAgICAgICAgcmV0dXJuIHBmLmdldFdpZHRoRnJvbUxlbmd0aCggd2lubmluZ0xlbmd0aCApO1xuICAgIH07XG5cbiAgICBwZi5wYXJzZVNyY3NldCA9IGZ1bmN0aW9uKCBzcmNzZXQgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxvdCBvZiB0aGlzIHdhcyBwdWxsZWQgZnJvbSBCb3JpcyBTbXVz4oCZIHBhcnNlciBmb3IgdGhlIG5vdy1kZWZ1bmN0IFdIQVRXRyBgc3Jjc2V0YFxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vYm9yaXNtdXMvc3Jjc2V0LXBvbHlmaWxsL2Jsb2IvbWFzdGVyL2pzL3NyY3NldC1pbmZvLmpzXG4gICAgICAgICAqXG4gICAgICAgICAqIDEuIExldCBpbnB1dCAoYHNyY3NldGApIGJlIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhpcyBhbGdvcml0aG0uXG4gICAgICAgICAqIDIuIExldCBwb3NpdGlvbiBiZSBhIHBvaW50ZXIgaW50byBpbnB1dCwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSBzdGFydCBvZiB0aGUgc3RyaW5nLlxuICAgICAgICAgKiAzLiBMZXQgcmF3IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IG9yZGVyZWQgbGlzdCBvZiBVUkxzIHdpdGggYXNzb2NpYXRlZFxuICAgICAgICAgKiAgICB1bnBhcnNlZCBkZXNjcmlwdG9ycy4gVGhlIG9yZGVyIG9mIGVudHJpZXMgaW4gdGhlIGxpc3QgaXMgdGhlIG9yZGVyIGluIHdoaWNoIGVudHJpZXNcbiAgICAgICAgICogICAgYXJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcblxuICAgICAgICB3aGlsZSAoIHNyY3NldCAhPT0gXCJcIiApIHtcbiAgICAgICAgICAgIHNyY3NldCA9IHNyY3NldC5yZXBsYWNlKCAvXlxccysvZywgXCJcIiApO1xuXG4gICAgICAgICAgICAvLyA1LiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyB0aGF0IGFyZSBub3Qgc3BhY2UgY2hhcmFjdGVycywgYW5kIGxldCB0aGF0IGJlIHVybC5cbiAgICAgICAgICAgIHZhciBwb3MgPSBzcmNzZXQuc2VhcmNoKC9cXHMvZyksXG4gICAgICAgICAgICAgICAgdXJsLCBkZXNjcmlwdG9yID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKCBwb3MgIT09IC0xICkge1xuICAgICAgICAgICAgICAgIHVybCA9IHNyY3NldC5zbGljZSggMCwgcG9zICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHVybC5zbGljZSgtMSk7XG5cbiAgICAgICAgICAgICAgICAvLyA2LiBJZiB1cmwgZW5kcyB3aXRoIGEgVSswMDJDIENPTU1BIGNoYXJhY3RlciAoLCksIHJlbW92ZSB0aGF0IGNoYXJhY3RlciBmcm9tIHVybFxuICAgICAgICAgICAgICAgIC8vIGFuZCBsZXQgZGVzY3JpcHRvcnMgYmUgdGhlIGVtcHR5IHN0cmluZy4gT3RoZXJ3aXNlLCBmb2xsb3cgdGhlc2Ugc3Vic3RlcHNcbiAgICAgICAgICAgICAgICAvLyA2LjEuIElmIHVybCBpcyBlbXB0eSwgdGhlbiBqdW1wIHRvIHRoZSBzdGVwIGxhYmVsZWQgZGVzY3JpcHRvciBwYXJzZXIuXG5cbiAgICAgICAgICAgICAgICBpZiAoIGxhc3QgPT09IFwiLFwiIHx8IHVybCA9PT0gXCJcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoIC8sKyQvLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcmNzZXQgPSBzcmNzZXQuc2xpY2UoIHBvcyArIDEgKTtcblxuICAgICAgICAgICAgICAgIC8vIDYuMi4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IFUrMDAyQyBDT01NQSBjaGFyYWN0ZXJzICgsKSwgYW5kXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRoYXQgYmUgZGVzY3JpcHRvcnMuXG4gICAgICAgICAgICAgICAgaWYgKCBkZXNjcmlwdG9yID09PSBudWxsICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzY3BvcyA9IHNyY3NldC5pbmRleE9mKCBcIixcIiApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIGRlc2Nwb3MgIT09IC0xICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IHNyY3NldC5zbGljZSggMCwgZGVzY3BvcyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Jjc2V0ID0gc3Jjc2V0LnNsaWNlKCBkZXNjcG9zICsgMSApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IHNyY3NldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY3NldCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybCA9IHNyY3NldDtcbiAgICAgICAgICAgICAgICBzcmNzZXQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA3LiBBZGQgdXJsIHRvIHJhdyBjYW5kaWRhdGVzLCBhc3NvY2lhdGVkIHdpdGggZGVzY3JpcHRvcnMuXG4gICAgICAgICAgICBpZiAoIHVybCB8fCBkZXNjcmlwdG9yICkge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yOiBkZXNjcmlwdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIHBmLnBhcnNlRGVzY3JpcHRvciA9IGZ1bmN0aW9uKCBkZXNjcmlwdG9yLCBzaXplc2F0dHIgKSB7XG4gICAgICAgIC8vIDExLiBEZXNjcmlwdG9yIHBhcnNlcjogTGV0IGNhbmRpZGF0ZXMgYmUgYW4gaW5pdGlhbGx5IGVtcHR5IHNvdXJjZSBzZXQuIFRoZSBvcmRlciBvZiBlbnRyaWVzIGluIHRoZSBsaXN0XG4gICAgICAgIC8vIGlzIHRoZSBvcmRlciBpbiB3aGljaCBlbnRyaWVzIGFyZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgICAgdmFyIHNpemVzID0gc2l6ZXNhdHRyIHx8IFwiMTAwdndcIixcbiAgICAgICAgICAgIHNpemVEZXNjcmlwdG9yID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnJlcGxhY2UoIC8oXlxccyt8XFxzKyQpL2csIFwiXCIgKSxcbiAgICAgICAgICAgIHdpZHRoSW5Dc3NQaXhlbHMgPSBwZi5maW5kV2lkdGhGcm9tU291cmNlU2l6ZSggc2l6ZXMgKSxcbiAgICAgICAgICAgIHJlc0NhbmRpZGF0ZTtcblxuICAgICAgICBpZiAoIHNpemVEZXNjcmlwdG9yICkge1xuICAgICAgICAgICAgdmFyIHNwbGl0RGVzY3JpcHRvciA9IHNpemVEZXNjcmlwdG9yLnNwbGl0KFwiIFwiKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNwbGl0RGVzY3JpcHRvci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyID0gc3BsaXREZXNjcmlwdG9yWyBpIF0sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RjaGFyID0gY3VyciAmJiBjdXJyLnNsaWNlKCBjdXJyLmxlbmd0aCAtIDEgKTtcblxuICAgICAgICAgICAgICAgIGlmICggKCBsYXN0Y2hhciA9PT0gXCJoXCIgfHwgbGFzdGNoYXIgPT09IFwid1wiICkgJiYgIXBmLnNpemVzU3VwcG9ydGVkICkge1xuICAgICAgICAgICAgICAgICAgICByZXNDYW5kaWRhdGUgPSBwYXJzZUZsb2F0KCAoIHBhcnNlSW50KCBjdXJyLCAxMCApIC8gd2lkdGhJbkNzc1BpeGVscyApICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggbGFzdGNoYXIgPT09IFwieFwiICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gY3VyciAmJiBwYXJzZUZsb2F0KCBjdXJyLCAxMCApO1xuICAgICAgICAgICAgICAgICAgICByZXNDYW5kaWRhdGUgPSByZXMgJiYgIWlzTmFOKCByZXMgKSA/IHJlcyA6IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNDYW5kaWRhdGUgfHwgMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBzcmNzZXQgaW4gdGhlIGZvcm0gb2YgdXJsL1xuICAgICAqIGV4LiBcImltYWdlcy9waWMtbWVkaXVtLnBuZyAxeCwgaW1hZ2VzL3BpYy1tZWRpdW0tMngucG5nIDJ4XCIgb3JcbiAgICAgKiAgICAgXCJpbWFnZXMvcGljLW1lZGl1bS5wbmcgNDAwdywgaW1hZ2VzL3BpYy1tZWRpdW0tMngucG5nIDgwMHdcIiBvclxuICAgICAqICAgICBcImltYWdlcy9waWMtc21hbGwucG5nXCJcbiAgICAgKiBHZXQgYW4gYXJyYXkgb2YgaW1hZ2UgY2FuZGlkYXRlcyBpbiB0aGUgZm9ybSBvZlxuICAgICAqICAgICAge3VybDogXCIvZm9vL2Jhci5wbmdcIiwgcmVzb2x1dGlvbjogMX1cbiAgICAgKiB3aGVyZSByZXNvbHV0aW9uIGlzIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jcmVzb2x1dGlvbi12YWx1ZVxuICAgICAqIElmIHNpemVzIGlzIHNwZWNpZmllZCwgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkXG4gICAgICovXG4gICAgcGYuZ2V0Q2FuZGlkYXRlc0Zyb21Tb3VyY2VTZXQgPSBmdW5jdGlvbiggc3Jjc2V0LCBzaXplcyApIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBwZi5wYXJzZVNyY3NldCggc3Jjc2V0ICksXG4gICAgICAgICAgICBmb3JtYXR0ZWRDYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBjYW5kaWRhdGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrICkge1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcblxuICAgICAgICAgICAgZm9ybWF0dGVkQ2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmw6IGNhbmRpZGF0ZS51cmwsXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogcGYucGFyc2VEZXNjcmlwdG9yKCBjYW5kaWRhdGUuZGVzY3JpcHRvciwgc2l6ZXMgKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZENhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGlmIGl0J3MgYW4gaW1nIGVsZW1lbnQgYW5kIGl0IGhhcyBhIHNyY3NldCBwcm9wZXJ0eSxcbiAgICAgKiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYXR0cmlidXRlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHNyY1xuICAgICAqICh0aGUgcHJvcGVydHkncyBleGlzdGVuY2UgaW5mZXJzIG5hdGl2ZSBzcmNzZXQgc3VwcG9ydCwgYW5kIGEgc3Jjc2V0LXN1cHBvcnRpbmcgYnJvd3NlciB3aWxsIHByaW9yaXRpemUgc3Jjc2V0J3MgdmFsdWUgb3ZlciBvdXIgd2lubmluZyBwaWN0dXJlIGNhbmRpZGF0ZSlcbiAgICAgKiB0aGlzIG1vdmVzIHNyY3NldCdzIHZhbHVlIHRvIG1lbW9yeSBmb3IgbGF0ZXIgdXNlIGFuZCByZW1vdmVzIHRoZSBhdHRyXG4gICAgICovXG4gICAgcGYuZG9kZ2VTcmNzZXQgPSBmdW5jdGlvbiggaW1nICkge1xuICAgICAgICBpZiAoIGltZy5zcmNzZXQgKSB7XG4gICAgICAgICAgICBpbWdbIHBmLm5zIF0uc3Jjc2V0ID0gaW1nLnNyY3NldDtcbiAgICAgICAgICAgIGltZy5zcmNzZXQgPSBcIlwiO1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSggXCJkYXRhLXBmc3Jjc2V0XCIsIGltZ1sgcGYubnMgXS5zcmNzZXQgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBY2NlcHQgYSBzb3VyY2Ugb3IgaW1nIGVsZW1lbnQgYW5kIHByb2Nlc3MgaXRzIHNyY3NldCBhbmQgc2l6ZXMgYXR0cnNcbiAgICBwZi5wcm9jZXNzU291cmNlU2V0ID0gZnVuY3Rpb24oIGVsICkge1xuICAgICAgICB2YXIgc3Jjc2V0ID0gZWwuZ2V0QXR0cmlidXRlKCBcInNyY3NldFwiICksXG4gICAgICAgICAgICBzaXplcyA9IGVsLmdldEF0dHJpYnV0ZSggXCJzaXplc1wiICksXG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgLy8gaWYgaXQncyBhbiBpbWcgZWxlbWVudCwgdXNlIHRoZSBjYWNoZWQgc3Jjc2V0IHByb3BlcnR5IChkZWZpbmVkIG9yIG5vdClcbiAgICAgICAgaWYgKCBlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIklNR1wiICYmIGVsWyBwZi5ucyBdICYmIGVsWyBwZi5ucyBdLnNyY3NldCApIHtcbiAgICAgICAgICAgIHNyY3NldCA9IGVsWyBwZi5ucyBdLnNyY3NldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggc3Jjc2V0ICkge1xuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHBmLmdldENhbmRpZGF0ZXNGcm9tU291cmNlU2V0KCBzcmNzZXQsIHNpemVzICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfTtcblxuICAgIHBmLmJhY2tmYWNlVmlzaWJpbGl0eUZpeCA9IGZ1bmN0aW9uKCBwaWNJbWcgKSB7XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3Njb3R0amVobC9waWN0dXJlZmlsbC9pc3N1ZXMvMzMyXG4gICAgICAgIHZhciBzdHlsZSA9IHBpY0ltZy5zdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9IFwid2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5XCIgaW4gc3R5bGUsXG4gICAgICAgICAgICBjdXJyZW50Wm9vbSA9IHN0eWxlLnpvb207XG5cbiAgICAgICAgaWYgKFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgc3R5bGUuem9vbSA9IFwiLjk5OVwiO1xuXG4gICAgICAgICAgICBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSBwaWNJbWcub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgIHN0eWxlLnpvb20gPSBjdXJyZW50Wm9vbTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwZi5zZXRJbmhlcmVudFNpemUgPSBmdW5jdGlvbiggcmVzLCBwaWNJbWcsIHJlYWR5U3RhdGUgKSB7XG4gICAgICAgIHZhciByZWFkeSA9IHJlYWR5U3RhdGUgIT09IHVuZGVmaW5lZCA/IHJlYWR5U3RhdGUgOiBwaWNJbWcuY29tcGxldGUsXG4gICAgICAgICAgICB3aWR0aFByZXNldCA9ICFyZWFkeSAmJiBwaWNJbWcuZ2V0QXR0cmlidXRlICYmIHBpY0ltZy5nZXRBdHRyaWJ1dGUoIFwid2lkdGhcIiApICE9PSBudWxsLFxuICAgICAgICAgICAgc2V0V2lkdGggPSBmdW5jdGlvbiggcmVzLCBwaWNJbWcgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCBwaWNJbWcuc2V0QXR0cmlidXRlICkge1xuICAgICAgICAgICAgICAgICAgICBwaWNJbWcuc2V0QXR0cmlidXRlKCBcIndpZHRoXCIsIHBpY0ltZy5uYXR1cmFsV2lkdGggLyByZXMgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2lkdGhJbnRlcnZhbDtcblxuICAgICAgICBpZiAoIHJlYWR5ICYmIHJlcyAmJiAhd2lkdGhQcmVzZXQgKSB7XG4gICAgICAgICAgICBzZXRXaWR0aCggcmVzLCBwaWNJbWcgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICFyZWFkeSApIHtcbiAgICAgICAgICAgIHdpZHRoSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBmLnNldEluaGVyZW50U2l6ZSggcmVzLCBwaWNJbWcsIHBpY0ltZy5jb21wbGV0ZSApO1xuICAgICAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwZi5hcHBseUJlc3RDYW5kaWRhdGUgPSBmdW5jdGlvbiggY2FuZGlkYXRlcywgcGljSW1nICkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgYmVzdENhbmRpZGF0ZTtcblxuICAgICAgICBjYW5kaWRhdGVzLnNvcnQoIHBmLmFzY2VuZGluZ1NvcnQgKTtcblxuICAgICAgICBsZW5ndGggPSBjYW5kaWRhdGVzLmxlbmd0aDtcbiAgICAgICAgYmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGxlbmd0aCAtIDEgXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbIGkgXTtcbiAgICAgICAgICAgIGlmICggY2FuZGlkYXRlLnJlc29sdXRpb24gPj0gcGYuZ2V0RHByKCkgKSB7XG4gICAgICAgICAgICAgICAgYmVzdENhbmRpZGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggYmVzdENhbmRpZGF0ZSAmJiAhcGYuZW5kc1dpdGgoIHBpY0ltZy5zcmMsIGJlc3RDYW5kaWRhdGUudXJsICkgKSB7XG4gICAgICAgICAgICBpZiAoIHBmLnJlc3RyaWN0c01peGVkQ29udGVudCgpICYmIGJlc3RDYW5kaWRhdGUudXJsLnN1YnN0cigwLCBcImh0dHA6XCIubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHA6XCIgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCB3aW5kb3cuY29uc29sZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiQmxvY2tlZCBtaXhlZCBjb250ZW50IGltYWdlIFwiICsgYmVzdENhbmRpZGF0ZS51cmwgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBpY0ltZy5zcmMgPSBiZXN0Q2FuZGlkYXRlLnVybDtcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50U3JjIGF0dHJpYnV0ZSBhbmQgcHJvcGVydHkgdG8gbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vcGljdHVyZS5yZXNwb25zaXZlaW1hZ2VzLm9yZy8jdGhlLWltZy1lbGVtZW50XG4gICAgICAgICAgICAgICAgcGljSW1nLmN1cnJlbnRTcmMgPSBwaWNJbWcuc3JjO1xuXG4gICAgICAgICAgICAgICAgcGYuYmFja2ZhY2VWaXNpYmlsaXR5Rml4KCBwaWNJbWcgKTtcbiAgICAgICAgICAgICAgICBwZi5zZXRJbmhlcmVudFNpemUoIGJlc3RDYW5kaWRhdGUucmVzb2x1dGlvbiwgcGljSW1nICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcGYuYXNjZW5kaW5nU29ydCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuICAgICAgICByZXR1cm4gYS5yZXNvbHV0aW9uIC0gYi5yZXNvbHV0aW9uO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbiBJRTksIDxzb3VyY2U+IGVsZW1lbnRzIGdldCByZW1vdmVkIGlmIHRoZXkgYXJlbid0IGNoaWxkcmVuIG9mXG4gICAgICogdmlkZW8gZWxlbWVudHMuIFRodXMsIHdlIGNvbmRpdGlvbmFsbHkgd3JhcCBzb3VyY2UgZWxlbWVudHNcbiAgICAgKiB1c2luZyA8IS0tW2lmIElFIDldPjx2aWRlbyBzdHlsZT1cImRpc3BsYXk6IG5vbmU7XCI+PCFbZW5kaWZdLS0+XG4gICAgICogYW5kIG11c3QgYWNjb3VudCBmb3IgdGhhdCBoZXJlIGJ5IG1vdmluZyB0aG9zZSBzb3VyY2UgZWxlbWVudHNcbiAgICAgKiBiYWNrIGludG8gdGhlIHBpY3R1cmUgZWxlbWVudC5cbiAgICAgKi9cbiAgICBwZi5yZW1vdmVWaWRlb1NoaW0gPSBmdW5jdGlvbiggcGljdHVyZSApIHtcbiAgICAgICAgdmFyIHZpZGVvcyA9IHBpY3R1cmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwidmlkZW9cIiApO1xuICAgICAgICBpZiAoIHZpZGVvcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB2YXIgdmlkZW8gPSB2aWRlb3NbIDAgXSxcbiAgICAgICAgICAgICAgICB2c291cmNlcyA9IHZpZGVvLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInNvdXJjZVwiICk7XG4gICAgICAgICAgICB3aGlsZSAoIHZzb3VyY2VzLmxlbmd0aCApIHtcbiAgICAgICAgICAgICAgICBwaWN0dXJlLmluc2VydEJlZm9yZSggdnNvdXJjZXNbIDAgXSwgdmlkZW8gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdmlkZW8gZWxlbWVudCBvbmNlIHdlJ3JlIGZpbmlzaGVkIHJlbW92aW5nIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgdmlkZW8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggdmlkZW8gKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFsbCBgaW1nYCBlbGVtZW50cywgYW5kIGFkZCB0aGVtIHRvIHRoZSBjYW5kaWRhdGUgbGlzdCBpZiB0aGV5IGhhdmVcbiAgICAgKiBhIGBwaWN0dXJlYCBwYXJlbnQsIGEgYHNpemVzYCBhdHRyaWJ1dGUgaW4gYmFzaWMgYHNyY3NldGAgc3VwcG9ydGluZyBicm93c2VycyxcbiAgICAgKiBhIGBzcmNzZXRgIGF0dHJpYnV0ZSBhdCBhbGwsIGFuZCB0aGV5IGhhdmVu4oCZdCBiZWVuIGV2YWx1YXRlZCBhbHJlYWR5LlxuICAgICAqL1xuICAgIHBmLmdldEFsbEVsZW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlbGVtcyA9IFtdLFxuICAgICAgICAgICAgaW1ncyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJpbWdcIiApO1xuXG4gICAgICAgIGZvciAoIHZhciBoID0gMCwgbGVuID0gaW1ncy5sZW5ndGg7IGggPCBsZW47IGgrKyApIHtcbiAgICAgICAgICAgIHZhciBjdXJySW1nID0gaW1nc1sgaCBdO1xuXG4gICAgICAgICAgICBpZiAoIGN1cnJJbWcucGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIiB8fFxuICAgICAgICAgICAgICAgICggY3VyckltZy5nZXRBdHRyaWJ1dGUoIFwic3Jjc2V0XCIgKSAhPT0gbnVsbCApIHx8IGN1cnJJbWdbIHBmLm5zIF0gJiYgY3VyckltZ1sgcGYubnMgXS5zcmNzZXQgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgICAgZWxlbXMucHVzaCggY3VyckltZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtcztcbiAgICB9O1xuXG4gICAgcGYuZ2V0TWF0Y2ggPSBmdW5jdGlvbiggaW1nLCBwaWN0dXJlICkge1xuICAgICAgICB2YXIgc291cmNlcyA9IHBpY3R1cmUuY2hpbGROb2RlcyxcbiAgICAgICAgICAgIG1hdGNoO1xuXG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBjaGlsZCwgYW5kIGlmIHRoZXkgaGF2ZSBtZWRpYSBxdWVyaWVzLCBldmFsdWF0ZSB0aGVtXG4gICAgICAgIGZvciAoIHZhciBqID0gMCwgc2xlbiA9IHNvdXJjZXMubGVuZ3RoOyBqIDwgc2xlbjsgaisrICkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbIGogXTtcblxuICAgICAgICAgICAgLy8gaWdub3JlIG5vbi1lbGVtZW50IG5vZGVzXG4gICAgICAgICAgICBpZiAoIHNvdXJjZS5ub2RlVHlwZSAhPT0gMSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGl0dGluZyB0aGUgYGltZ2AgZWxlbWVudCB0aGF0IHN0YXJ0ZWQgZXZlcnl0aGluZyBzdG9wcyB0aGUgc2VhcmNoIGZvciBgc291cmNlc2AuXG4gICAgICAgICAgICAvLyBJZiBubyBwcmV2aW91cyBgc291cmNlYCBtYXRjaGVzLCB0aGUgYGltZ2AgaXRzZWxmIGlzIGV2YWx1YXRlZCBsYXRlci5cbiAgICAgICAgICAgIGlmICggc291cmNlID09PSBpbWcgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgbm9uLWBzb3VyY2VgIG5vZGVzXG4gICAgICAgICAgICBpZiAoIHNvdXJjZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNPVVJDRVwiICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgaGFzIHRoZSBgc3JjYCBwcm9wZXJ0eSBzZXQsIHRocm93IGEgd2FybmluZyBpbiB0aGUgY29uc29sZVxuICAgICAgICAgICAgaWYgKCBzb3VyY2UuZ2V0QXR0cmlidXRlKCBcInNyY1wiICkgIT09IG51bGwgJiYgdHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgYHNyY2AgYXR0cmlidXRlIGlzIGludmFsaWQgb24gYHBpY3R1cmVgIGBzb3VyY2VgIGVsZW1lbnQ7IGluc3RlYWQsIHVzZSBgc3Jjc2V0YC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtZWRpYSA9IHNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwibWVkaWFcIiApO1xuXG4gICAgICAgICAgICAvLyBpZiBzb3VyY2UgZG9lcyBub3QgaGF2ZSBhIHNyY3NldCBhdHRyaWJ1dGUsIHNraXBcbiAgICAgICAgICAgIGlmICggIXNvdXJjZS5nZXRBdHRyaWJ1dGUoIFwic3Jjc2V0XCIgKSApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBubyBtZWRpYSBzcGVjaWZpZWQsIE9SIHcubWF0Y2hNZWRpYSBpcyBzdXBwb3J0ZWRcbiAgICAgICAgICAgIGlmICggKCAhbWVkaWEgfHwgcGYubWF0Y2hlc01lZGlhKCBtZWRpYSApICkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVTdXBwb3J0ZWQgPSBwZi52ZXJpZnlUeXBlU3VwcG9ydCggc291cmNlICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIHR5cGVTdXBwb3J0ZWQgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCB0eXBlU3VwcG9ydGVkID09PSBcInBlbmRpbmdcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcGljdHVyZWZpbGwoIG9wdCApIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGZpcnN0TWF0Y2gsXG4gICAgICAgICAgICBjYW5kaWRhdGVzLFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdCB8fCB7fTtcblxuICAgICAgICBlbGVtZW50cyA9IG9wdGlvbnMuZWxlbWVudHMgfHwgcGYuZ2V0QWxsRWxlbWVudHMoKTtcblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIGVsZW1lbnRzXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgcGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IHBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1sgaSBdO1xuICAgICAgICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgZmlyc3RNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHNraXAgbm9uLWBpbWdgIG5vZGVzXG4gICAgICAgICAgICBpZiAoIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJJTUdcIiApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZXhwYW5kbyBmb3IgY2FjaGluZyBkYXRhIG9uIHRoZSBpbWdcbiAgICAgICAgICAgIGlmICggIWVsZW1lbnRbIHBmLm5zIF0gKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFsgcGYubnMgXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZCwgc2tpcCBpdCB1bmxlc3NcbiAgICAgICAgICAgIC8vIGBvcHRpb25zLnJlZXZhbHVhdGVgIGlzIHNldCB0byB0cnVlICggdGhpcywgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHJ1bm5pbmcgYHBpY3R1cmVmaWxsYCBvbiBgcmVzaXplYCApLlxuICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy5yZWV2YWx1YXRlICYmIGVsZW1lbnRbIHBmLm5zIF0uZXZhbHVhdGVkICkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBgaW1nYCBpcyBpbiBhIGBwaWN0dXJlYCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIHBhcmVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIiApIHtcblxuICAgICAgICAgICAgICAgIC8vIElFOSB2aWRlbyB3b3JrYXJvdW5kXG4gICAgICAgICAgICAgICAgcGYucmVtb3ZlVmlkZW9TaGltKCBwYXJlbnQgKTtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgbWF0Y2ggd2hpY2ggbWlnaHQgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJucyBmYWxzZSBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgc291cmNlXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGUgcmV0dXJuIHR5cGUgaGVyZSBpcyBicnV0YWwsIGNsZWFudXBcbiAgICAgICAgICAgICAgICBmaXJzdE1hdGNoID0gcGYuZ2V0TWF0Y2goIGVsZW1lbnQsIHBhcmVudCApO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IHNvdXJjZXMgYXJlIHBlbmRpbmcgaW4gdGhpcyBwaWN0dXJlIGR1ZSB0byBhc3luYyB0eXBlIHRlc3QocylcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGV2YWx1YXRlZCBhdHRyIGFuZCBza2lwIGZvciBub3cgKCB0aGUgcGVuZGluZyB0ZXN0IHdpbGxcbiAgICAgICAgICAgICAgICAvLyByZXJ1biBwaWN0dXJlZmlsbCBvbiB0aGlzIGVsZW1lbnQgd2hlbiBjb21wbGV0ZSlcbiAgICAgICAgICAgICAgICBpZiAoIGZpcnN0TWF0Y2ggPT09IGZhbHNlICkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhY2hlIGFuZCByZW1vdmUgYHNyY3NldGAgaWYgcHJlc2VudCBhbmQgd2XigJlyZSBnb2luZyB0byBiZSBkb2luZyBgcGljdHVyZWAvYHNyY3NldGAvYHNpemVzYCBwb2x5ZmlsbGluZyB0byBpdC5cbiAgICAgICAgICAgIGlmICggcGFyZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUElDVFVSRVwiIHx8XG4gICAgICAgICAgICAgICAgKCBlbGVtZW50LnNyY3NldCAmJiAhcGYuc3Jjc2V0U3VwcG9ydGVkICkgfHxcbiAgICAgICAgICAgICAgICAoICFwZi5zaXplc1N1cHBvcnRlZCAmJiAoIGVsZW1lbnQuc3Jjc2V0ICYmIGVsZW1lbnQuc3Jjc2V0LmluZGV4T2YoXCJ3XCIpID4gLTEgKSApICkge1xuICAgICAgICAgICAgICAgIHBmLmRvZGdlU3Jjc2V0KCBlbGVtZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggZmlyc3RNYXRjaCApIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gcGYucHJvY2Vzc1NvdXJjZVNldCggZmlyc3RNYXRjaCApO1xuICAgICAgICAgICAgICAgIHBmLmFwcGx5QmVzdENhbmRpZGF0ZSggY2FuZGlkYXRlcywgZWxlbWVudCApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzb3VyY2VzIG1hdGNoZWQsIHNvIHdl4oCZcmUgZG93biB0byBwcm9jZXNzaW5nIHRoZSBpbm5lciBgaW1nYCBhcyBhIHNvdXJjZS5cbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzID0gcGYucHJvY2Vzc1NvdXJjZVNldCggZWxlbWVudCApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCBlbGVtZW50LnNyY3NldCA9PT0gdW5kZWZpbmVkIHx8IGVsZW1lbnRbIHBmLm5zIF0uc3Jjc2V0ICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFaXRoZXIgYHNyY3NldGAgaXMgY29tcGxldGVseSB1bnN1cHBvcnRlZCwgb3Igd2UgbmVlZCB0byBwb2x5ZmlsbCBgc2l6ZXNgIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICAgICAgICAgICAgIHBmLmFwcGx5QmVzdENhbmRpZGF0ZSggY2FuZGlkYXRlcywgZWxlbWVudCApO1xuICAgICAgICAgICAgICAgIH0gLy8gRWxzZSwgcmVzb2x1dGlvbi1vbmx5IGBzcmNzZXRgIGlzIHN1cHBvcnRlZCBuYXRpdmVseS5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGV2YWx1YXRlZCB0byB0cnVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlcGFyc2luZ1xuICAgICAgICAgICAgZWxlbWVudFsgcGYubnMgXS5ldmFsdWF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBwaWN0dXJlIHBvbHlmaWxsIGJ5IHBvbGxpbmcgdGhlIGRvY3VtZW50IGFuZCBydW5uaW5nXG4gICAgICogdGhlIHBvbHlmaWxsIGV2ZXJ5IDI1MG1zIHVudGlsIHRoZSBkb2N1bWVudCBpcyByZWFkeS5cbiAgICAgKiBBbHNvIGF0dGFjaGVzIHBpY3R1cmVmaWxsIG9uIHJlc2l6ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1blBpY3R1cmVmaWxsKCkge1xuICAgICAgICBwaWN0dXJlZmlsbCgpO1xuICAgICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLCBzdG9wIGNoZWNraW5nIGZvciBuZXcgaW1hZ2VzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVkL2RvbXJlYWR5L2Jsb2IvbWFzdGVyL3JlYWR5LmpzI0wxNVxuICAgICAgICAgICAgcGljdHVyZWZpbGwoKTtcblxuICAgICAgICAgICAgaWYgKCAvXmxvYWRlZHxeaXxeYy8udGVzdCggZG9jLnJlYWR5U3RhdGUgKSApIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKCBpbnRlcnZhbElkICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyNTAgKTtcblxuICAgICAgICBmdW5jdGlvbiBjaGVja1Jlc2l6ZSgpIHtcbiAgICAgICAgICAgIHZhciByZXNpemVUaHJvdHRsZTtcblxuICAgICAgICAgICAgaWYgKCAhdy5fcGljdHVyZWZpbGxXb3JraW5nICkge1xuICAgICAgICAgICAgICAgIHcuX3BpY3R1cmVmaWxsV29ya2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdy5jbGVhclRpbWVvdXQoIHJlc2l6ZVRocm90dGxlICk7XG4gICAgICAgICAgICAgICAgcmVzaXplVGhyb3R0bGUgPSB3LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBwaWN0dXJlZmlsbCh7IHJlZXZhbHVhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHcuX3BpY3R1cmVmaWxsV29ya2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIDYwICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHcuYWRkRXZlbnRMaXN0ZW5lciApIHtcbiAgICAgICAgICAgIHcuYWRkRXZlbnRMaXN0ZW5lciggXCJyZXNpemVcIiwgY2hlY2tSZXNpemUsIGZhbHNlICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHcuYXR0YWNoRXZlbnQgKSB7XG4gICAgICAgICAgICB3LmF0dGFjaEV2ZW50KCBcIm9ucmVzaXplXCIsIGNoZWNrUmVzaXplICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBydW5QaWN0dXJlZmlsbCgpO1xuXG4gICAgLyogZXhwb3NlIG1ldGhvZHMgZm9yIHRlc3RpbmcgKi9cbiAgICBwaWN0dXJlZmlsbC5fID0gcGY7XG5cbiAgICAvKiBleHBvc2UgcGljdHVyZWZpbGwgKi9cbiAgICBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuICAgICAgICAvLyBDb21tb25KUywganVzdCBleHBvcnRcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBwaWN0dXJlZmlsbDtcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAgICAgLy8gQU1EIHN1cHBvcnRcbiAgICAgICAgZGVmaW5lKCBmdW5jdGlvbigpIHsgcmV0dXJuIHBpY3R1cmVmaWxsOyB9ICk7XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgdyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgLy8gSWYgbm8gQU1EIGFuZCB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIsIGF0dGFjaCB0byB3aW5kb3dcbiAgICAgICAgdy5waWN0dXJlZmlsbCA9IHBpY3R1cmVmaWxsO1xuICAgIH1cblxufSApKCB3aW5kb3csIHdpbmRvdy5kb2N1bWVudCwgbmV3IHdpbmRvdy5JbWFnZSgpICk7Il19
