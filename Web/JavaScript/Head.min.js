(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * Head.min.js
 */

var WebFontJSONLoader = require('webfontjsonloader'),
    supportsWoff2 = require('./Utilities/Feature-Detects/Woff2.js'),
    webFontUrl = (supportsWoff2) ? 'WebFonts/DevButze.woff2.json': 'WebFonts/DevButze.woff.json';

// Load the WebFont.
new WebFontJSONLoader({
	url: webFontUrl,
	timeStamp: '?t=01152015',
    JSONPCallbackName:  'devButzeAttachFonts',
	namespace: 'devButze',
    callback: function() {
        console.log('Whee')
    }
});

// Require some polyfills
require('./Vendor/Polyfills/Html5shiv.js');
require('./Vendor/Polyfills/Picturefill.js');
 
},{"./Utilities/Feature-Detects/Woff2.js":2,"./Vendor/Polyfills/Html5shiv.js":3,"./Vendor/Polyfills/Picturefill.js":4,"webfontjsonloader":5}],2:[function(require,module,exports){
/**
 * supportsWoff2
 * @description A simple feature test for the WOFF2 font format.
 * @see https://github.com/filamentgroup/woff2-feature-test/blob/master/woff2.js
 */
var supportsWoff2 = (function(win){
    'use strict';

	if(!("FontFace" in win)) {
		return false;
	}

    var f = new win.FontFace("t", 'url( "data:application/font-woff2,4e" ) format( "woff2" )', {});
    f.load();

	return f.status === 'loading';
})(window);


module.exports = supportsWoff2;
},{}],3:[function(require,module,exports){
/**
 * @preserve HTML5 Shiv 3.7.2 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
 */
;(function(window, document) {
    /*jshint evil:true */
    /** version */
    var version = '3.7.2';

    /** Preset options */
    var options = window.html5 || {};

    /** Used to skip problem elements */
    var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

    /** Not all elements can be cloned in IE **/
    var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

    /** Detect whether the browser supports default html5 styles */
    var supportsHtml5Styles;

    /** Name of the expando, to work with multiple documents or to re-shiv one document */
    var expando = '_html5shiv';

    /** The id for the the documents expando */
    var expanID = 0;

    /** Cached data for each document */
    var expandoData = {};

    /** Detect whether the browser supports unknown elements */
    var supportsUnknownElements;

    (function() {
        try {
            var a = document.createElement('a');
            a.innerHTML = '<xyz></xyz>';
            //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
            supportsHtml5Styles = ('hidden' in a);

            supportsUnknownElements = a.childNodes.length == 1 || (function() {
                // assign a false positive if unable to shiv
                (document.createElement)('a');
                var frag = document.createDocumentFragment();
                return (
                    typeof frag.cloneNode == 'undefined' ||
                        typeof frag.createDocumentFragment == 'undefined' ||
                        typeof frag.createElement == 'undefined'
                    );
            }());
        } catch(e) {
            // assign a false positive if detection fails => unable to shiv
            supportsHtml5Styles = true;
            supportsUnknownElements = true;
        }

    }());

    /*--------------------------------------------------------------------------*/

    /**
     * Creates a style sheet with the given CSS text and adds it to the document.
     * @private
     * @param {Document} ownerDocument The document.
     * @param {String} cssText The CSS text.
     * @returns {StyleSheet} The style element.
     */
    function addStyleSheet(ownerDocument, cssText) {
        var p = ownerDocument.createElement('p'),
            parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

        p.innerHTML = 'x<style>' + cssText + '</style>';
        return parent.insertBefore(p.lastChild, parent.firstChild);
    }

    /**
     * Returns the value of `html5.elements` as an array.
     * @private
     * @returns {Array} An array of shived element node names.
     */
    function getElements() {
        var elements = html5.elements;
        return typeof elements == 'string' ? elements.split(' ') : elements;
    }

    /**
     * Extends the built-in list of html5 elements
     * @memberOf html5
     * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
     * @param {Document} ownerDocument The context document.
     */
    function addElements(newElements, ownerDocument) {
        var elements = html5.elements;
        if(typeof elements != 'string'){
            elements = elements.join(' ');
        }
        if(typeof newElements != 'string'){
            newElements = newElements.join(' ');
        }
        html5.elements = elements +' '+ newElements;
        shivDocument(ownerDocument);
    }

    /**
     * Returns the data associated to the given document
     * @private
     * @param {Document} ownerDocument The document.
     * @returns {Object} An object of data.
     */
    function getExpandoData(ownerDocument) {
        var data = expandoData[ownerDocument[expando]];
        if (!data) {
            data = {};
            expanID++;
            ownerDocument[expando] = expanID;
            expandoData[expanID] = data;
        }
        return data;
    }

    /**
     * returns a shived element for the given nodeName and document
     * @memberOf html5
     * @param {String} nodeName name of the element
     * @param {Document} ownerDocument The context document.
     * @returns {Object} The shived element.
     */
    function createElement(nodeName, ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createElement(nodeName);
        }
        if (!data) {
            data = getExpandoData(ownerDocument);
        }
        var node;

        if (data.cache[nodeName]) {
            node = data.cache[nodeName].cloneNode();
        } else if (saveClones.test(nodeName)) {
            node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
        } else {
            node = data.createElem(nodeName);
        }

        // Avoid adding some elements to fragments in IE < 9 because
        // * Attributes like `name` or `type` cannot be set/changed once an element
        //   is inserted into a document/fragment
        // * Link elements with `src` attributes that are inaccessible, as with
        //   a 403 response, will cause the tab/window to crash
        // * Script elements appended to fragments will execute when their `src`
        //   or `text` property is set
        return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
    }

    /**
     * returns a shived DocumentFragment for the given document
     * @memberOf html5
     * @param {Document} ownerDocument The context document.
     * @returns {Object} The shived DocumentFragment.
     */
    function createDocumentFragment(ownerDocument, data){
        if (!ownerDocument) {
            ownerDocument = document;
        }
        if(supportsUnknownElements){
            return ownerDocument.createDocumentFragment();
        }
        data = data || getExpandoData(ownerDocument);
        var clone = data.frag.cloneNode(),
            i = 0,
            elems = getElements(),
            l = elems.length;
        for(;i<l;i++){
            clone.createElement(elems[i]);
        }
        return clone;
    }

    /**
     * Shivs the `createElement` and `createDocumentFragment` methods of the document.
     * @private
     * @param {Document|DocumentFragment} ownerDocument The document.
     * @param {Object} data of the document.
     */
    function shivMethods(ownerDocument, data) {
        if (!data.cache) {
            data.cache = {};
            data.createElem = ownerDocument.createElement;
            data.createFrag = ownerDocument.createDocumentFragment;
            data.frag = data.createFrag();
        }


        ownerDocument.createElement = function(nodeName) {
            //abort shiv
            if (!html5.shivMethods) {
                return data.createElem(nodeName);
            }
            return createElement(nodeName, ownerDocument, data);
        };

        ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' +
            'var n=f.cloneNode(),c=n.createElement;' +
            'h.shivMethods&&(' +
            // unroll the `createElement` calls
            getElements().join().replace(/[\w\-:]+/g, function(nodeName) {
                data.createElem(nodeName);
                data.frag.createElement(nodeName);
                return 'c("' + nodeName + '")';
            }) +
            ');return n}'
        )(html5, data.frag);
    }

    /*--------------------------------------------------------------------------*/

    /**
     * Shivs the given document.
     * @memberOf html5
     * @param {Document} ownerDocument The document to shiv.
     * @returns {Document} The shived document.
     */
    function shivDocument(ownerDocument) {
        if (!ownerDocument) {
            ownerDocument = document;
        }
        var data = getExpandoData(ownerDocument);

        if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
            data.hasCSS = !!addStyleSheet(ownerDocument,
                // corrects block display not defined in IE6/7/8/9
                'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' +
                    // adds styling not present in IE6/7/8/9
                    'mark{background:#FF0;color:#000}' +
                    // hides non-rendered elements
                    'template{display:none}'
            );
        }
        if (!supportsUnknownElements) {
            shivMethods(ownerDocument, data);
        }
        return ownerDocument;
    }

    /*--------------------------------------------------------------------------*/

    /**
     * The `html5` object is exposed so that more elements can be shived and
     * existing shiving can be detected on iframes.
     * @type Object
     * @example
     *
     * // options can be changed before the script is included
     * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
     */
    var html5 = {

        /**
         * An array or space separated string of node names of the elements to shiv.
         * @memberOf html5
         * @type Array|String
         */
        'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video',

        /**
         * current version of html5shiv
         */
        'version': version,

        /**
         * A flag to indicate that the HTML5 style sheet should be inserted.
         * @memberOf html5
         * @type Boolean
         */
        'shivCSS': (options.shivCSS !== false),

        /**
         * Is equal to true if a browser supports creating unknown/HTML5 elements
         * @memberOf html5
         * @type boolean
         */
        'supportsUnknownElements': supportsUnknownElements,

        /**
         * A flag to indicate that the document's `createElement` and `createDocumentFragment`
         * methods should be overwritten.
         * @memberOf html5
         * @type Boolean
         */
        'shivMethods': (options.shivMethods !== false),

        /**
         * A string to describe the type of `html5` object ("default" or "default print").
         * @memberOf html5
         * @type String
         */
        'type': 'default',

        // shivs the document according to the specified `html5` object options
        'shivDocument': shivDocument,

        //creates a shived element
        createElement: createElement,

        //creates a shived documentFragment
        createDocumentFragment: createDocumentFragment,

        //extends list of elements
        addElements: addElements
    };

    /*--------------------------------------------------------------------------*/

    // expose html5
    window.html5 = html5;

    // shiv the document
    shivDocument(document);

}(this, document));
},{}],4:[function(require,module,exports){
/*! Picturefill - v2.2.0 - 2014-12-19
 * http://scottjehl.github.io/picturefill
 * Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
    "use strict";

    // For browsers that support matchMedium api such as IE 9 and webkit
    var styleMedia = (window.styleMedia || window.media);

    // For those that don't support matchMedium
    if (!styleMedia) {
        var style       = document.createElement('style'),
            script      = document.getElementsByTagName('script')[0],
            info        = null;

        style.type  = 'text/css';
        style.id    = 'matchmediajs-test';

        script.parentNode.insertBefore(style, script);

        // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
        info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

        styleMedia = {
            matchMedium: function(media) {
                var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                if (style.styleSheet) {
                    style.styleSheet.cssText = text;
                } else {
                    style.textContent = text;
                }

                // Test if media query is true or false
                return info.width === '1px';
            }
        };
    }

    return function(media) {
        return {
            matches: styleMedia.matchMedium(media || 'all'),
            media: media || 'all'
        };
    };
}());
/*! Picturefill - Responsive Images that work today.
 *  Author: Scott Jehl, Filament Group, 2012 ( new proposal implemented by Shawn Jansepar )
 *  License: MIT/GPLv2
 *  Spec: http://picture.responsiveimages.org/
 */
(function( w, doc, image ) {
    // Enable strict mode
    "use strict";

    // If picture is supported, well, that's awesome. Let's get outta here...
    if ( w.HTMLPictureElement ) {
        w.picturefill = function() { };
        return;
    }

    // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
    doc.createElement( "picture" );

    // local object for method references and testing exposure
    var pf = w.picturefill || {};

    // namespace
    pf.ns = "picturefill";

    // srcset support test
    (function() {
        pf.srcsetSupported = "srcset" in image;
        pf.sizesSupported = "sizes" in image;
    })();

    // just a string trim workaround
    pf.trim = function( str ) {
        return str.trim ? str.trim() : str.replace( /^\s+|\s+$/g, "" );
    };

    // just a string endsWith workaround
    pf.endsWith = function( str, suffix ) {
        return str.endsWith ? str.endsWith( suffix ) : str.indexOf( suffix, str.length - suffix.length ) !== -1;
    };

    /**
     * Shortcut method for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
     */
    pf.restrictsMixedContent = function() {
        return w.location.protocol === "https:";
    };
    /**
     * Shortcut method for matchMedia ( for easy overriding in tests )
     */

    pf.matchesMedia = function( media ) {
        return w.matchMedia && w.matchMedia( media ).matches;
    };

    // Shortcut method for `devicePixelRatio` ( for easy overriding in tests )
    pf.getDpr = function() {
        return ( w.devicePixelRatio || 1 );
    };

    /**
     * Get width in css pixel value from a "length" value
     * http://dev.w3.org/csswg/css-values-3/#length-value
     */
    pf.getWidthFromLength = function( length ) {
        // If a length is specified and doesn’t contain a percentage, and it is greater than 0 or using `calc`, use it. Else, use the `100vw` default.
        length = length && length.indexOf( "%" ) > -1 === false && ( parseFloat( length ) > 0 || length.indexOf( "calc(" ) > -1 ) ? length : "100vw";

        /**
         * If length is specified in  `vw` units, use `%` instead since the div we’re measuring
         * is injected at the top of the document.
         *
         * TODO: maybe we should put this behind a feature test for `vw`? The risk of doing this is possible browser inconsistancies with vw vs %
         */
        length = length.replace( "vw", "%" );

        // Create a cached element for getting length value widths
        if ( !pf.lengthEl ) {
            pf.lengthEl = doc.createElement( "div" );

            // Positioning styles help prevent padding/margin/width on `html` or `body` from throwing calculations off.
            pf.lengthEl.style.cssText = "border:0;display:block;font-size:1em;left:0;margin:0;padding:0;position:absolute;visibility:hidden";
        }

        pf.lengthEl.style.width = length;

        doc.body.appendChild(pf.lengthEl);

        // Add a class, so that everyone knows where this element comes from
        pf.lengthEl.className = "helper-from-picturefill-js";

        if ( pf.lengthEl.offsetWidth <= 0 ) {
            // Something has gone wrong. `calc()` is in use and unsupported, most likely. Default to `100vw` (`100%`, for broader support.):
            pf.lengthEl.style.width = doc.documentElement.offsetWidth + "px";
        }

        var offsetWidth = pf.lengthEl.offsetWidth;

        doc.body.removeChild( pf.lengthEl );

        return offsetWidth;
    };

    pf.detectTypeSupport = function( type, typeUri ) {
        // based on Modernizr's lossless img-webp test
        // note: asynchronous
        var image = new w.Image();
        image.onerror = function() {
            pf.types[ type ] = false;
            picturefill();
        };
        image.onload = function() {
            pf.types[ type ] = image.width === 1;
            picturefill();
        };
        image.src = typeUri;

        return "pending";
    };
    // container of supported mime types that one might need to qualify before using
    pf.types = pf.types || {};

    // Add support for standard mime types
    pf.types[ "image/jpeg" ] = true;
    pf.types[ "image/gif" ] = true;
    pf.types[ "image/png" ] = true;
    pf.types[ "image/svg+xml" ] = doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");
    pf.types[ "image/webp" ] = pf.detectTypeSupport("image/webp", "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=");

    pf.verifyTypeSupport = function( source ) {
        var type = source.getAttribute( "type" );
        // if type attribute exists, return test result, otherwise return true
        if ( type === null || type === "" ) {
            return true;
        } else {
            var pfType = pf.types[ type ];
            // if the type test is a function, run it and return "pending" status. The function will rerun picturefill on pending elements once finished.
            if ( typeof pfType === "string" && pfType !== "pending") {
                pf.types[ type ] = pf.detectTypeSupport( type, pfType );
                return "pending";
            } else if ( typeof pfType === "function" ) {
                pfType();
                return "pending";
            } else {
                return pfType;
            }
        }
    };

    // Parses an individual `size` and returns the length, and optional media query
    pf.parseSize = function( sourceSizeStr ) {
        var match = /(\([^)]+\))?\s*(.+)/g.exec( sourceSizeStr );
        return {
            media: match && match[1],
            length: match && match[2]
        };
    };

    // Takes a string of sizes and returns the width in pixels as a number
    pf.findWidthFromSourceSize = function( sourceSizeListStr ) {
        // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
        //                            or (min-width:30em) calc(30% - 15px)
        var sourceSizeList = pf.trim( sourceSizeListStr ).split( /\s*,\s*/ ),
            winningLength;

        for ( var i = 0, len = sourceSizeList.length; i < len; i++ ) {
            // Match <media-condition>? length, ie ( min-width: 50em ) 100%
            var sourceSize = sourceSizeList[ i ],
            // Split "( min-width: 50em ) 100%" into separate strings
                parsedSize = pf.parseSize( sourceSize ),
                length = parsedSize.length,
                media = parsedSize.media;

            if ( !length ) {
                continue;
            }
            if ( !media || pf.matchesMedia( media ) ) {
                // if there is no media query or it matches, choose this as our winning length
                // and end algorithm
                winningLength = length;
                break;
            }
        }

        // pass the length to a method that can properly determine length
        // in pixels based on these formats: http://dev.w3.org/csswg/css-values-3/#length-value
        return pf.getWidthFromLength( winningLength );
    };

    pf.parseSrcset = function( srcset ) {
        /**
         * A lot of this was pulled from Boris Smus’ parser for the now-defunct WHATWG `srcset`
         * https://github.com/borismus/srcset-polyfill/blob/master/js/srcset-info.js
         *
         * 1. Let input (`srcset`) be the value passed to this algorithm.
         * 2. Let position be a pointer into input, initially pointing at the start of the string.
         * 3. Let raw candidates be an initially empty ordered list of URLs with associated
         *    unparsed descriptors. The order of entries in the list is the order in which entries
         *    are added to the list.
         */
        var candidates = [];

        while ( srcset !== "" ) {
            srcset = srcset.replace( /^\s+/g, "" );

            // 5. Collect a sequence of characters that are not space characters, and let that be url.
            var pos = srcset.search(/\s/g),
                url, descriptor = null;

            if ( pos !== -1 ) {
                url = srcset.slice( 0, pos );

                var last = url.slice(-1);

                // 6. If url ends with a U+002C COMMA character (,), remove that character from url
                // and let descriptors be the empty string. Otherwise, follow these substeps
                // 6.1. If url is empty, then jump to the step labeled descriptor parser.

                if ( last === "," || url === "" ) {
                    url = url.replace( /,+$/, "" );
                    descriptor = "";
                }
                srcset = srcset.slice( pos + 1 );

                // 6.2. Collect a sequence of characters that are not U+002C COMMA characters (,), and
                // let that be descriptors.
                if ( descriptor === null ) {
                    var descpos = srcset.indexOf( "," );
                    if ( descpos !== -1 ) {
                        descriptor = srcset.slice( 0, descpos );
                        srcset = srcset.slice( descpos + 1 );
                    } else {
                        descriptor = srcset;
                        srcset = "";
                    }
                }
            } else {
                url = srcset;
                srcset = "";
            }

            // 7. Add url to raw candidates, associated with descriptors.
            if ( url || descriptor ) {
                candidates.push({
                    url: url,
                    descriptor: descriptor
                });
            }
        }
        return candidates;
    };

    pf.parseDescriptor = function( descriptor, sizesattr ) {
        // 11. Descriptor parser: Let candidates be an initially empty source set. The order of entries in the list
        // is the order in which entries are added to the list.
        var sizes = sizesattr || "100vw",
            sizeDescriptor = descriptor && descriptor.replace( /(^\s+|\s+$)/g, "" ),
            widthInCssPixels = pf.findWidthFromSourceSize( sizes ),
            resCandidate;

        if ( sizeDescriptor ) {
            var splitDescriptor = sizeDescriptor.split(" ");

            for (var i = splitDescriptor.length - 1; i >= 0; i--) {
                var curr = splitDescriptor[ i ],
                    lastchar = curr && curr.slice( curr.length - 1 );

                if ( ( lastchar === "h" || lastchar === "w" ) && !pf.sizesSupported ) {
                    resCandidate = parseFloat( ( parseInt( curr, 10 ) / widthInCssPixels ) );
                } else if ( lastchar === "x" ) {
                    var res = curr && parseFloat( curr, 10 );
                    resCandidate = res && !isNaN( res ) ? res : 1;
                }
            }
        }
        return resCandidate || 1;
    };

    /**
     * Takes a srcset in the form of url/
     * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
     *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
     *     "images/pic-small.png"
     * Get an array of image candidates in the form of
     *      {url: "/foo/bar.png", resolution: 1}
     * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
     * If sizes is specified, resolution is calculated
     */
    pf.getCandidatesFromSourceSet = function( srcset, sizes ) {
        var candidates = pf.parseSrcset( srcset ),
            formattedCandidates = [];

        for ( var i = 0, len = candidates.length; i < len; i++ ) {
            var candidate = candidates[ i ];

            formattedCandidates.push({
                url: candidate.url,
                resolution: pf.parseDescriptor( candidate.descriptor, sizes )
            });
        }
        return formattedCandidates;
    };

    /**
     * if it's an img element and it has a srcset property,
     * we need to remove the attribute so we can manipulate src
     * (the property's existence infers native srcset support, and a srcset-supporting browser will prioritize srcset's value over our winning picture candidate)
     * this moves srcset's value to memory for later use and removes the attr
     */
    pf.dodgeSrcset = function( img ) {
        if ( img.srcset ) {
            img[ pf.ns ].srcset = img.srcset;
            img.srcset = "";
            img.setAttribute( "data-pfsrcset", img[ pf.ns ].srcset );
        }
    };

    // Accept a source or img element and process its srcset and sizes attrs
    pf.processSourceSet = function( el ) {
        var srcset = el.getAttribute( "srcset" ),
            sizes = el.getAttribute( "sizes" ),
            candidates = [];

        // if it's an img element, use the cached srcset property (defined or not)
        if ( el.nodeName.toUpperCase() === "IMG" && el[ pf.ns ] && el[ pf.ns ].srcset ) {
            srcset = el[ pf.ns ].srcset;
        }

        if ( srcset ) {
            candidates = pf.getCandidatesFromSourceSet( srcset, sizes );
        }
        return candidates;
    };

    pf.backfaceVisibilityFix = function( picImg ) {
        // See: https://github.com/scottjehl/picturefill/issues/332
        var style = picImg.style || {},
            WebkitBackfaceVisibility = "webkitBackfaceVisibility" in style,
            currentZoom = style.zoom;

        if (WebkitBackfaceVisibility) {
            style.zoom = ".999";

            WebkitBackfaceVisibility = picImg.offsetWidth;

            style.zoom = currentZoom;
        }
    };

    pf.setInherentSize = function( res, picImg, readyState ) {
        var ready = readyState !== undefined ? readyState : picImg.complete,
            widthPreset = !ready && picImg.getAttribute && picImg.getAttribute( "width" ) !== null,
            setWidth = function( res, picImg ) {
                if ( picImg.setAttribute ) {
                    picImg.setAttribute( "width", picImg.naturalWidth / res );
                }
            },
            widthInterval;

        if ( ready && res && !widthPreset ) {
            setWidth( res, picImg );
        }
        if ( !ready ) {
            widthInterval = setTimeout(function() {
                pf.setInherentSize( res, picImg, picImg.complete );
            }, 250);
        }
    };

    pf.applyBestCandidate = function( candidates, picImg ) {
        var candidate,
            length,
            bestCandidate;

        candidates.sort( pf.ascendingSort );

        length = candidates.length;
        bestCandidate = candidates[ length - 1 ];

        for ( var i = 0; i < length; i++ ) {
            candidate = candidates[ i ];
            if ( candidate.resolution >= pf.getDpr() ) {
                bestCandidate = candidate;
                break;
            }
        }

        if ( bestCandidate && !pf.endsWith( picImg.src, bestCandidate.url ) ) {
            if ( pf.restrictsMixedContent() && bestCandidate.url.substr(0, "http:".length).toLowerCase() === "http:" ) {
                if ( window.console !== undefined ) {
                    console.warn( "Blocked mixed content image " + bestCandidate.url );
                }
            } else {
                picImg.src = bestCandidate.url;
                // currentSrc attribute and property to match
                // http://picture.responsiveimages.org/#the-img-element
                picImg.currentSrc = picImg.src;

                pf.backfaceVisibilityFix( picImg );
                pf.setInherentSize( bestCandidate.resolution, picImg );
            }
        }
    };

    pf.ascendingSort = function( a, b ) {
        return a.resolution - b.resolution;
    };

    /**
     * In IE9, <source> elements get removed if they aren't children of
     * video elements. Thus, we conditionally wrap source elements
     * using <!--[if IE 9]><video style="display: none;"><![endif]-->
     * and must account for that here by moving those source elements
     * back into the picture element.
     */
    pf.removeVideoShim = function( picture ) {
        var videos = picture.getElementsByTagName( "video" );
        if ( videos.length ) {
            var video = videos[ 0 ],
                vsources = video.getElementsByTagName( "source" );
            while ( vsources.length ) {
                picture.insertBefore( vsources[ 0 ], video );
            }
            // Remove the video element once we're finished removing its children
            video.parentNode.removeChild( video );
        }
    };

    /**
     * Find all `img` elements, and add them to the candidate list if they have
     * a `picture` parent, a `sizes` attribute in basic `srcset` supporting browsers,
     * a `srcset` attribute at all, and they haven’t been evaluated already.
     */
    pf.getAllElements = function() {
        var elems = [],
            imgs = doc.getElementsByTagName( "img" );

        for ( var h = 0, len = imgs.length; h < len; h++ ) {
            var currImg = imgs[ h ];

            if ( currImg.parentNode.nodeName.toUpperCase() === "PICTURE" ||
                ( currImg.getAttribute( "srcset" ) !== null ) || currImg[ pf.ns ] && currImg[ pf.ns ].srcset !== null ) {
                elems.push( currImg );
            }
        }
        return elems;
    };

    pf.getMatch = function( img, picture ) {
        var sources = picture.childNodes,
            match;

        // Go through each child, and if they have media queries, evaluate them
        for ( var j = 0, slen = sources.length; j < slen; j++ ) {
            var source = sources[ j ];

            // ignore non-element nodes
            if ( source.nodeType !== 1 ) {
                continue;
            }

            // Hitting the `img` element that started everything stops the search for `sources`.
            // If no previous `source` matches, the `img` itself is evaluated later.
            if ( source === img ) {
                return match;
            }

            // ignore non-`source` nodes
            if ( source.nodeName.toUpperCase() !== "SOURCE" ) {
                continue;
            }
            // if it's a source element that has the `src` property set, throw a warning in the console
            if ( source.getAttribute( "src" ) !== null && typeof console !== undefined ) {
                console.warn("The `src` attribute is invalid on `picture` `source` element; instead, use `srcset`.");
            }

            var media = source.getAttribute( "media" );

            // if source does not have a srcset attribute, skip
            if ( !source.getAttribute( "srcset" ) ) {
                continue;
            }

            // if there's no media specified, OR w.matchMedia is supported
            if ( ( !media || pf.matchesMedia( media ) ) ) {
                var typeSupported = pf.verifyTypeSupport( source );

                if ( typeSupported === true ) {
                    match = source;
                    break;
                } else if ( typeSupported === "pending" ) {
                    return false;
                }
            }
        }

        return match;
    };

    function picturefill( opt ) {
        var elements,
            element,
            parent,
            firstMatch,
            candidates,
            options = opt || {};

        elements = options.elements || pf.getAllElements();

        // Loop through all elements
        for ( var i = 0, plen = elements.length; i < plen; i++ ) {
            element = elements[ i ];
            parent = element.parentNode;
            firstMatch = undefined;
            candidates = undefined;

            // immediately skip non-`img` nodes
            if ( element.nodeName.toUpperCase() !== "IMG" ) {
                continue;
            }

            // expando for caching data on the img
            if ( !element[ pf.ns ] ) {
                element[ pf.ns ] = {};
            }

            // if the element has already been evaluated, skip it unless
            // `options.reevaluate` is set to true ( this, for example,
            // is set to true when running `picturefill` on `resize` ).
            if ( !options.reevaluate && element[ pf.ns ].evaluated ) {
                continue;
            }

            // if `img` is in a `picture` element
            if ( parent.nodeName.toUpperCase() === "PICTURE" ) {

                // IE9 video workaround
                pf.removeVideoShim( parent );

                // return the first match which might undefined
                // returns false if there is a pending source
                // TODO the return type here is brutal, cleanup
                firstMatch = pf.getMatch( element, parent );

                // if any sources are pending in this picture due to async type test(s)
                // remove the evaluated attr and skip for now ( the pending test will
                // rerun picturefill on this element when complete)
                if ( firstMatch === false ) {
                    continue;
                }
            } else {
                firstMatch = undefined;
            }

            // Cache and remove `srcset` if present and we’re going to be doing `picture`/`srcset`/`sizes` polyfilling to it.
            if ( parent.nodeName.toUpperCase() === "PICTURE" ||
                ( element.srcset && !pf.srcsetSupported ) ||
                ( !pf.sizesSupported && ( element.srcset && element.srcset.indexOf("w") > -1 ) ) ) {
                pf.dodgeSrcset( element );
            }

            if ( firstMatch ) {
                candidates = pf.processSourceSet( firstMatch );
                pf.applyBestCandidate( candidates, element );
            } else {
                // No sources matched, so we’re down to processing the inner `img` as a source.
                candidates = pf.processSourceSet( element );

                if ( element.srcset === undefined || element[ pf.ns ].srcset ) {
                    // Either `srcset` is completely unsupported, or we need to polyfill `sizes` functionality.
                    pf.applyBestCandidate( candidates, element );
                } // Else, resolution-only `srcset` is supported natively.
            }

            // set evaluated to true to avoid unnecessary reparsing
            element[ pf.ns ].evaluated = true;
        }
    }

    /**
     * Sets up picture polyfill by polling the document and running
     * the polyfill every 250ms until the document is ready.
     * Also attaches picturefill on resize
     */
    function runPicturefill() {
        picturefill();
        var intervalId = setInterval( function() {
            // When the document has finished loading, stop checking for new images
            // https://github.com/ded/domready/blob/master/ready.js#L15
            picturefill();

            if ( /^loaded|^i|^c/.test( doc.readyState ) ) {
                clearInterval( intervalId );
                return;
            }
        }, 250 );

        function checkResize() {
            var resizeThrottle;

            if ( !w._picturefillWorking ) {
                w._picturefillWorking = true;
                w.clearTimeout( resizeThrottle );
                resizeThrottle = w.setTimeout( function() {
                    picturefill({ reevaluate: true });
                    w._picturefillWorking = false;
                }, 60 );
            }
        }

        if ( w.addEventListener ) {
            w.addEventListener( "resize", checkResize, false );
        } else if ( w.attachEvent ) {
            w.attachEvent( "onresize", checkResize );
        }
    }

    runPicturefill();

    /* expose methods for testing */
    picturefill._ = pf;

    /* expose picturefill */
    if ( typeof module === "object" && typeof module.exports === "object" ) {
        // CommonJS, just export
        module.exports = picturefill;
    } else if ( typeof define === "function" && define.amd ) {
        // AMD support
        define( function() { return picturefill; } );
    }

    if ( typeof w === "object" ) {
        // If no AMD and we are in the browser, attach to window
        w.picturefill = picturefill;
    }

} )( window, window.document, new window.Image() );
},{}],5:[function(require,module,exports){
"use strict";

/* WebFontJSONLoader 0.0.2 | @license ISC */

(function (global, factory) {
    // If the env is browserify, export the factory using the module object.
    if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = factory(global);

        // If the env is AMD, register the Module as 'webfontjsonloader'.
    } else if (typeof define === "function" && define.amd) {
        define("webfontjsonloader", [], function () {
            return factory(global);
        });

        // If the env is a browser(without CJS or AMD support), export the factory into the global window object.
    } else {
        global.WebFontLoader = factory(global);
    }
})(window, function (global) {
    var doc = global.document;
    var headElement = doc.getElementsByTagName("head")[0];
    var storage = global.localStorage;
    var srcKey = "_font_src";
    var timeStampKey = "_font_timestamp";

    /*
     * WebFontLoader
     * @param options {Object} The options Object which initializes the loader.
     * @example
     * new WebFontLoader({
     *      url: 'fonts/webfont.json', // Path to the JSONP file.
     *      timeStamp: '?t=01072015', // Timestamp for the cache.
     *      JSONPCallbackName:  'callback', //JSONP callback name.
     * });
     * @constructor
     */
    var WebFontLoader = function () {
        var options = arguments[0] === undefined ? {} : arguments[0];
        this.url = options.url;
        this.timeStamp = options.timeStamp || new Date();
        this.namespace = options.namespace || "WebFontJSONLoader";
        this.callback = options.callback;
        this.callbackName = options.JSONPCallbackName || "WebFontJsonCallBack";

        if (!this._hasRequiredConstantsAndAPIs()) {
            return;
        }

        this.getWebFontStyles();
    };

    WebFontLoader.prototype._hasRequiredConstantsAndAPIs = function () {
        var bool = true;

        if (!_supportsLocalStorageAPI()) {
            console.info("WebFontJSONLoader: This browser does not support the localStorage API, aborting.");

            bool = false;
        }
        if (!this.url) {
            console.info("WebFontJSONLoader: No URL was found in the options object, aborting.");

            bool = false;
        }

        return bool;
    };
    var _supportsLocalStorageAPI = function () {
        var key = "test";

        try {
            storage.setItem(key, 1);
            storage.removeItem(key);

            return true;
        } catch (e) {
            return false;
        }
    };

    WebFontLoader.prototype.getWebFontStyles = function () {
        if (this._isLocalStorageSrcValid()) {
            this._createInlineStyles()._executeCallBack();
        } else {
            this._getStylesFromJSONP();
        }
    };

    WebFontLoader.prototype._isLocalStorageSrcValid = function () {
        var namespace = this.namespace;

        return storage.getItem(namespace + srcKey) && storage.getItem(namespace + timeStampKey) === this.timeStamp;
    };

    WebFontLoader.prototype._executeCallBack = function () {
        var callback = this.callback;

        if (!callback) {
            return;
        }

        callback();
    };

    WebFontLoader.prototype._getStylesFromJSONP = function () {
        // Renew the timestamp.
        storage.setItem(this.namespace + timeStampKey, this.timeStamp);

        // Make the JSONP callback accessible.
        global[this.callbackName] = this._JSONPCallback.bind(this);

        // Load the JSONP and run the callback.
        this._loadJSONP();
    };

    WebFontLoader.prototype._JSONPCallback = function (res) {
        var css = res.css;

        // Create the localStorage cache.
        storage.setItem(this.namespace + srcKey, css);

        this._createInlineStyles();

        // Remove this function from the global namespace.
        global[this.callbackName] = undefined;

        return this;
    };

    WebFontLoader.prototype._loadJSONP = function () {
        // Create the script element.
        var script = doc.createElement("script");
        script.type = "text/javascript";
        script.src = this.url;
        headElement.appendChild(script);
        headElement.removeChild(script);

        // Execute the callback as the JSONP file was loaded.
        script.onload = this._executeCallBack.bind(this);

        return this;
    };

    WebFontLoader.prototype._createInlineStyles = function () {
        var namespace = this.namespace;
        var css = storage.getItem(namespace + srcKey);

        // Create the style element.
        var style = doc.createElement("style");
        style.type = "text/css";
        style.appendChild(doc.createTextNode(css));
        headElement.appendChild(style);

        return this;
    };

    return WebFontLoader;
});

},{}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9Tb3VyY2VzL0phdmFTY3JpcHQvSGVhZC5qcyIsIi9Wb2x1bWVzL0RhdGEvR2l0SHViL2RldkJ1dHplL1NvdXJjZXMvSmF2YVNjcmlwdC9VdGlsaXRpZXMvRmVhdHVyZS1EZXRlY3RzL1dvZmYyLmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1ZlbmRvci9Qb2x5ZmlsbHMvSHRtbDVzaGl2LmpzIiwiL1ZvbHVtZXMvRGF0YS9HaXRIdWIvZGV2QnV0emUvU291cmNlcy9KYXZhU2NyaXB0L1ZlbmRvci9Qb2x5ZmlsbHMvUGljdHVyZWZpbGwuanMiLCIvVm9sdW1lcy9EYXRhL0dpdEh1Yi9kZXZCdXR6ZS9ub2RlX21vZHVsZXMvd2ViZm9udGpzb25sb2FkZXIvRGlzdC9XZWJGb250SlNPTkxvYWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qXG4gKiBIZWFkLm1pbi5qc1xuICovXG5cbnZhciBXZWJGb250SlNPTkxvYWRlciA9IHJlcXVpcmUoJ3dlYmZvbnRqc29ubG9hZGVyJyksXG4gICAgc3VwcG9ydHNXb2ZmMiA9IHJlcXVpcmUoJy4vVXRpbGl0aWVzL0ZlYXR1cmUtRGV0ZWN0cy9Xb2ZmMi5qcycpLFxuICAgIHdlYkZvbnRVcmwgPSAoc3VwcG9ydHNXb2ZmMikgPyAnV2ViRm9udHMvRGV2QnV0emUud29mZjIuanNvbic6ICdXZWJGb250cy9EZXZCdXR6ZS53b2ZmLmpzb24nO1xuXG4vLyBMb2FkIHRoZSBXZWJGb250LlxubmV3IFdlYkZvbnRKU09OTG9hZGVyKHtcblx0dXJsOiB3ZWJGb250VXJsLFxuXHR0aW1lU3RhbXA6ICc/dD0wMTE1MjAxNScsXG4gICAgSlNPTlBDYWxsYmFja05hbWU6ICAnZGV2QnV0emVBdHRhY2hGb250cycsXG5cdG5hbWVzcGFjZTogJ2RldkJ1dHplJyxcbiAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdXaGVlJylcbiAgICB9XG59KTtcblxuLy8gUmVxdWlyZSBzb21lIHBvbHlmaWxsc1xucmVxdWlyZSgnLi9WZW5kb3IvUG9seWZpbGxzL0h0bWw1c2hpdi5qcycpO1xucmVxdWlyZSgnLi9WZW5kb3IvUG9seWZpbGxzL1BpY3R1cmVmaWxsLmpzJyk7XG4gIiwiLyoqXG4gKiBzdXBwb3J0c1dvZmYyXG4gKiBAZGVzY3JpcHRpb24gQSBzaW1wbGUgZmVhdHVyZSB0ZXN0IGZvciB0aGUgV09GRjIgZm9udCBmb3JtYXQuXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9maWxhbWVudGdyb3VwL3dvZmYyLWZlYXR1cmUtdGVzdC9ibG9iL21hc3Rlci93b2ZmMi5qc1xuICovXG52YXIgc3VwcG9ydHNXb2ZmMiA9IChmdW5jdGlvbih3aW4pe1xuICAgICd1c2Ugc3RyaWN0JztcblxuXHRpZighKFwiRm9udEZhY2VcIiBpbiB3aW4pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cbiAgICB2YXIgZiA9IG5ldyB3aW4uRm9udEZhY2UoXCJ0XCIsICd1cmwoIFwiZGF0YTphcHBsaWNhdGlvbi9mb250LXdvZmYyLDRlXCIgKSBmb3JtYXQoIFwid29mZjJcIiApJywge30pO1xuICAgIGYubG9hZCgpO1xuXG5cdHJldHVybiBmLnN0YXR1cyA9PT0gJ2xvYWRpbmcnO1xufSkod2luZG93KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzV29mZjI7IiwiLyoqXG4gKiBAcHJlc2VydmUgSFRNTDUgU2hpdiAzLjcuMiB8IEBhZmFya2FzIEBqZGFsdG9uIEBqb25fbmVhbCBAcmVtIHwgTUlUL0dQTDIgTGljZW5zZWRcbiAqL1xuOyhmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4gICAgLypqc2hpbnQgZXZpbDp0cnVlICovXG4gICAgLyoqIHZlcnNpb24gKi9cbiAgICB2YXIgdmVyc2lvbiA9ICczLjcuMic7XG5cbiAgICAvKiogUHJlc2V0IG9wdGlvbnMgKi9cbiAgICB2YXIgb3B0aW9ucyA9IHdpbmRvdy5odG1sNSB8fCB7fTtcblxuICAgIC8qKiBVc2VkIHRvIHNraXAgcHJvYmxlbSBlbGVtZW50cyAqL1xuICAgIHZhciByZVNraXAgPSAvXjx8Xig/OmJ1dHRvbnxtYXB8c2VsZWN0fHRleHRhcmVhfG9iamVjdHxpZnJhbWV8b3B0aW9ufG9wdGdyb3VwKSQvaTtcblxuICAgIC8qKiBOb3QgYWxsIGVsZW1lbnRzIGNhbiBiZSBjbG9uZWQgaW4gSUUgKiovXG4gICAgdmFyIHNhdmVDbG9uZXMgPSAvXig/OmF8Ynxjb2RlfGRpdnxmaWVsZHNldHxoMXxoMnxoM3xoNHxoNXxoNnxpfGxhYmVsfGxpfG9sfHB8cXxzcGFufHN0cm9uZ3xzdHlsZXx0YWJsZXx0Ym9keXx0ZHx0aHx0cnx1bCkkL2k7XG5cbiAgICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgZGVmYXVsdCBodG1sNSBzdHlsZXMgKi9cbiAgICB2YXIgc3VwcG9ydHNIdG1sNVN0eWxlcztcblxuICAgIC8qKiBOYW1lIG9mIHRoZSBleHBhbmRvLCB0byB3b3JrIHdpdGggbXVsdGlwbGUgZG9jdW1lbnRzIG9yIHRvIHJlLXNoaXYgb25lIGRvY3VtZW50ICovXG4gICAgdmFyIGV4cGFuZG8gPSAnX2h0bWw1c2hpdic7XG5cbiAgICAvKiogVGhlIGlkIGZvciB0aGUgdGhlIGRvY3VtZW50cyBleHBhbmRvICovXG4gICAgdmFyIGV4cGFuSUQgPSAwO1xuXG4gICAgLyoqIENhY2hlZCBkYXRhIGZvciBlYWNoIGRvY3VtZW50ICovXG4gICAgdmFyIGV4cGFuZG9EYXRhID0ge307XG5cbiAgICAvKiogRGV0ZWN0IHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdW5rbm93biBlbGVtZW50cyAqL1xuICAgIHZhciBzdXBwb3J0c1Vua25vd25FbGVtZW50cztcblxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgYS5pbm5lckhUTUwgPSAnPHh5ej48L3h5ej4nO1xuICAgICAgICAgICAgLy9pZiB0aGUgaGlkZGVuIHByb3BlcnR5IGlzIGltcGxlbWVudGVkIHdlIGNhbiBhc3N1bWUsIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgYmFzaWMgSFRNTDUgU3R5bGVzXG4gICAgICAgICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gKCdoaWRkZW4nIGluIGEpO1xuXG4gICAgICAgICAgICBzdXBwb3J0c1Vua25vd25FbGVtZW50cyA9IGEuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSB8fCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgdW5hYmxlIHRvIHNoaXZcbiAgICAgICAgICAgICAgICAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCkoJ2EnKTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZnJhZy5jbG9uZU5vZGUgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBmcmFnLmNyZWF0ZUVsZW1lbnQgPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gYXNzaWduIGEgZmFsc2UgcG9zaXRpdmUgaWYgZGV0ZWN0aW9uIGZhaWxzID0+IHVuYWJsZSB0byBzaGl2XG4gICAgICAgICAgICBzdXBwb3J0c0h0bWw1U3R5bGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfSgpKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0eWxlIHNoZWV0IHdpdGggdGhlIGdpdmVuIENTUyB0ZXh0IGFuZCBhZGRzIGl0IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RG9jdW1lbnR9IG93bmVyRG9jdW1lbnQgVGhlIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjc3NUZXh0IFRoZSBDU1MgdGV4dC5cbiAgICAgKiBAcmV0dXJucyB7U3R5bGVTaGVldH0gVGhlIHN0eWxlIGVsZW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkU3R5bGVTaGVldChvd25lckRvY3VtZW50LCBjc3NUZXh0KSB7XG4gICAgICAgIHZhciBwID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyksXG4gICAgICAgICAgICBwYXJlbnQgPSBvd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0gfHwgb3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgcC5pbm5lckhUTUwgPSAneDxzdHlsZT4nICsgY3NzVGV4dCArICc8L3N0eWxlPic7XG4gICAgICAgIHJldHVybiBwYXJlbnQuaW5zZXJ0QmVmb3JlKHAubGFzdENoaWxkLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYGh0bWw1LmVsZW1lbnRzYCBhcyBhbiBhcnJheS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2Ygc2hpdmVkIGVsZW1lbnQgbm9kZSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gaHRtbDUuZWxlbWVudHM7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZWxlbWVudHMgPT0gJ3N0cmluZycgPyBlbGVtZW50cy5zcGxpdCgnICcpIDogZWxlbWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kcyB0aGUgYnVpbHQtaW4gbGlzdCBvZiBodG1sNSBlbGVtZW50c1xuICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBuZXdFbGVtZW50cyB3aGl0ZXNwYWNlIHNlcGFyYXRlZCBsaXN0IG9yIGFycmF5IG9mIG5ldyBlbGVtZW50IG5hbWVzIHRvIHNoaXZcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEVsZW1lbnRzKG5ld0VsZW1lbnRzLCBvd25lckRvY3VtZW50KSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IGh0bWw1LmVsZW1lbnRzO1xuICAgICAgICBpZih0eXBlb2YgZWxlbWVudHMgIT0gJ3N0cmluZycpe1xuICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cy5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIG5ld0VsZW1lbnRzICE9ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIG5ld0VsZW1lbnRzID0gbmV3RWxlbWVudHMuam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGh0bWw1LmVsZW1lbnRzID0gZWxlbWVudHMgKycgJysgbmV3RWxlbWVudHM7XG4gICAgICAgIHNoaXZEb2N1bWVudChvd25lckRvY3VtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIGFzc29jaWF0ZWQgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KSB7XG4gICAgICAgIHZhciBkYXRhID0gZXhwYW5kb0RhdGFbb3duZXJEb2N1bWVudFtleHBhbmRvXV07XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgZXhwYW5JRCsrO1xuICAgICAgICAgICAgb3duZXJEb2N1bWVudFtleHBhbmRvXSA9IGV4cGFuSUQ7XG4gICAgICAgICAgICBleHBhbmRvRGF0YVtleHBhbklEXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHNoaXZlZCBlbGVtZW50IGZvciB0aGUgZ2l2ZW4gbm9kZU5hbWUgYW5kIGRvY3VtZW50XG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lIG5hbWUgb2YgdGhlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0RvY3VtZW50fSBvd25lckRvY3VtZW50IFRoZSBjb250ZXh0IGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzaGl2ZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KG5vZGVOYW1lLCBvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3VwcG9ydHNVbmtub3duRWxlbWVudHMpe1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0RXhwYW5kb0RhdGEob3duZXJEb2N1bWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGU7XG5cbiAgICAgICAgaWYgKGRhdGEuY2FjaGVbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgICBub2RlID0gZGF0YS5jYWNoZVtub2RlTmFtZV0uY2xvbmVOb2RlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2F2ZUNsb25lcy50ZXN0KG5vZGVOYW1lKSkge1xuICAgICAgICAgICAgbm9kZSA9IChkYXRhLmNhY2hlW25vZGVOYW1lXSA9IGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSkpLmNsb25lTm9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdm9pZCBhZGRpbmcgc29tZSBlbGVtZW50cyB0byBmcmFnbWVudHMgaW4gSUUgPCA5IGJlY2F1c2VcbiAgICAgICAgLy8gKiBBdHRyaWJ1dGVzIGxpa2UgYG5hbWVgIG9yIGB0eXBlYCBjYW5ub3QgYmUgc2V0L2NoYW5nZWQgb25jZSBhbiBlbGVtZW50XG4gICAgICAgIC8vICAgaXMgaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50L2ZyYWdtZW50XG4gICAgICAgIC8vICogTGluayBlbGVtZW50cyB3aXRoIGBzcmNgIGF0dHJpYnV0ZXMgdGhhdCBhcmUgaW5hY2Nlc3NpYmxlLCBhcyB3aXRoXG4gICAgICAgIC8vICAgYSA0MDMgcmVzcG9uc2UsIHdpbGwgY2F1c2UgdGhlIHRhYi93aW5kb3cgdG8gY3Jhc2hcbiAgICAgICAgLy8gKiBTY3JpcHQgZWxlbWVudHMgYXBwZW5kZWQgdG8gZnJhZ21lbnRzIHdpbGwgZXhlY3V0ZSB3aGVuIHRoZWlyIGBzcmNgXG4gICAgICAgIC8vICAgb3IgYHRleHRgIHByb3BlcnR5IGlzIHNldFxuICAgICAgICByZXR1cm4gbm9kZS5jYW5IYXZlQ2hpbGRyZW4gJiYgIXJlU2tpcC50ZXN0KG5vZGVOYW1lKSAmJiAhbm9kZS50YWdVcm4gPyBkYXRhLmZyYWcuYXBwZW5kQ2hpbGQobm9kZSkgOiBub2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBzaGl2ZWQgRG9jdW1lbnRGcmFnbWVudCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgY29udGV4dCBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2hpdmVkIERvY3VtZW50RnJhZ21lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRGcmFnbWVudChvd25lckRvY3VtZW50LCBkYXRhKXtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc3VwcG9ydHNVbmtub3duRWxlbWVudHMpe1xuICAgICAgICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IGdldEV4cGFuZG9EYXRhKG93bmVyRG9jdW1lbnQpO1xuICAgICAgICB2YXIgY2xvbmUgPSBkYXRhLmZyYWcuY2xvbmVOb2RlKCksXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIGVsZW1zID0gZ2V0RWxlbWVudHMoKSxcbiAgICAgICAgICAgIGwgPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgIGZvcig7aTxsO2krKyl7XG4gICAgICAgICAgICBjbG9uZS5jcmVhdGVFbGVtZW50KGVsZW1zW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hpdnMgdGhlIGBjcmVhdGVFbGVtZW50YCBhbmQgYGNyZWF0ZURvY3VtZW50RnJhZ21lbnRgIG1ldGhvZHMgb2YgdGhlIGRvY3VtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtEb2N1bWVudHxEb2N1bWVudEZyYWdtZW50fSBvd25lckRvY3VtZW50IFRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpdk1ldGhvZHMob3duZXJEb2N1bWVudCwgZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEuY2FjaGUpIHtcbiAgICAgICAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICAgICAgICAgIGRhdGEuY3JlYXRlRWxlbSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudDtcbiAgICAgICAgICAgIGRhdGEuY3JlYXRlRnJhZyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudDtcbiAgICAgICAgICAgIGRhdGEuZnJhZyA9IGRhdGEuY3JlYXRlRnJhZygpO1xuICAgICAgICB9XG5cblxuICAgICAgICBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihub2RlTmFtZSkge1xuICAgICAgICAgICAgLy9hYm9ydCBzaGl2XG4gICAgICAgICAgICBpZiAoIWh0bWw1LnNoaXZNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuY3JlYXRlRWxlbShub2RlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChub2RlTmFtZSwgb3duZXJEb2N1bWVudCwgZGF0YSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gRnVuY3Rpb24oJ2gsZicsICdyZXR1cm4gZnVuY3Rpb24oKXsnICtcbiAgICAgICAgICAgICd2YXIgbj1mLmNsb25lTm9kZSgpLGM9bi5jcmVhdGVFbGVtZW50OycgK1xuICAgICAgICAgICAgJ2guc2hpdk1ldGhvZHMmJignICtcbiAgICAgICAgICAgIC8vIHVucm9sbCB0aGUgYGNyZWF0ZUVsZW1lbnRgIGNhbGxzXG4gICAgICAgICAgICBnZXRFbGVtZW50cygpLmpvaW4oKS5yZXBsYWNlKC9bXFx3XFwtOl0rL2csIGZ1bmN0aW9uKG5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jcmVhdGVFbGVtKG5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBkYXRhLmZyYWcuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdjKFwiJyArIG5vZGVOYW1lICsgJ1wiKSc7XG4gICAgICAgICAgICB9KSArXG4gICAgICAgICAgICAnKTtyZXR1cm4gbn0nXG4gICAgICAgICkoaHRtbDUsIGRhdGEuZnJhZyk7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBTaGl2cyB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICogQHBhcmFtIHtEb2N1bWVudH0gb3duZXJEb2N1bWVudCBUaGUgZG9jdW1lbnQgdG8gc2hpdi5cbiAgICAgKiBAcmV0dXJucyB7RG9jdW1lbnR9IFRoZSBzaGl2ZWQgZG9jdW1lbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hpdkRvY3VtZW50KG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBvd25lckRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGEgPSBnZXRFeHBhbmRvRGF0YShvd25lckRvY3VtZW50KTtcblxuICAgICAgICBpZiAoaHRtbDUuc2hpdkNTUyAmJiAhc3VwcG9ydHNIdG1sNVN0eWxlcyAmJiAhZGF0YS5oYXNDU1MpIHtcbiAgICAgICAgICAgIGRhdGEuaGFzQ1NTID0gISFhZGRTdHlsZVNoZWV0KG93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdHMgYmxvY2sgZGlzcGxheSBub3QgZGVmaW5lZCBpbiBJRTYvNy84LzlcbiAgICAgICAgICAgICAgICAnYXJ0aWNsZSxhc2lkZSxkaWFsb2csZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixuYXYsc2VjdGlvbntkaXNwbGF5OmJsb2NrfScgK1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGRzIHN0eWxpbmcgbm90IHByZXNlbnQgaW4gSUU2LzcvOC85XG4gICAgICAgICAgICAgICAgICAgICdtYXJre2JhY2tncm91bmQ6I0ZGMDtjb2xvcjojMDAwfScgK1xuICAgICAgICAgICAgICAgICAgICAvLyBoaWRlcyBub24tcmVuZGVyZWQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgICAgJ3RlbXBsYXRle2Rpc3BsYXk6bm9uZX0nXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3VwcG9ydHNVbmtub3duRWxlbWVudHMpIHtcbiAgICAgICAgICAgIHNoaXZNZXRob2RzKG93bmVyRG9jdW1lbnQsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvd25lckRvY3VtZW50O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGBodG1sNWAgb2JqZWN0IGlzIGV4cG9zZWQgc28gdGhhdCBtb3JlIGVsZW1lbnRzIGNhbiBiZSBzaGl2ZWQgYW5kXG4gICAgICogZXhpc3Rpbmcgc2hpdmluZyBjYW4gYmUgZGV0ZWN0ZWQgb24gaWZyYW1lcy5cbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gb3B0aW9ucyBjYW4gYmUgY2hhbmdlZCBiZWZvcmUgdGhlIHNjcmlwdCBpcyBpbmNsdWRlZFxuICAgICAqIGh0bWw1ID0geyAnZWxlbWVudHMnOiAnbWFyayBzZWN0aW9uJywgJ3NoaXZDU1MnOiBmYWxzZSwgJ3NoaXZNZXRob2RzJzogZmFsc2UgfTtcbiAgICAgKi9cbiAgICB2YXIgaHRtbDUgPSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IG9yIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2Ygbm9kZSBuYW1lcyBvZiB0aGUgZWxlbWVudHMgdG8gc2hpdi5cbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIEFycmF5fFN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgJ2VsZW1lbnRzJzogb3B0aW9ucy5lbGVtZW50cyB8fCAnYWJiciBhcnRpY2xlIGFzaWRlIGF1ZGlvIGJkaSBjYW52YXMgZGF0YSBkYXRhbGlzdCBkZXRhaWxzIGRpYWxvZyBmaWdjYXB0aW9uIGZpZ3VyZSBmb290ZXIgaGVhZGVyIGhncm91cCBtYWluIG1hcmsgbWV0ZXIgbmF2IG91dHB1dCBwaWN0dXJlIHByb2dyZXNzIHNlY3Rpb24gc3VtbWFyeSB0ZW1wbGF0ZSB0aW1lIHZpZGVvJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY3VycmVudCB2ZXJzaW9uIG9mIGh0bWw1c2hpdlxuICAgICAgICAgKi9cbiAgICAgICAgJ3ZlcnNpb24nOiB2ZXJzaW9uLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgSFRNTDUgc3R5bGUgc2hlZXQgc2hvdWxkIGJlIGluc2VydGVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgaHRtbDVcbiAgICAgICAgICogQHR5cGUgQm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgJ3NoaXZDU1MnOiAob3B0aW9ucy5zaGl2Q1NTICE9PSBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElzIGVxdWFsIHRvIHRydWUgaWYgYSBicm93c2VyIHN1cHBvcnRzIGNyZWF0aW5nIHVua25vd24vSFRNTDUgZWxlbWVudHNcbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgICdzdXBwb3J0c1Vua25vd25FbGVtZW50cyc6IHN1cHBvcnRzVW5rbm93bkVsZW1lbnRzLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgZG9jdW1lbnQncyBgY3JlYXRlRWxlbWVudGAgYW5kIGBjcmVhdGVEb2N1bWVudEZyYWdtZW50YFxuICAgICAgICAgKiBtZXRob2RzIHNob3VsZCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICogQG1lbWJlck9mIGh0bWw1XG4gICAgICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgICdzaGl2TWV0aG9kcyc6IChvcHRpb25zLnNoaXZNZXRob2RzICE9PSBmYWxzZSksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc3RyaW5nIHRvIGRlc2NyaWJlIHRoZSB0eXBlIG9mIGBodG1sNWAgb2JqZWN0IChcImRlZmF1bHRcIiBvciBcImRlZmF1bHQgcHJpbnRcIikuXG4gICAgICAgICAqIEBtZW1iZXJPZiBodG1sNVxuICAgICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgICd0eXBlJzogJ2RlZmF1bHQnLFxuXG4gICAgICAgIC8vIHNoaXZzIHRoZSBkb2N1bWVudCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBgaHRtbDVgIG9iamVjdCBvcHRpb25zXG4gICAgICAgICdzaGl2RG9jdW1lbnQnOiBzaGl2RG9jdW1lbnQsXG5cbiAgICAgICAgLy9jcmVhdGVzIGEgc2hpdmVkIGVsZW1lbnRcbiAgICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcblxuICAgICAgICAvL2NyZWF0ZXMgYSBzaGl2ZWQgZG9jdW1lbnRGcmFnbWVudFxuICAgICAgICBjcmVhdGVEb2N1bWVudEZyYWdtZW50OiBjcmVhdGVEb2N1bWVudEZyYWdtZW50LFxuXG4gICAgICAgIC8vZXh0ZW5kcyBsaXN0IG9mIGVsZW1lbnRzXG4gICAgICAgIGFkZEVsZW1lbnRzOiBhZGRFbGVtZW50c1xuICAgIH07XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIGV4cG9zZSBodG1sNVxuICAgIHdpbmRvdy5odG1sNSA9IGh0bWw1O1xuXG4gICAgLy8gc2hpdiB0aGUgZG9jdW1lbnRcbiAgICBzaGl2RG9jdW1lbnQoZG9jdW1lbnQpO1xuXG59KHRoaXMsIGRvY3VtZW50KSk7IiwiLyohIFBpY3R1cmVmaWxsIC0gdjIuMi4wIC0gMjAxNC0xMi0xOVxuICogaHR0cDovL3Njb3R0amVobC5naXRodWIuaW8vcGljdHVyZWZpbGxcbiAqIENvcHlyaWdodCAoYykgMjAxNCBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRqZWhsL3BpY3R1cmVmaWxsL2Jsb2IvbWFzdGVyL0F1dGhvcnMudHh0OyBMaWNlbnNlZCBNSVQgKi9cbi8qISBtYXRjaE1lZGlhKCkgcG9seWZpbGwgLSBUZXN0IGEgQ1NTIG1lZGlhIHR5cGUvcXVlcnkgaW4gSlMuIEF1dGhvcnMgJiBjb3B5cmlnaHQgKGMpIDIwMTI6IFNjb3R0IEplaGwsIFBhdWwgSXJpc2gsIE5pY2hvbGFzIFpha2FzLCBEYXZpZCBLbmlnaHQuIER1YWwgTUlUL0JTRCBsaWNlbnNlICovXG5cbndpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBtYXRjaE1lZGl1bSBhcGkgc3VjaCBhcyBJRSA5IGFuZCB3ZWJraXRcbiAgICB2YXIgc3R5bGVNZWRpYSA9ICh3aW5kb3cuc3R5bGVNZWRpYSB8fCB3aW5kb3cubWVkaWEpO1xuXG4gICAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxuICAgIGlmICghc3R5bGVNZWRpYSkge1xuICAgICAgICB2YXIgc3R5bGUgICAgICAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxuICAgICAgICAgICAgc2NyaXB0ICAgICAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXG4gICAgICAgICAgICBpbmZvICAgICAgICA9IG51bGw7XG5cbiAgICAgICAgc3R5bGUudHlwZSAgPSAndGV4dC9jc3MnO1xuICAgICAgICBzdHlsZS5pZCAgICA9ICdtYXRjaG1lZGlhanMtdGVzdCc7XG5cbiAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLCBzY3JpcHQpO1xuXG4gICAgICAgIC8vICdzdHlsZS5jdXJyZW50U3R5bGUnIGlzIHVzZWQgYnkgSUUgPD0gOCBhbmQgJ3dpbmRvdy5nZXRDb21wdXRlZFN0eWxlJyBmb3IgYWxsIG90aGVyIGJyb3dzZXJzXG4gICAgICAgIGluZm8gPSAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3R5bGUsIG51bGwpIHx8IHN0eWxlLmN1cnJlbnRTdHlsZTtcblxuICAgICAgICBzdHlsZU1lZGlhID0ge1xuICAgICAgICAgICAgbWF0Y2hNZWRpdW06IGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAnQG1lZGlhICcgKyBtZWRpYSArICd7ICNtYXRjaG1lZGlhanMtdGVzdCB7IHdpZHRoOiAxcHg7IH0gfSc7XG5cbiAgICAgICAgICAgICAgICAvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUZXN0IGlmIG1lZGlhIHF1ZXJ5IGlzIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5mby53aWR0aCA9PT0gJzFweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1lZGlhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcbiAgICAgICAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xuICAgICAgICB9O1xuICAgIH07XG59KCkpO1xuLyohIFBpY3R1cmVmaWxsIC0gUmVzcG9uc2l2ZSBJbWFnZXMgdGhhdCB3b3JrIHRvZGF5LlxuICogIEF1dGhvcjogU2NvdHQgSmVobCwgRmlsYW1lbnQgR3JvdXAsIDIwMTIgKCBuZXcgcHJvcG9zYWwgaW1wbGVtZW50ZWQgYnkgU2hhd24gSmFuc2VwYXIgKVxuICogIExpY2Vuc2U6IE1JVC9HUEx2MlxuICogIFNwZWM6IGh0dHA6Ly9waWN0dXJlLnJlc3BvbnNpdmVpbWFnZXMub3JnL1xuICovXG4oZnVuY3Rpb24oIHcsIGRvYywgaW1hZ2UgKSB7XG4gICAgLy8gRW5hYmxlIHN0cmljdCBtb2RlXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBJZiBwaWN0dXJlIGlzIHN1cHBvcnRlZCwgd2VsbCwgdGhhdCdzIGF3ZXNvbWUuIExldCdzIGdldCBvdXR0YSBoZXJlLi4uXG4gICAgaWYgKCB3LkhUTUxQaWN0dXJlRWxlbWVudCApIHtcbiAgICAgICAgdy5waWN0dXJlZmlsbCA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSFRNTCBzaGltfHYgaXQgZm9yIG9sZCBJRSAoSUU5IHdpbGwgc3RpbGwgbmVlZCB0aGUgSFRNTCB2aWRlbyB0YWcgd29ya2Fyb3VuZClcbiAgICBkb2MuY3JlYXRlRWxlbWVudCggXCJwaWN0dXJlXCIgKTtcblxuICAgIC8vIGxvY2FsIG9iamVjdCBmb3IgbWV0aG9kIHJlZmVyZW5jZXMgYW5kIHRlc3RpbmcgZXhwb3N1cmVcbiAgICB2YXIgcGYgPSB3LnBpY3R1cmVmaWxsIHx8IHt9O1xuXG4gICAgLy8gbmFtZXNwYWNlXG4gICAgcGYubnMgPSBcInBpY3R1cmVmaWxsXCI7XG5cbiAgICAvLyBzcmNzZXQgc3VwcG9ydCB0ZXN0XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBwZi5zcmNzZXRTdXBwb3J0ZWQgPSBcInNyY3NldFwiIGluIGltYWdlO1xuICAgICAgICBwZi5zaXplc1N1cHBvcnRlZCA9IFwic2l6ZXNcIiBpbiBpbWFnZTtcbiAgICB9KSgpO1xuXG4gICAgLy8ganVzdCBhIHN0cmluZyB0cmltIHdvcmthcm91bmRcbiAgICBwZi50cmltID0gZnVuY3Rpb24oIHN0ciApIHtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKCAvXlxccyt8XFxzKyQvZywgXCJcIiApO1xuICAgIH07XG5cbiAgICAvLyBqdXN0IGEgc3RyaW5nIGVuZHNXaXRoIHdvcmthcm91bmRcbiAgICBwZi5lbmRzV2l0aCA9IGZ1bmN0aW9uKCBzdHIsIHN1ZmZpeCApIHtcbiAgICAgICAgcmV0dXJuIHN0ci5lbmRzV2l0aCA/IHN0ci5lbmRzV2l0aCggc3VmZml4ICkgOiBzdHIuaW5kZXhPZiggc3VmZml4LCBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aCApICE9PSAtMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgbWV0aG9kIGZvciBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjL3NwZWNzL21peGVkY29udGVudC8jcmVzdHJpY3RzLW1peGVkLWNvbnRlbnQgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcbiAgICAgKi9cbiAgICBwZi5yZXN0cmljdHNNaXhlZENvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHcubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCBtZXRob2QgZm9yIG1hdGNoTWVkaWEgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcbiAgICAgKi9cblxuICAgIHBmLm1hdGNoZXNNZWRpYSA9IGZ1bmN0aW9uKCBtZWRpYSApIHtcbiAgICAgICAgcmV0dXJuIHcubWF0Y2hNZWRpYSAmJiB3Lm1hdGNoTWVkaWEoIG1lZGlhICkubWF0Y2hlcztcbiAgICB9O1xuXG4gICAgLy8gU2hvcnRjdXQgbWV0aG9kIGZvciBgZGV2aWNlUGl4ZWxSYXRpb2AgKCBmb3IgZWFzeSBvdmVycmlkaW5nIGluIHRlc3RzIClcbiAgICBwZi5nZXREcHIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICggdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHdpZHRoIGluIGNzcyBwaXhlbCB2YWx1ZSBmcm9tIGEgXCJsZW5ndGhcIiB2YWx1ZVxuICAgICAqIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jbGVuZ3RoLXZhbHVlXG4gICAgICovXG4gICAgcGYuZ2V0V2lkdGhGcm9tTGVuZ3RoID0gZnVuY3Rpb24oIGxlbmd0aCApIHtcbiAgICAgICAgLy8gSWYgYSBsZW5ndGggaXMgc3BlY2lmaWVkIGFuZCBkb2VzbuKAmXQgY29udGFpbiBhIHBlcmNlbnRhZ2UsIGFuZCBpdCBpcyBncmVhdGVyIHRoYW4gMCBvciB1c2luZyBgY2FsY2AsIHVzZSBpdC4gRWxzZSwgdXNlIHRoZSBgMTAwdndgIGRlZmF1bHQuXG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCAmJiBsZW5ndGguaW5kZXhPZiggXCIlXCIgKSA+IC0xID09PSBmYWxzZSAmJiAoIHBhcnNlRmxvYXQoIGxlbmd0aCApID4gMCB8fCBsZW5ndGguaW5kZXhPZiggXCJjYWxjKFwiICkgPiAtMSApID8gbGVuZ3RoIDogXCIxMDB2d1wiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsZW5ndGggaXMgc3BlY2lmaWVkIGluICBgdndgIHVuaXRzLCB1c2UgYCVgIGluc3RlYWQgc2luY2UgdGhlIGRpdiB3ZeKAmXJlIG1lYXN1cmluZ1xuICAgICAgICAgKiBpcyBpbmplY3RlZCBhdCB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogbWF5YmUgd2Ugc2hvdWxkIHB1dCB0aGlzIGJlaGluZCBhIGZlYXR1cmUgdGVzdCBmb3IgYHZ3YD8gVGhlIHJpc2sgb2YgZG9pbmcgdGhpcyBpcyBwb3NzaWJsZSBicm93c2VyIGluY29uc2lzdGFuY2llcyB3aXRoIHZ3IHZzICVcbiAgICAgICAgICovXG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aC5yZXBsYWNlKCBcInZ3XCIsIFwiJVwiICk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY2FjaGVkIGVsZW1lbnQgZm9yIGdldHRpbmcgbGVuZ3RoIHZhbHVlIHdpZHRoc1xuICAgICAgICBpZiAoICFwZi5sZW5ndGhFbCApIHtcbiAgICAgICAgICAgIHBmLmxlbmd0aEVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuICAgICAgICAgICAgLy8gUG9zaXRpb25pbmcgc3R5bGVzIGhlbHAgcHJldmVudCBwYWRkaW5nL21hcmdpbi93aWR0aCBvbiBgaHRtbGAgb3IgYGJvZHlgIGZyb20gdGhyb3dpbmcgY2FsY3VsYXRpb25zIG9mZi5cbiAgICAgICAgICAgIHBmLmxlbmd0aEVsLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO2Rpc3BsYXk6YmxvY2s7Zm9udC1zaXplOjFlbTtsZWZ0OjA7bWFyZ2luOjA7cGFkZGluZzowO3Bvc2l0aW9uOmFic29sdXRlO3Zpc2liaWxpdHk6aGlkZGVuXCI7XG4gICAgICAgIH1cblxuICAgICAgICBwZi5sZW5ndGhFbC5zdHlsZS53aWR0aCA9IGxlbmd0aDtcblxuICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChwZi5sZW5ndGhFbCk7XG5cbiAgICAgICAgLy8gQWRkIGEgY2xhc3MsIHNvIHRoYXQgZXZlcnlvbmUga25vd3Mgd2hlcmUgdGhpcyBlbGVtZW50IGNvbWVzIGZyb21cbiAgICAgICAgcGYubGVuZ3RoRWwuY2xhc3NOYW1lID0gXCJoZWxwZXItZnJvbS1waWN0dXJlZmlsbC1qc1wiO1xuXG4gICAgICAgIGlmICggcGYubGVuZ3RoRWwub2Zmc2V0V2lkdGggPD0gMCApIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gYGNhbGMoKWAgaXMgaW4gdXNlIGFuZCB1bnN1cHBvcnRlZCwgbW9zdCBsaWtlbHkuIERlZmF1bHQgdG8gYDEwMHZ3YCAoYDEwMCVgLCBmb3IgYnJvYWRlciBzdXBwb3J0Lik6XG4gICAgICAgICAgICBwZi5sZW5ndGhFbC5zdHlsZS53aWR0aCA9IGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGggKyBcInB4XCI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2V0V2lkdGggPSBwZi5sZW5ndGhFbC5vZmZzZXRXaWR0aDtcblxuICAgICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZCggcGYubGVuZ3RoRWwgKTtcblxuICAgICAgICByZXR1cm4gb2Zmc2V0V2lkdGg7XG4gICAgfTtcblxuICAgIHBmLmRldGVjdFR5cGVTdXBwb3J0ID0gZnVuY3Rpb24oIHR5cGUsIHR5cGVVcmkgKSB7XG4gICAgICAgIC8vIGJhc2VkIG9uIE1vZGVybml6cidzIGxvc3NsZXNzIGltZy13ZWJwIHRlc3RcbiAgICAgICAgLy8gbm90ZTogYXN5bmNocm9ub3VzXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyB3LkltYWdlKCk7XG4gICAgICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBmLnR5cGVzWyB0eXBlIF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHBpY3R1cmVmaWxsKCk7XG4gICAgICAgIH07XG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcGYudHlwZXNbIHR5cGUgXSA9IGltYWdlLndpZHRoID09PSAxO1xuICAgICAgICAgICAgcGljdHVyZWZpbGwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1hZ2Uuc3JjID0gdHlwZVVyaTtcblxuICAgICAgICByZXR1cm4gXCJwZW5kaW5nXCI7XG4gICAgfTtcbiAgICAvLyBjb250YWluZXIgb2Ygc3VwcG9ydGVkIG1pbWUgdHlwZXMgdGhhdCBvbmUgbWlnaHQgbmVlZCB0byBxdWFsaWZ5IGJlZm9yZSB1c2luZ1xuICAgIHBmLnR5cGVzID0gcGYudHlwZXMgfHwge307XG5cbiAgICAvLyBBZGQgc3VwcG9ydCBmb3Igc3RhbmRhcmQgbWltZSB0eXBlc1xuICAgIHBmLnR5cGVzWyBcImltYWdlL2pwZWdcIiBdID0gdHJ1ZTtcbiAgICBwZi50eXBlc1sgXCJpbWFnZS9naWZcIiBdID0gdHJ1ZTtcbiAgICBwZi50eXBlc1sgXCJpbWFnZS9wbmdcIiBdID0gdHJ1ZTtcbiAgICBwZi50eXBlc1sgXCJpbWFnZS9zdmcreG1sXCIgXSA9IGRvYy5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNJbWFnZVwiLCBcIjEuMVwiKTtcbiAgICBwZi50eXBlc1sgXCJpbWFnZS93ZWJwXCIgXSA9IHBmLmRldGVjdFR5cGVTdXBwb3J0KFwiaW1hZ2Uvd2VicFwiLCBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JoNEFBQUJYUlVKUVZsQTRUQkVBQUFBdkFBQUFBQWZRLy83M3YvK0JpT2gvQUFBPVwiKTtcblxuICAgIHBmLnZlcmlmeVR5cGVTdXBwb3J0ID0gZnVuY3Rpb24oIHNvdXJjZSApIHtcbiAgICAgICAgdmFyIHR5cGUgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApO1xuICAgICAgICAvLyBpZiB0eXBlIGF0dHJpYnV0ZSBleGlzdHMsIHJldHVybiB0ZXN0IHJlc3VsdCwgb3RoZXJ3aXNlIHJldHVybiB0cnVlXG4gICAgICAgIGlmICggdHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSBcIlwiICkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGZUeXBlID0gcGYudHlwZXNbIHR5cGUgXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB0eXBlIHRlc3QgaXMgYSBmdW5jdGlvbiwgcnVuIGl0IGFuZCByZXR1cm4gXCJwZW5kaW5nXCIgc3RhdHVzLiBUaGUgZnVuY3Rpb24gd2lsbCByZXJ1biBwaWN0dXJlZmlsbCBvbiBwZW5kaW5nIGVsZW1lbnRzIG9uY2UgZmluaXNoZWQuXG4gICAgICAgICAgICBpZiAoIHR5cGVvZiBwZlR5cGUgPT09IFwic3RyaW5nXCIgJiYgcGZUeXBlICE9PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgIHBmLnR5cGVzWyB0eXBlIF0gPSBwZi5kZXRlY3RUeXBlU3VwcG9ydCggdHlwZSwgcGZUeXBlICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicGVuZGluZ1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHBmVHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgIHBmVHlwZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBmVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYW4gaW5kaXZpZHVhbCBgc2l6ZWAgYW5kIHJldHVybnMgdGhlIGxlbmd0aCwgYW5kIG9wdGlvbmFsIG1lZGlhIHF1ZXJ5XG4gICAgcGYucGFyc2VTaXplID0gZnVuY3Rpb24oIHNvdXJjZVNpemVTdHIgKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IC8oXFwoW14pXStcXCkpP1xccyooLispL2cuZXhlYyggc291cmNlU2l6ZVN0ciApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVkaWE6IG1hdGNoICYmIG1hdGNoWzFdLFxuICAgICAgICAgICAgbGVuZ3RoOiBtYXRjaCAmJiBtYXRjaFsyXVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBUYWtlcyBhIHN0cmluZyBvZiBzaXplcyBhbmQgcmV0dXJucyB0aGUgd2lkdGggaW4gcGl4ZWxzIGFzIGEgbnVtYmVyXG4gICAgcGYuZmluZFdpZHRoRnJvbVNvdXJjZVNpemUgPSBmdW5jdGlvbiggc291cmNlU2l6ZUxpc3RTdHIgKSB7XG4gICAgICAgIC8vIFNwbGl0IHVwIHNvdXJjZSBzaXplIGxpc3QsIGllICggbWF4LXdpZHRoOiAzMGVtICkgMTAwJSwgKCBtYXgtd2lkdGg6IDUwZW0gKSA1MCUsIDMzJVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciAobWluLXdpZHRoOjMwZW0pIGNhbGMoMzAlIC0gMTVweClcbiAgICAgICAgdmFyIHNvdXJjZVNpemVMaXN0ID0gcGYudHJpbSggc291cmNlU2l6ZUxpc3RTdHIgKS5zcGxpdCggL1xccyosXFxzKi8gKSxcbiAgICAgICAgICAgIHdpbm5pbmdMZW5ndGg7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VTaXplTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIC8vIE1hdGNoIDxtZWRpYS1jb25kaXRpb24+PyBsZW5ndGgsIGllICggbWluLXdpZHRoOiA1MGVtICkgMTAwJVxuICAgICAgICAgICAgdmFyIHNvdXJjZVNpemUgPSBzb3VyY2VTaXplTGlzdFsgaSBdLFxuICAgICAgICAgICAgLy8gU3BsaXQgXCIoIG1pbi13aWR0aDogNTBlbSApIDEwMCVcIiBpbnRvIHNlcGFyYXRlIHN0cmluZ3NcbiAgICAgICAgICAgICAgICBwYXJzZWRTaXplID0gcGYucGFyc2VTaXplKCBzb3VyY2VTaXplICksXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcGFyc2VkU2l6ZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgbWVkaWEgPSBwYXJzZWRTaXplLm1lZGlhO1xuXG4gICAgICAgICAgICBpZiAoICFsZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICFtZWRpYSB8fCBwZi5tYXRjaGVzTWVkaWEoIG1lZGlhICkgKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbWVkaWEgcXVlcnkgb3IgaXQgbWF0Y2hlcywgY2hvb3NlIHRoaXMgYXMgb3VyIHdpbm5pbmcgbGVuZ3RoXG4gICAgICAgICAgICAgICAgLy8gYW5kIGVuZCBhbGdvcml0aG1cbiAgICAgICAgICAgICAgICB3aW5uaW5nTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFzcyB0aGUgbGVuZ3RoIHRvIGEgbWV0aG9kIHRoYXQgY2FuIHByb3Blcmx5IGRldGVybWluZSBsZW5ndGhcbiAgICAgICAgLy8gaW4gcGl4ZWxzIGJhc2VkIG9uIHRoZXNlIGZvcm1hdHM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy12YWx1ZXMtMy8jbGVuZ3RoLXZhbHVlXG4gICAgICAgIHJldHVybiBwZi5nZXRXaWR0aEZyb21MZW5ndGgoIHdpbm5pbmdMZW5ndGggKTtcbiAgICB9O1xuXG4gICAgcGYucGFyc2VTcmNzZXQgPSBmdW5jdGlvbiggc3Jjc2V0ICkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsb3Qgb2YgdGhpcyB3YXMgcHVsbGVkIGZyb20gQm9yaXMgU211c+KAmSBwYXJzZXIgZm9yIHRoZSBub3ctZGVmdW5jdCBXSEFUV0cgYHNyY3NldGBcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2JvcmlzbXVzL3NyY3NldC1wb2x5ZmlsbC9ibG9iL21hc3Rlci9qcy9zcmNzZXQtaW5mby5qc1xuICAgICAgICAgKlxuICAgICAgICAgKiAxLiBMZXQgaW5wdXQgKGBzcmNzZXRgKSBiZSB0aGUgdmFsdWUgcGFzc2VkIHRvIHRoaXMgYWxnb3JpdGhtLlxuICAgICAgICAgKiAyLiBMZXQgcG9zaXRpb24gYmUgYSBwb2ludGVyIGludG8gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZy5cbiAgICAgICAgICogMy4gTGV0IHJhdyBjYW5kaWRhdGVzIGJlIGFuIGluaXRpYWxseSBlbXB0eSBvcmRlcmVkIGxpc3Qgb2YgVVJMcyB3aXRoIGFzc29jaWF0ZWRcbiAgICAgICAgICogICAgdW5wYXJzZWQgZGVzY3JpcHRvcnMuIFRoZSBvcmRlciBvZiBlbnRyaWVzIGluIHRoZSBsaXN0IGlzIHRoZSBvcmRlciBpbiB3aGljaCBlbnRyaWVzXG4gICAgICAgICAqICAgIGFyZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gW107XG5cbiAgICAgICAgd2hpbGUgKCBzcmNzZXQgIT09IFwiXCIgKSB7XG4gICAgICAgICAgICBzcmNzZXQgPSBzcmNzZXQucmVwbGFjZSggL15cXHMrL2csIFwiXCIgKTtcblxuICAgICAgICAgICAgLy8gNS4gQ29sbGVjdCBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IHNwYWNlIGNoYXJhY3RlcnMsIGFuZCBsZXQgdGhhdCBiZSB1cmwuXG4gICAgICAgICAgICB2YXIgcG9zID0gc3Jjc2V0LnNlYXJjaCgvXFxzL2cpLFxuICAgICAgICAgICAgICAgIHVybCwgZGVzY3JpcHRvciA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmICggcG9zICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBzcmNzZXQuc2xpY2UoIDAsIHBvcyApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB1cmwuc2xpY2UoLTEpO1xuXG4gICAgICAgICAgICAgICAgLy8gNi4gSWYgdXJsIGVuZHMgd2l0aCBhIFUrMDAyQyBDT01NQSBjaGFyYWN0ZXIgKCwpLCByZW1vdmUgdGhhdCBjaGFyYWN0ZXIgZnJvbSB1cmxcbiAgICAgICAgICAgICAgICAvLyBhbmQgbGV0IGRlc2NyaXB0b3JzIGJlIHRoZSBlbXB0eSBzdHJpbmcuIE90aGVyd2lzZSwgZm9sbG93IHRoZXNlIHN1YnN0ZXBzXG4gICAgICAgICAgICAgICAgLy8gNi4xLiBJZiB1cmwgaXMgZW1wdHksIHRoZW4ganVtcCB0byB0aGUgc3RlcCBsYWJlbGVkIGRlc2NyaXB0b3IgcGFyc2VyLlxuXG4gICAgICAgICAgICAgICAgaWYgKCBsYXN0ID09PSBcIixcIiB8fCB1cmwgPT09IFwiXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCAvLCskLywgXCJcIiApO1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdG9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Jjc2V0ID0gc3Jjc2V0LnNsaWNlKCBwb3MgKyAxICk7XG5cbiAgICAgICAgICAgICAgICAvLyA2LjIuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBVKzAwMkMgQ09NTUEgY2hhcmFjdGVycyAoLCksIGFuZFxuICAgICAgICAgICAgICAgIC8vIGxldCB0aGF0IGJlIGRlc2NyaXB0b3JzLlxuICAgICAgICAgICAgICAgIGlmICggZGVzY3JpcHRvciA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2Nwb3MgPSBzcmNzZXQuaW5kZXhPZiggXCIsXCIgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBkZXNjcG9zICE9PSAtMSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBzcmNzZXQuc2xpY2UoIDAsIGRlc2Nwb3MgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyY3NldCA9IHNyY3NldC5zbGljZSggZGVzY3BvcyArIDEgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IgPSBzcmNzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmNzZXQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cmwgPSBzcmNzZXQ7XG4gICAgICAgICAgICAgICAgc3Jjc2V0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gNy4gQWRkIHVybCB0byByYXcgY2FuZGlkYXRlcywgYXNzb2NpYXRlZCB3aXRoIGRlc2NyaXB0b3JzLlxuICAgICAgICAgICAgaWYgKCB1cmwgfHwgZGVzY3JpcHRvciApIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvcjogZGVzY3JpcHRvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH07XG5cbiAgICBwZi5wYXJzZURlc2NyaXB0b3IgPSBmdW5jdGlvbiggZGVzY3JpcHRvciwgc2l6ZXNhdHRyICkge1xuICAgICAgICAvLyAxMS4gRGVzY3JpcHRvciBwYXJzZXI6IExldCBjYW5kaWRhdGVzIGJlIGFuIGluaXRpYWxseSBlbXB0eSBzb3VyY2Ugc2V0LiBUaGUgb3JkZXIgb2YgZW50cmllcyBpbiB0aGUgbGlzdFxuICAgICAgICAvLyBpcyB0aGUgb3JkZXIgaW4gd2hpY2ggZW50cmllcyBhcmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICAgIHZhciBzaXplcyA9IHNpemVzYXR0ciB8fCBcIjEwMHZ3XCIsXG4gICAgICAgICAgICBzaXplRGVzY3JpcHRvciA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5yZXBsYWNlKCAvKF5cXHMrfFxccyskKS9nLCBcIlwiICksXG4gICAgICAgICAgICB3aWR0aEluQ3NzUGl4ZWxzID0gcGYuZmluZFdpZHRoRnJvbVNvdXJjZVNpemUoIHNpemVzICksXG4gICAgICAgICAgICByZXNDYW5kaWRhdGU7XG5cbiAgICAgICAgaWYgKCBzaXplRGVzY3JpcHRvciApIHtcbiAgICAgICAgICAgIHZhciBzcGxpdERlc2NyaXB0b3IgPSBzaXplRGVzY3JpcHRvci5zcGxpdChcIiBcIik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBzcGxpdERlc2NyaXB0b3IubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyciA9IHNwbGl0RGVzY3JpcHRvclsgaSBdLFxuICAgICAgICAgICAgICAgICAgICBsYXN0Y2hhciA9IGN1cnIgJiYgY3Vyci5zbGljZSggY3Vyci5sZW5ndGggLSAxICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoICggbGFzdGNoYXIgPT09IFwiaFwiIHx8IGxhc3RjaGFyID09PSBcIndcIiApICYmICFwZi5zaXplc1N1cHBvcnRlZCApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzQ2FuZGlkYXRlID0gcGFyc2VGbG9hdCggKCBwYXJzZUludCggY3VyciwgMTAgKSAvIHdpZHRoSW5Dc3NQaXhlbHMgKSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGxhc3RjaGFyID09PSBcInhcIiApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGN1cnIgJiYgcGFyc2VGbG9hdCggY3VyciwgMTAgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzQ2FuZGlkYXRlID0gcmVzICYmICFpc05hTiggcmVzICkgPyByZXMgOiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzQ2FuZGlkYXRlIHx8IDE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRha2VzIGEgc3Jjc2V0IGluIHRoZSBmb3JtIG9mIHVybC9cbiAgICAgKiBleC4gXCJpbWFnZXMvcGljLW1lZGl1bS5wbmcgMXgsIGltYWdlcy9waWMtbWVkaXVtLTJ4LnBuZyAyeFwiIG9yXG4gICAgICogICAgIFwiaW1hZ2VzL3BpYy1tZWRpdW0ucG5nIDQwMHcsIGltYWdlcy9waWMtbWVkaXVtLTJ4LnBuZyA4MDB3XCIgb3JcbiAgICAgKiAgICAgXCJpbWFnZXMvcGljLXNtYWxsLnBuZ1wiXG4gICAgICogR2V0IGFuIGFycmF5IG9mIGltYWdlIGNhbmRpZGF0ZXMgaW4gdGhlIGZvcm0gb2ZcbiAgICAgKiAgICAgIHt1cmw6IFwiL2Zvby9iYXIucG5nXCIsIHJlc29sdXRpb246IDF9XG4gICAgICogd2hlcmUgcmVzb2x1dGlvbiBpcyBodHRwOi8vZGV2LnczLm9yZy9jc3N3Zy9jc3MtdmFsdWVzLTMvI3Jlc29sdXRpb24tdmFsdWVcbiAgICAgKiBJZiBzaXplcyBpcyBzcGVjaWZpZWQsIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZFxuICAgICAqL1xuICAgIHBmLmdldENhbmRpZGF0ZXNGcm9tU291cmNlU2V0ID0gZnVuY3Rpb24oIHNyY3NldCwgc2l6ZXMgKSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gcGYucGFyc2VTcmNzZXQoIHNyY3NldCApLFxuICAgICAgICAgICAgZm9ybWF0dGVkQ2FuZGlkYXRlcyA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gY2FuZGlkYXRlcy5sZW5ndGg7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBpIF07XG5cbiAgICAgICAgICAgIGZvcm1hdHRlZENhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBjYW5kaWRhdGUudXJsLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHBmLnBhcnNlRGVzY3JpcHRvciggY2FuZGlkYXRlLmRlc2NyaXB0b3IsIHNpemVzIClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRDYW5kaWRhdGVzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBpZiBpdCdzIGFuIGltZyBlbGVtZW50IGFuZCBpdCBoYXMgYSBzcmNzZXQgcHJvcGVydHksXG4gICAgICogd2UgbmVlZCB0byByZW1vdmUgdGhlIGF0dHJpYnV0ZSBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSBzcmNcbiAgICAgKiAodGhlIHByb3BlcnR5J3MgZXhpc3RlbmNlIGluZmVycyBuYXRpdmUgc3Jjc2V0IHN1cHBvcnQsIGFuZCBhIHNyY3NldC1zdXBwb3J0aW5nIGJyb3dzZXIgd2lsbCBwcmlvcml0aXplIHNyY3NldCdzIHZhbHVlIG92ZXIgb3VyIHdpbm5pbmcgcGljdHVyZSBjYW5kaWRhdGUpXG4gICAgICogdGhpcyBtb3ZlcyBzcmNzZXQncyB2YWx1ZSB0byBtZW1vcnkgZm9yIGxhdGVyIHVzZSBhbmQgcmVtb3ZlcyB0aGUgYXR0clxuICAgICAqL1xuICAgIHBmLmRvZGdlU3Jjc2V0ID0gZnVuY3Rpb24oIGltZyApIHtcbiAgICAgICAgaWYgKCBpbWcuc3Jjc2V0ICkge1xuICAgICAgICAgICAgaW1nWyBwZi5ucyBdLnNyY3NldCA9IGltZy5zcmNzZXQ7XG4gICAgICAgICAgICBpbWcuc3Jjc2V0ID0gXCJcIjtcbiAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoIFwiZGF0YS1wZnNyY3NldFwiLCBpbWdbIHBmLm5zIF0uc3Jjc2V0ICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQWNjZXB0IGEgc291cmNlIG9yIGltZyBlbGVtZW50IGFuZCBwcm9jZXNzIGl0cyBzcmNzZXQgYW5kIHNpemVzIGF0dHJzXG4gICAgcGYucHJvY2Vzc1NvdXJjZVNldCA9IGZ1bmN0aW9uKCBlbCApIHtcbiAgICAgICAgdmFyIHNyY3NldCA9IGVsLmdldEF0dHJpYnV0ZSggXCJzcmNzZXRcIiApLFxuICAgICAgICAgICAgc2l6ZXMgPSBlbC5nZXRBdHRyaWJ1dGUoIFwic2l6ZXNcIiApLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyA9IFtdO1xuXG4gICAgICAgIC8vIGlmIGl0J3MgYW4gaW1nIGVsZW1lbnQsIHVzZSB0aGUgY2FjaGVkIHNyY3NldCBwcm9wZXJ0eSAoZGVmaW5lZCBvciBub3QpXG4gICAgICAgIGlmICggZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJJTUdcIiAmJiBlbFsgcGYubnMgXSAmJiBlbFsgcGYubnMgXS5zcmNzZXQgKSB7XG4gICAgICAgICAgICBzcmNzZXQgPSBlbFsgcGYubnMgXS5zcmNzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHNyY3NldCApIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZXMgPSBwZi5nZXRDYW5kaWRhdGVzRnJvbVNvdXJjZVNldCggc3Jjc2V0LCBzaXplcyApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH07XG5cbiAgICBwZi5iYWNrZmFjZVZpc2liaWxpdHlGaXggPSBmdW5jdGlvbiggcGljSW1nICkge1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zY290dGplaGwvcGljdHVyZWZpbGwvaXNzdWVzLzMzMlxuICAgICAgICB2YXIgc3R5bGUgPSBwaWNJbWcuc3R5bGUgfHwge30sXG4gICAgICAgICAgICBXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSBcIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eVwiIGluIHN0eWxlLFxuICAgICAgICAgICAgY3VycmVudFpvb20gPSBzdHlsZS56b29tO1xuXG4gICAgICAgIGlmIChXZWJraXRCYWNrZmFjZVZpc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHN0eWxlLnpvb20gPSBcIi45OTlcIjtcblxuICAgICAgICAgICAgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5ID0gcGljSW1nLm9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICBzdHlsZS56b29tID0gY3VycmVudFpvb207XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcGYuc2V0SW5oZXJlbnRTaXplID0gZnVuY3Rpb24oIHJlcywgcGljSW1nLCByZWFkeVN0YXRlICkge1xuICAgICAgICB2YXIgcmVhZHkgPSByZWFkeVN0YXRlICE9PSB1bmRlZmluZWQgPyByZWFkeVN0YXRlIDogcGljSW1nLmNvbXBsZXRlLFxuICAgICAgICAgICAgd2lkdGhQcmVzZXQgPSAhcmVhZHkgJiYgcGljSW1nLmdldEF0dHJpYnV0ZSAmJiBwaWNJbWcuZ2V0QXR0cmlidXRlKCBcIndpZHRoXCIgKSAhPT0gbnVsbCxcbiAgICAgICAgICAgIHNldFdpZHRoID0gZnVuY3Rpb24oIHJlcywgcGljSW1nICkge1xuICAgICAgICAgICAgICAgIGlmICggcGljSW1nLnNldEF0dHJpYnV0ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgcGljSW1nLnNldEF0dHJpYnV0ZSggXCJ3aWR0aFwiLCBwaWNJbWcubmF0dXJhbFdpZHRoIC8gcmVzICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdpZHRoSW50ZXJ2YWw7XG5cbiAgICAgICAgaWYgKCByZWFkeSAmJiByZXMgJiYgIXdpZHRoUHJlc2V0ICkge1xuICAgICAgICAgICAgc2V0V2lkdGgoIHJlcywgcGljSW1nICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhcmVhZHkgKSB7XG4gICAgICAgICAgICB3aWR0aEludGVydmFsID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwZi5zZXRJbmhlcmVudFNpemUoIHJlcywgcGljSW1nLCBwaWNJbWcuY29tcGxldGUgKTtcbiAgICAgICAgICAgIH0sIDI1MCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcGYuYXBwbHlCZXN0Q2FuZGlkYXRlID0gZnVuY3Rpb24oIGNhbmRpZGF0ZXMsIHBpY0ltZyApIHtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIGJlc3RDYW5kaWRhdGU7XG5cbiAgICAgICAgY2FuZGlkYXRlcy5zb3J0KCBwZi5hc2NlbmRpbmdTb3J0ICk7XG5cbiAgICAgICAgbGVuZ3RoID0gY2FuZGlkYXRlcy5sZW5ndGg7XG4gICAgICAgIGJlc3RDYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBsZW5ndGggLSAxIF07XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBjYW5kaWRhdGVzWyBpIF07XG4gICAgICAgICAgICBpZiAoIGNhbmRpZGF0ZS5yZXNvbHV0aW9uID49IHBmLmdldERwcigpICkge1xuICAgICAgICAgICAgICAgIGJlc3RDYW5kaWRhdGUgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGJlc3RDYW5kaWRhdGUgJiYgIXBmLmVuZHNXaXRoKCBwaWNJbWcuc3JjLCBiZXN0Q2FuZGlkYXRlLnVybCApICkge1xuICAgICAgICAgICAgaWYgKCBwZi5yZXN0cmljdHNNaXhlZENvbnRlbnQoKSAmJiBiZXN0Q2FuZGlkYXRlLnVybC5zdWJzdHIoMCwgXCJodHRwOlwiLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gXCJodHRwOlwiICkge1xuICAgICAgICAgICAgICAgIGlmICggd2luZG93LmNvbnNvbGUgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCBcIkJsb2NrZWQgbWl4ZWQgY29udGVudCBpbWFnZSBcIiArIGJlc3RDYW5kaWRhdGUudXJsICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwaWNJbWcuc3JjID0gYmVzdENhbmRpZGF0ZS51cmw7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudFNyYyBhdHRyaWJ1dGUgYW5kIHByb3BlcnR5IHRvIG1hdGNoXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3BpY3R1cmUucmVzcG9uc2l2ZWltYWdlcy5vcmcvI3RoZS1pbWctZWxlbWVudFxuICAgICAgICAgICAgICAgIHBpY0ltZy5jdXJyZW50U3JjID0gcGljSW1nLnNyYztcblxuICAgICAgICAgICAgICAgIHBmLmJhY2tmYWNlVmlzaWJpbGl0eUZpeCggcGljSW1nICk7XG4gICAgICAgICAgICAgICAgcGYuc2V0SW5oZXJlbnRTaXplKCBiZXN0Q2FuZGlkYXRlLnJlc29sdXRpb24sIHBpY0ltZyApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHBmLmFzY2VuZGluZ1NvcnQgPSBmdW5jdGlvbiggYSwgYiApIHtcbiAgICAgICAgcmV0dXJuIGEucmVzb2x1dGlvbiAtIGIucmVzb2x1dGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW4gSUU5LCA8c291cmNlPiBlbGVtZW50cyBnZXQgcmVtb3ZlZCBpZiB0aGV5IGFyZW4ndCBjaGlsZHJlbiBvZlxuICAgICAqIHZpZGVvIGVsZW1lbnRzLiBUaHVzLCB3ZSBjb25kaXRpb25hbGx5IHdyYXAgc291cmNlIGVsZW1lbnRzXG4gICAgICogdXNpbmcgPCEtLVtpZiBJRSA5XT48dmlkZW8gc3R5bGU9XCJkaXNwbGF5OiBub25lO1wiPjwhW2VuZGlmXS0tPlxuICAgICAqIGFuZCBtdXN0IGFjY291bnQgZm9yIHRoYXQgaGVyZSBieSBtb3ZpbmcgdGhvc2Ugc291cmNlIGVsZW1lbnRzXG4gICAgICogYmFjayBpbnRvIHRoZSBwaWN0dXJlIGVsZW1lbnQuXG4gICAgICovXG4gICAgcGYucmVtb3ZlVmlkZW9TaGltID0gZnVuY3Rpb24oIHBpY3R1cmUgKSB7XG4gICAgICAgIHZhciB2aWRlb3MgPSBwaWN0dXJlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcInZpZGVvXCIgKTtcbiAgICAgICAgaWYgKCB2aWRlb3MubGVuZ3RoICkge1xuICAgICAgICAgICAgdmFyIHZpZGVvID0gdmlkZW9zWyAwIF0sXG4gICAgICAgICAgICAgICAgdnNvdXJjZXMgPSB2aWRlby5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzb3VyY2VcIiApO1xuICAgICAgICAgICAgd2hpbGUgKCB2c291cmNlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAgICAgcGljdHVyZS5pbnNlcnRCZWZvcmUoIHZzb3VyY2VzWyAwIF0sIHZpZGVvICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHZpZGVvIGVsZW1lbnQgb25jZSB3ZSdyZSBmaW5pc2hlZCByZW1vdmluZyBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgIHZpZGVvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHZpZGVvICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgYGltZ2AgZWxlbWVudHMsIGFuZCBhZGQgdGhlbSB0byB0aGUgY2FuZGlkYXRlIGxpc3QgaWYgdGhleSBoYXZlXG4gICAgICogYSBgcGljdHVyZWAgcGFyZW50LCBhIGBzaXplc2AgYXR0cmlidXRlIGluIGJhc2ljIGBzcmNzZXRgIHN1cHBvcnRpbmcgYnJvd3NlcnMsXG4gICAgICogYSBgc3Jjc2V0YCBhdHRyaWJ1dGUgYXQgYWxsLCBhbmQgdGhleSBoYXZlbuKAmXQgYmVlbiBldmFsdWF0ZWQgYWxyZWFkeS5cbiAgICAgKi9cbiAgICBwZi5nZXRBbGxFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZWxlbXMgPSBbXSxcbiAgICAgICAgICAgIGltZ3MgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiaW1nXCIgKTtcblxuICAgICAgICBmb3IgKCB2YXIgaCA9IDAsIGxlbiA9IGltZ3MubGVuZ3RoOyBoIDwgbGVuOyBoKysgKSB7XG4gICAgICAgICAgICB2YXIgY3VyckltZyA9IGltZ3NbIGggXTtcblxuICAgICAgICAgICAgaWYgKCBjdXJySW1nLnBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJQSUNUVVJFXCIgfHxcbiAgICAgICAgICAgICAgICAoIGN1cnJJbWcuZ2V0QXR0cmlidXRlKCBcInNyY3NldFwiICkgIT09IG51bGwgKSB8fCBjdXJySW1nWyBwZi5ucyBdICYmIGN1cnJJbWdbIHBmLm5zIF0uc3Jjc2V0ICE9PSBudWxsICkge1xuICAgICAgICAgICAgICAgIGVsZW1zLnB1c2goIGN1cnJJbWcgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbXM7XG4gICAgfTtcblxuICAgIHBmLmdldE1hdGNoID0gZnVuY3Rpb24oIGltZywgcGljdHVyZSApIHtcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBwaWN0dXJlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgICBtYXRjaDtcblxuICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggY2hpbGQsIGFuZCBpZiB0aGV5IGhhdmUgbWVkaWEgcXVlcmllcywgZXZhbHVhdGUgdGhlbVxuICAgICAgICBmb3IgKCB2YXIgaiA9IDAsIHNsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaiA8IHNsZW47IGorKyApIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzWyBqIF07XG5cbiAgICAgICAgICAgIC8vIGlnbm9yZSBub24tZWxlbWVudCBub2Rlc1xuICAgICAgICAgICAgaWYgKCBzb3VyY2Uubm9kZVR5cGUgIT09IDEgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpdHRpbmcgdGhlIGBpbWdgIGVsZW1lbnQgdGhhdCBzdGFydGVkIGV2ZXJ5dGhpbmcgc3RvcHMgdGhlIHNlYXJjaCBmb3IgYHNvdXJjZXNgLlxuICAgICAgICAgICAgLy8gSWYgbm8gcHJldmlvdXMgYHNvdXJjZWAgbWF0Y2hlcywgdGhlIGBpbWdgIGl0c2VsZiBpcyBldmFsdWF0ZWQgbGF0ZXIuXG4gICAgICAgICAgICBpZiAoIHNvdXJjZSA9PT0gaW1nICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWdub3JlIG5vbi1gc291cmNlYCBub2Rlc1xuICAgICAgICAgICAgaWYgKCBzb3VyY2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJTT1VSQ0VcIiApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBzb3VyY2UgZWxlbWVudCB0aGF0IGhhcyB0aGUgYHNyY2AgcHJvcGVydHkgc2V0LCB0aHJvdyBhIHdhcm5pbmcgaW4gdGhlIGNvbnNvbGVcbiAgICAgICAgICAgIGlmICggc291cmNlLmdldEF0dHJpYnV0ZSggXCJzcmNcIiApICE9PSBudWxsICYmIHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlIGBzcmNgIGF0dHJpYnV0ZSBpcyBpbnZhbGlkIG9uIGBwaWN0dXJlYCBgc291cmNlYCBlbGVtZW50OyBpbnN0ZWFkLCB1c2UgYHNyY3NldGAuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWVkaWEgPSBzb3VyY2UuZ2V0QXR0cmlidXRlKCBcIm1lZGlhXCIgKTtcblxuICAgICAgICAgICAgLy8gaWYgc291cmNlIGRvZXMgbm90IGhhdmUgYSBzcmNzZXQgYXR0cmlidXRlLCBza2lwXG4gICAgICAgICAgICBpZiAoICFzb3VyY2UuZ2V0QXR0cmlidXRlKCBcInNyY3NldFwiICkgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWVkaWEgc3BlY2lmaWVkLCBPUiB3Lm1hdGNoTWVkaWEgaXMgc3VwcG9ydGVkXG4gICAgICAgICAgICBpZiAoICggIW1lZGlhIHx8IHBmLm1hdGNoZXNNZWRpYSggbWVkaWEgKSApICkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlU3VwcG9ydGVkID0gcGYudmVyaWZ5VHlwZVN1cHBvcnQoIHNvdXJjZSApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCB0eXBlU3VwcG9ydGVkID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggdHlwZVN1cHBvcnRlZCA9PT0gXCJwZW5kaW5nXCIgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBpY3R1cmVmaWxsKCBvcHQgKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyxcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBmaXJzdE1hdGNoLFxuICAgICAgICAgICAgY2FuZGlkYXRlcyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHQgfHwge307XG5cbiAgICAgICAgZWxlbWVudHMgPSBvcHRpb25zLmVsZW1lbnRzIHx8IHBmLmdldEFsbEVsZW1lbnRzKCk7XG5cbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBlbGVtZW50c1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIHBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBwbGVuOyBpKysgKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbIGkgXTtcbiAgICAgICAgICAgIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGZpcnN0TWF0Y2ggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5kaWRhdGVzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBza2lwIG5vbi1gaW1nYCBub2Rlc1xuICAgICAgICAgICAgaWYgKCBlbGVtZW50Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09IFwiSU1HXCIgKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGV4cGFuZG8gZm9yIGNhY2hpbmcgZGF0YSBvbiB0aGUgaW1nXG4gICAgICAgICAgICBpZiAoICFlbGVtZW50WyBwZi5ucyBdICkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRbIHBmLm5zIF0gPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiBldmFsdWF0ZWQsIHNraXAgaXQgdW5sZXNzXG4gICAgICAgICAgICAvLyBgb3B0aW9ucy5yZWV2YWx1YXRlYCBpcyBzZXQgdG8gdHJ1ZSAoIHRoaXMsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gaXMgc2V0IHRvIHRydWUgd2hlbiBydW5uaW5nIGBwaWN0dXJlZmlsbGAgb24gYHJlc2l6ZWAgKS5cbiAgICAgICAgICAgIGlmICggIW9wdGlvbnMucmVldmFsdWF0ZSAmJiBlbGVtZW50WyBwZi5ucyBdLmV2YWx1YXRlZCApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYGltZ2AgaXMgaW4gYSBgcGljdHVyZWAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCBwYXJlbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJQSUNUVVJFXCIgKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJRTkgdmlkZW8gd29ya2Fyb3VuZFxuICAgICAgICAgICAgICAgIHBmLnJlbW92ZVZpZGVvU2hpbSggcGFyZW50ICk7XG5cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIGZpcnN0IG1hdGNoIHdoaWNoIG1pZ2h0IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgZmFsc2UgaWYgdGhlcmUgaXMgYSBwZW5kaW5nIHNvdXJjZVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhlIHJldHVybiB0eXBlIGhlcmUgaXMgYnJ1dGFsLCBjbGVhbnVwXG4gICAgICAgICAgICAgICAgZmlyc3RNYXRjaCA9IHBmLmdldE1hdGNoKCBlbGVtZW50LCBwYXJlbnQgKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBzb3VyY2VzIGFyZSBwZW5kaW5nIGluIHRoaXMgcGljdHVyZSBkdWUgdG8gYXN5bmMgdHlwZSB0ZXN0KHMpXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBldmFsdWF0ZWQgYXR0ciBhbmQgc2tpcCBmb3Igbm93ICggdGhlIHBlbmRpbmcgdGVzdCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gcmVydW4gcGljdHVyZWZpbGwgb24gdGhpcyBlbGVtZW50IHdoZW4gY29tcGxldGUpXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJzdE1hdGNoID09PSBmYWxzZSApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdE1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWNoZSBhbmQgcmVtb3ZlIGBzcmNzZXRgIGlmIHByZXNlbnQgYW5kIHdl4oCZcmUgZ29pbmcgdG8gYmUgZG9pbmcgYHBpY3R1cmVgL2BzcmNzZXRgL2BzaXplc2AgcG9seWZpbGxpbmcgdG8gaXQuXG4gICAgICAgICAgICBpZiAoIHBhcmVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlBJQ1RVUkVcIiB8fFxuICAgICAgICAgICAgICAgICggZWxlbWVudC5zcmNzZXQgJiYgIXBmLnNyY3NldFN1cHBvcnRlZCApIHx8XG4gICAgICAgICAgICAgICAgKCAhcGYuc2l6ZXNTdXBwb3J0ZWQgJiYgKCBlbGVtZW50LnNyY3NldCAmJiBlbGVtZW50LnNyY3NldC5pbmRleE9mKFwid1wiKSA+IC0xICkgKSApIHtcbiAgICAgICAgICAgICAgICBwZi5kb2RnZVNyY3NldCggZWxlbWVudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGZpcnN0TWF0Y2ggKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHBmLnByb2Nlc3NTb3VyY2VTZXQoIGZpcnN0TWF0Y2ggKTtcbiAgICAgICAgICAgICAgICBwZi5hcHBseUJlc3RDYW5kaWRhdGUoIGNhbmRpZGF0ZXMsIGVsZW1lbnQgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gc291cmNlcyBtYXRjaGVkLCBzbyB3ZeKAmXJlIGRvd24gdG8gcHJvY2Vzc2luZyB0aGUgaW5uZXIgYGltZ2AgYXMgYSBzb3VyY2UuXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlcyA9IHBmLnByb2Nlc3NTb3VyY2VTZXQoIGVsZW1lbnQgKTtcblxuICAgICAgICAgICAgICAgIGlmICggZWxlbWVudC5zcmNzZXQgPT09IHVuZGVmaW5lZCB8fCBlbGVtZW50WyBwZi5ucyBdLnNyY3NldCApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWl0aGVyIGBzcmNzZXRgIGlzIGNvbXBsZXRlbHkgdW5zdXBwb3J0ZWQsIG9yIHdlIG5lZWQgdG8gcG9seWZpbGwgYHNpemVzYCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICAgICAgICBwZi5hcHBseUJlc3RDYW5kaWRhdGUoIGNhbmRpZGF0ZXMsIGVsZW1lbnQgKTtcbiAgICAgICAgICAgICAgICB9IC8vIEVsc2UsIHJlc29sdXRpb24tb25seSBgc3Jjc2V0YCBpcyBzdXBwb3J0ZWQgbmF0aXZlbHkuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBldmFsdWF0ZWQgdG8gdHJ1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXBhcnNpbmdcbiAgICAgICAgICAgIGVsZW1lbnRbIHBmLm5zIF0uZXZhbHVhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgcGljdHVyZSBwb2x5ZmlsbCBieSBwb2xsaW5nIHRoZSBkb2N1bWVudCBhbmQgcnVubmluZ1xuICAgICAqIHRoZSBwb2x5ZmlsbCBldmVyeSAyNTBtcyB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuXG4gICAgICogQWxzbyBhdHRhY2hlcyBwaWN0dXJlZmlsbCBvbiByZXNpemVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBydW5QaWN0dXJlZmlsbCgpIHtcbiAgICAgICAgcGljdHVyZWZpbGwoKTtcbiAgICAgICAgdmFyIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZywgc3RvcCBjaGVja2luZyBmb3IgbmV3IGltYWdlc1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlZC9kb21yZWFkeS9ibG9iL21hc3Rlci9yZWFkeS5qcyNMMTVcbiAgICAgICAgICAgIHBpY3R1cmVmaWxsKCk7XG5cbiAgICAgICAgICAgIGlmICggL15sb2FkZWR8Xml8XmMvLnRlc3QoIGRvYy5yZWFkeVN0YXRlICkgKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCggaW50ZXJ2YWxJZCApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjUwICk7XG5cbiAgICAgICAgZnVuY3Rpb24gY2hlY2tSZXNpemUoKSB7XG4gICAgICAgICAgICB2YXIgcmVzaXplVGhyb3R0bGU7XG5cbiAgICAgICAgICAgIGlmICggIXcuX3BpY3R1cmVmaWxsV29ya2luZyApIHtcbiAgICAgICAgICAgICAgICB3Ll9waWN0dXJlZmlsbFdvcmtpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHcuY2xlYXJUaW1lb3V0KCByZXNpemVUaHJvdHRsZSApO1xuICAgICAgICAgICAgICAgIHJlc2l6ZVRocm90dGxlID0gdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcGljdHVyZWZpbGwoeyByZWV2YWx1YXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICB3Ll9waWN0dXJlZmlsbFdvcmtpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCA2MCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB3LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgICAgICAgICB3LmFkZEV2ZW50TGlzdGVuZXIoIFwicmVzaXplXCIsIGNoZWNrUmVzaXplLCBmYWxzZSApO1xuICAgICAgICB9IGVsc2UgaWYgKCB3LmF0dGFjaEV2ZW50ICkge1xuICAgICAgICAgICAgdy5hdHRhY2hFdmVudCggXCJvbnJlc2l6ZVwiLCBjaGVja1Jlc2l6ZSApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcnVuUGljdHVyZWZpbGwoKTtcblxuICAgIC8qIGV4cG9zZSBtZXRob2RzIGZvciB0ZXN0aW5nICovXG4gICAgcGljdHVyZWZpbGwuXyA9IHBmO1xuXG4gICAgLyogZXhwb3NlIHBpY3R1cmVmaWxsICovXG4gICAgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcbiAgICAgICAgLy8gQ29tbW9uSlMsIGp1c3QgZXhwb3J0XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcGljdHVyZWZpbGw7XG4gICAgfSBlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG4gICAgICAgIC8vIEFNRCBzdXBwb3J0XG4gICAgICAgIGRlZmluZSggZnVuY3Rpb24oKSB7IHJldHVybiBwaWN0dXJlZmlsbDsgfSApO1xuICAgIH1cblxuICAgIGlmICggdHlwZW9mIHcgPT09IFwib2JqZWN0XCIgKSB7XG4gICAgICAgIC8vIElmIG5vIEFNRCBhbmQgd2UgYXJlIGluIHRoZSBicm93c2VyLCBhdHRhY2ggdG8gd2luZG93XG4gICAgICAgIHcucGljdHVyZWZpbGwgPSBwaWN0dXJlZmlsbDtcbiAgICB9XG5cbn0gKSggd2luZG93LCB3aW5kb3cuZG9jdW1lbnQsIG5ldyB3aW5kb3cuSW1hZ2UoKSApOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBXZWJGb250SlNPTkxvYWRlciAwLjAuMiB8IEBsaWNlbnNlIElTQyAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIC8vIElmIHRoZSBlbnYgaXMgYnJvd3NlcmlmeSwgZXhwb3J0IHRoZSBmYWN0b3J5IHVzaW5nIHRoZSBtb2R1bGUgb2JqZWN0LlxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZ2xvYmFsKTtcblxuICAgICAgICAvLyBJZiB0aGUgZW52IGlzIEFNRCwgcmVnaXN0ZXIgdGhlIE1vZHVsZSBhcyAnd2ViZm9udGpzb25sb2FkZXInLlxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFwid2ViZm9udGpzb25sb2FkZXJcIiwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KGdsb2JhbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHRoZSBlbnYgaXMgYSBicm93c2VyKHdpdGhvdXQgQ0pTIG9yIEFNRCBzdXBwb3J0KSwgZXhwb3J0IHRoZSBmYWN0b3J5IGludG8gdGhlIGdsb2JhbCB3aW5kb3cgb2JqZWN0LlxuICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbC5XZWJGb250TG9hZGVyID0gZmFjdG9yeShnbG9iYWwpO1xuICAgIH1cbn0pKHdpbmRvdywgZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIGhlYWRFbGVtZW50ID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICB2YXIgc3RvcmFnZSA9IGdsb2JhbC5sb2NhbFN0b3JhZ2U7XG4gICAgdmFyIHNyY0tleSA9IFwiX2ZvbnRfc3JjXCI7XG4gICAgdmFyIHRpbWVTdGFtcEtleSA9IFwiX2ZvbnRfdGltZXN0YW1wXCI7XG5cbiAgICAvKlxuICAgICAqIFdlYkZvbnRMb2FkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7T2JqZWN0fSBUaGUgb3B0aW9ucyBPYmplY3Qgd2hpY2ggaW5pdGlhbGl6ZXMgdGhlIGxvYWRlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5ldyBXZWJGb250TG9hZGVyKHtcbiAgICAgKiAgICAgIHVybDogJ2ZvbnRzL3dlYmZvbnQuanNvbicsIC8vIFBhdGggdG8gdGhlIEpTT05QIGZpbGUuXG4gICAgICogICAgICB0aW1lU3RhbXA6ICc/dD0wMTA3MjAxNScsIC8vIFRpbWVzdGFtcCBmb3IgdGhlIGNhY2hlLlxuICAgICAqICAgICAgSlNPTlBDYWxsYmFja05hbWU6ICAnY2FsbGJhY2snLCAvL0pTT05QIGNhbGxiYWNrIG5hbWUuXG4gICAgICogfSk7XG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIFdlYkZvbnRMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdGhpcy51cmwgPSBvcHRpb25zLnVybDtcbiAgICAgICAgdGhpcy50aW1lU3RhbXAgPSBvcHRpb25zLnRpbWVTdGFtcCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IG9wdGlvbnMubmFtZXNwYWNlIHx8IFwiV2ViRm9udEpTT05Mb2FkZXJcIjtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tOYW1lID0gb3B0aW9ucy5KU09OUENhbGxiYWNrTmFtZSB8fCBcIldlYkZvbnRKc29uQ2FsbEJhY2tcIjtcblxuICAgICAgICBpZiAoIXRoaXMuX2hhc1JlcXVpcmVkQ29uc3RhbnRzQW5kQVBJcygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdldFdlYkZvbnRTdHlsZXMoKTtcbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX2hhc1JlcXVpcmVkQ29uc3RhbnRzQW5kQVBJcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvb2wgPSB0cnVlO1xuXG4gICAgICAgIGlmICghX3N1cHBvcnRzTG9jYWxTdG9yYWdlQVBJKCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIldlYkZvbnRKU09OTG9hZGVyOiBUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbG9jYWxTdG9yYWdlIEFQSSwgYWJvcnRpbmcuXCIpO1xuXG4gICAgICAgICAgICBib29sID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnVybCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiV2ViRm9udEpTT05Mb2FkZXI6IE5vIFVSTCB3YXMgZm91bmQgaW4gdGhlIG9wdGlvbnMgb2JqZWN0LCBhYm9ydGluZy5cIik7XG5cbiAgICAgICAgICAgIGJvb2wgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib29sO1xuICAgIH07XG4gICAgdmFyIF9zdXBwb3J0c0xvY2FsU3RvcmFnZUFQSSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleSA9IFwidGVzdFwiO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCAxKTtcbiAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdlYkZvbnRMb2FkZXIucHJvdG90eXBlLmdldFdlYkZvbnRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xvY2FsU3RvcmFnZVNyY1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUlubGluZVN0eWxlcygpLl9leGVjdXRlQ2FsbEJhY2soKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFN0eWxlc0Zyb21KU09OUCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFdlYkZvbnRMb2FkZXIucHJvdG90eXBlLl9pc0xvY2FsU3RvcmFnZVNyY1ZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2U7XG5cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2UuZ2V0SXRlbShuYW1lc3BhY2UgKyBzcmNLZXkpICYmIHN0b3JhZ2UuZ2V0SXRlbShuYW1lc3BhY2UgKyB0aW1lU3RhbXBLZXkpID09PSB0aGlzLnRpbWVTdGFtcDtcbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX2V4ZWN1dGVDYWxsQmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFjaztcblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBXZWJGb250TG9hZGVyLnByb3RvdHlwZS5fZ2V0U3R5bGVzRnJvbUpTT05QID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBSZW5ldyB0aGUgdGltZXN0YW1wLlxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UgKyB0aW1lU3RhbXBLZXksIHRoaXMudGltZVN0YW1wKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBKU09OUCBjYWxsYmFjayBhY2Nlc3NpYmxlLlxuICAgICAgICBnbG9iYWxbdGhpcy5jYWxsYmFja05hbWVdID0gdGhpcy5fSlNPTlBDYWxsYmFjay5iaW5kKHRoaXMpO1xuXG4gICAgICAgIC8vIExvYWQgdGhlIEpTT05QIGFuZCBydW4gdGhlIGNhbGxiYWNrLlxuICAgICAgICB0aGlzLl9sb2FkSlNPTlAoKTtcbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX0pTT05QQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBjc3MgPSByZXMuY3NzO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbG9jYWxTdG9yYWdlIGNhY2hlLlxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0odGhpcy5uYW1lc3BhY2UgKyBzcmNLZXksIGNzcyk7XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlSW5saW5lU3R5bGVzKCk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgZ2xvYmFsW3RoaXMuY2FsbGJhY2tOYW1lXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgV2ViRm9udExvYWRlci5wcm90b3R5cGUuX2xvYWRKU09OUCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgZWxlbWVudC5cbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzY3JpcHQudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgIHNjcmlwdC5zcmMgPSB0aGlzLnVybDtcbiAgICAgICAgaGVhZEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgaGVhZEVsZW1lbnQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhcyB0aGUgSlNPTlAgZmlsZSB3YXMgbG9hZGVkLlxuICAgICAgICBzY3JpcHQub25sb2FkID0gdGhpcy5fZXhlY3V0ZUNhbGxCYWNrLmJpbmQodGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFdlYkZvbnRMb2FkZXIucHJvdG90eXBlLl9jcmVhdGVJbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICAgICAgdmFyIGNzcyA9IHN0b3JhZ2UuZ2V0SXRlbShuYW1lc3BhY2UgKyBzcmNLZXkpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc3R5bGUgZWxlbWVudC5cbiAgICAgICAgdmFyIHN0eWxlID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGUudHlwZSA9IFwidGV4dC9jc3NcIjtcbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICBoZWFkRWxlbWVudC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIHJldHVybiBXZWJGb250TG9hZGVyO1xufSk7XG4iXX0=
